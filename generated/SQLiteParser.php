<?php

/*
 * Generated from grammar/SQLiteParser.g4 by ANTLR 4.10
 */

namespace Doctrine\DBAL\Generated {
	use Antlr\Antlr4\Runtime\Atn\ATN;
	use Antlr\Antlr4\Runtime\Atn\ATNDeserializer;
	use Antlr\Antlr4\Runtime\Atn\ParserATNSimulator;
	use Antlr\Antlr4\Runtime\Dfa\DFA;
	use Antlr\Antlr4\Runtime\Error\Exceptions\FailedPredicateException;
	use Antlr\Antlr4\Runtime\Error\Exceptions\NoViableAltException;
	use Antlr\Antlr4\Runtime\PredictionContexts\PredictionContextCache;
	use Antlr\Antlr4\Runtime\Error\Exceptions\RecognitionException;
	use Antlr\Antlr4\Runtime\RuleContext;
	use Antlr\Antlr4\Runtime\Token;
	use Antlr\Antlr4\Runtime\TokenStream;
	use Antlr\Antlr4\Runtime\Vocabulary;
	use Antlr\Antlr4\Runtime\VocabularyImpl;
	use Antlr\Antlr4\Runtime\RuntimeMetaData;
	use Antlr\Antlr4\Runtime\Parser;

	final class SQLiteParser extends Parser
	{
		public const SCOL = 1, DOT = 2, OPEN_PAR = 3, CLOSE_PAR = 4, COMMA = 5, 
               ASSIGN = 6, STAR = 7, PLUS = 8, MINUS = 9, TILDE = 10, PIPE2 = 11, 
               DIV = 12, MOD = 13, LT2 = 14, GT2 = 15, AMP = 16, PIPE = 17, 
               LT = 18, LT_EQ = 19, GT = 20, GT_EQ = 21, EQ = 22, NOT_EQ1 = 23, 
               NOT_EQ2 = 24, ABORT_ = 25, ACTION_ = 26, ADD_ = 27, AFTER_ = 28, 
               ALL_ = 29, ALTER_ = 30, ANALYZE_ = 31, AND_ = 32, AS_ = 33, 
               ASC_ = 34, ATTACH_ = 35, AUTOINCREMENT_ = 36, BEFORE_ = 37, 
               BEGIN_ = 38, BETWEEN_ = 39, BY_ = 40, CASCADE_ = 41, CASE_ = 42, 
               CAST_ = 43, CHECK_ = 44, COLLATE_ = 45, COLUMN_ = 46, COMMIT_ = 47, 
               CONFLICT_ = 48, CONSTRAINT_ = 49, CREATE_ = 50, CROSS_ = 51, 
               CURRENT_DATE_ = 52, CURRENT_TIME_ = 53, CURRENT_TIMESTAMP_ = 54, 
               DATABASE_ = 55, DEFAULT_ = 56, DEFERRABLE_ = 57, DEFERRED_ = 58, 
               DELETE_ = 59, DESC_ = 60, DETACH_ = 61, DISTINCT_ = 62, DROP_ = 63, 
               EACH_ = 64, ELSE_ = 65, END_ = 66, ESCAPE_ = 67, EXCEPT_ = 68, 
               EXCLUSIVE_ = 69, EXISTS_ = 70, EXPLAIN_ = 71, FAIL_ = 72, 
               FOR_ = 73, FOREIGN_ = 74, FROM_ = 75, FULL_ = 76, GLOB_ = 77, 
               GROUP_ = 78, HAVING_ = 79, IF_ = 80, IGNORE_ = 81, IMMEDIATE_ = 82, 
               IN_ = 83, INDEX_ = 84, INDEXED_ = 85, INITIALLY_ = 86, INNER_ = 87, 
               INSERT_ = 88, INSTEAD_ = 89, INTERSECT_ = 90, INTO_ = 91, 
               IS_ = 92, ISNULL_ = 93, JOIN_ = 94, KEY_ = 95, LEFT_ = 96, 
               LIKE_ = 97, LIMIT_ = 98, MATCH_ = 99, NATURAL_ = 100, NO_ = 101, 
               NOT_ = 102, NOTNULL_ = 103, NULL_ = 104, OF_ = 105, OFFSET_ = 106, 
               ON_ = 107, OR_ = 108, ORDER_ = 109, OUTER_ = 110, PLAN_ = 111, 
               PRAGMA_ = 112, PRIMARY_ = 113, QUERY_ = 114, RAISE_ = 115, 
               RECURSIVE_ = 116, REFERENCES_ = 117, REGEXP_ = 118, REINDEX_ = 119, 
               RELEASE_ = 120, RENAME_ = 121, REPLACE_ = 122, RESTRICT_ = 123, 
               RETURNING_ = 124, RIGHT_ = 125, ROLLBACK_ = 126, ROW_ = 127, 
               ROWS_ = 128, SAVEPOINT_ = 129, SELECT_ = 130, SET_ = 131, 
               TABLE_ = 132, TEMP_ = 133, TEMPORARY_ = 134, THEN_ = 135, 
               TO_ = 136, TRANSACTION_ = 137, TRIGGER_ = 138, UNION_ = 139, 
               UNIQUE_ = 140, UPDATE_ = 141, USING_ = 142, VACUUM_ = 143, 
               VALUES_ = 144, VIEW_ = 145, VIRTUAL_ = 146, WHEN_ = 147, 
               WHERE_ = 148, WITH_ = 149, WITHOUT_ = 150, FIRST_VALUE_ = 151, 
               OVER_ = 152, PARTITION_ = 153, RANGE_ = 154, PRECEDING_ = 155, 
               UNBOUNDED_ = 156, CURRENT_ = 157, FOLLOWING_ = 158, CUME_DIST_ = 159, 
               DENSE_RANK_ = 160, LAG_ = 161, LAST_VALUE_ = 162, LEAD_ = 163, 
               NTH_VALUE_ = 164, NTILE_ = 165, PERCENT_RANK_ = 166, RANK_ = 167, 
               ROW_NUMBER_ = 168, GENERATED_ = 169, ALWAYS_ = 170, STORED_ = 171, 
               TRUE_ = 172, FALSE_ = 173, WINDOW_ = 174, NULLS_ = 175, FIRST_ = 176, 
               LAST_ = 177, FILTER_ = 178, GROUPS_ = 179, EXCLUDE_ = 180, 
               TIES_ = 181, OTHERS_ = 182, DO_ = 183, NOTHING_ = 184, IDENTIFIER = 185, 
               NUMERIC_LITERAL = 186, BIND_PARAMETER = 187, STRING_LITERAL = 188, 
               BLOB_LITERAL = 189, SINGLE_LINE_COMMENT = 190, MULTILINE_COMMENT = 191, 
               SPACES = 192, UNEXPECTED_CHAR = 193;

		public const RULE_parse = 0, RULE_sql_stmt_list = 1, RULE_sql_stmt = 2, 
               RULE_alter_table_stmt = 3, RULE_analyze_stmt = 4, RULE_attach_stmt = 5, 
               RULE_begin_stmt = 6, RULE_commit_stmt = 7, RULE_rollback_stmt = 8, 
               RULE_savepoint_stmt = 9, RULE_release_stmt = 10, RULE_create_index_stmt = 11, 
               RULE_indexed_column = 12, RULE_create_table_stmt = 13, RULE_column_def = 14, 
               RULE_type_name = 15, RULE_column_constraint = 16, RULE_signed_number = 17, 
               RULE_table_constraint = 18, RULE_foreign_key_clause = 19, 
               RULE_conflict_clause = 20, RULE_create_trigger_stmt = 21, 
               RULE_create_view_stmt = 22, RULE_create_virtual_table_stmt = 23, 
               RULE_with_clause = 24, RULE_cte_table_name = 25, RULE_recursive_cte = 26, 
               RULE_common_table_expression = 27, RULE_delete_stmt = 28, 
               RULE_delete_stmt_limited = 29, RULE_detach_stmt = 30, RULE_drop_stmt = 31, 
               RULE_expr = 32, RULE_raise_function = 33, RULE_literal_value = 34, 
               RULE_insert_stmt = 35, RULE_returning_clause = 36, RULE_upsert_clause = 37, 
               RULE_pragma_stmt = 38, RULE_pragma_value = 39, RULE_reindex_stmt = 40, 
               RULE_select_stmt = 41, RULE_join_clause = 42, RULE_select_core = 43, 
               RULE_factored_select_stmt = 44, RULE_simple_select_stmt = 45, 
               RULE_compound_select_stmt = 46, RULE_table_or_subquery = 47, 
               RULE_result_column = 48, RULE_join_operator = 49, RULE_join_constraint = 50, 
               RULE_compound_operator = 51, RULE_update_stmt = 52, RULE_column_name_list = 53, 
               RULE_update_stmt_limited = 54, RULE_qualified_table_name = 55, 
               RULE_vacuum_stmt = 56, RULE_filter_clause = 57, RULE_window_defn = 58, 
               RULE_over_clause = 59, RULE_frame_spec = 60, RULE_frame_clause = 61, 
               RULE_simple_function_invocation = 62, RULE_aggregate_function_invocation = 63, 
               RULE_window_function_invocation = 64, RULE_common_table_stmt = 65, 
               RULE_order_by_stmt = 66, RULE_limit_stmt = 67, RULE_ordering_term = 68, 
               RULE_asc_desc = 69, RULE_frame_left = 70, RULE_frame_right = 71, 
               RULE_frame_single = 72, RULE_window_function = 73, RULE_offset = 74, 
               RULE_default_value = 75, RULE_partition_by = 76, RULE_order_by_expr = 77, 
               RULE_order_by_expr_asc_desc = 78, RULE_expr_asc_desc = 79, 
               RULE_initial_select = 80, RULE_recursive_select = 81, RULE_unary_operator = 82, 
               RULE_error_message = 83, RULE_module_argument = 84, RULE_column_alias = 85, 
               RULE_keyword = 86, RULE_name = 87, RULE_function_name = 88, 
               RULE_schema_name = 89, RULE_table_name = 90, RULE_table_or_index_name = 91, 
               RULE_column_name = 92, RULE_collation_name = 93, RULE_foreign_table = 94, 
               RULE_index_name = 95, RULE_trigger_name = 96, RULE_view_name = 97, 
               RULE_module_name = 98, RULE_pragma_name = 99, RULE_savepoint_name = 100, 
               RULE_table_alias = 101, RULE_transaction_name = 102, RULE_window_name = 103, 
               RULE_alias = 104, RULE_filename = 105, RULE_base_window_name = 106, 
               RULE_simple_func = 107, RULE_aggregate_func = 108, RULE_table_function_name = 109, 
               RULE_any_name = 110;

		/**
		 * @var array<string>
		 */
		public const RULE_NAMES = [
			'parse', 'sql_stmt_list', 'sql_stmt', 'alter_table_stmt', 'analyze_stmt', 
			'attach_stmt', 'begin_stmt', 'commit_stmt', 'rollback_stmt', 'savepoint_stmt', 
			'release_stmt', 'create_index_stmt', 'indexed_column', 'create_table_stmt', 
			'column_def', 'type_name', 'column_constraint', 'signed_number', 'table_constraint', 
			'foreign_key_clause', 'conflict_clause', 'create_trigger_stmt', 'create_view_stmt', 
			'create_virtual_table_stmt', 'with_clause', 'cte_table_name', 'recursive_cte', 
			'common_table_expression', 'delete_stmt', 'delete_stmt_limited', 'detach_stmt', 
			'drop_stmt', 'expr', 'raise_function', 'literal_value', 'insert_stmt', 
			'returning_clause', 'upsert_clause', 'pragma_stmt', 'pragma_value', 'reindex_stmt', 
			'select_stmt', 'join_clause', 'select_core', 'factored_select_stmt', 
			'simple_select_stmt', 'compound_select_stmt', 'table_or_subquery', 'result_column', 
			'join_operator', 'join_constraint', 'compound_operator', 'update_stmt', 
			'column_name_list', 'update_stmt_limited', 'qualified_table_name', 'vacuum_stmt', 
			'filter_clause', 'window_defn', 'over_clause', 'frame_spec', 'frame_clause', 
			'simple_function_invocation', 'aggregate_function_invocation', 'window_function_invocation', 
			'common_table_stmt', 'order_by_stmt', 'limit_stmt', 'ordering_term', 
			'asc_desc', 'frame_left', 'frame_right', 'frame_single', 'window_function', 
			'offset', 'default_value', 'partition_by', 'order_by_expr', 'order_by_expr_asc_desc', 
			'expr_asc_desc', 'initial_select', 'recursive_select', 'unary_operator', 
			'error_message', 'module_argument', 'column_alias', 'keyword', 'name', 
			'function_name', 'schema_name', 'table_name', 'table_or_index_name', 
			'column_name', 'collation_name', 'foreign_table', 'index_name', 'trigger_name', 
			'view_name', 'module_name', 'pragma_name', 'savepoint_name', 'table_alias', 
			'transaction_name', 'window_name', 'alias', 'filename', 'base_window_name', 
			'simple_func', 'aggregate_func', 'table_function_name', 'any_name'
		];

		/**
		 * @var array<string|null>
		 */
		private const LITERAL_NAMES = [
		    null, "';'", "'.'", "'('", "')'", "','", "'='", "'*'", "'+'", "'-'", 
		    "'~'", "'||'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'|'", "'<'", 
		    "'<='", "'>'", "'>='", "'=='", "'!='", "'<>'", "'ABORT'", "'ACTION'", 
		    "'ADD'", "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'AS'", 
		    "'ASC'", "'ATTACH'", "'AUTOINCREMENT'", "'BEFORE'", "'BEGIN'", "'BETWEEN'", 
		    "'BY'", "'CASCADE'", "'CASE'", "'CAST'", "'CHECK'", "'COLLATE'", "'COLUMN'", 
		    "'COMMIT'", "'CONFLICT'", "'CONSTRAINT'", "'CREATE'", "'CROSS'", "'CURRENT_DATE'", 
		    "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'DATABASE'", "'DEFAULT'", 
		    "'DEFERRABLE'", "'DEFERRED'", "'DELETE'", "'DESC'", "'DETACH'", "'DISTINCT'", 
		    "'DROP'", "'EACH'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUSIVE'", 
		    "'EXISTS'", "'EXPLAIN'", "'FAIL'", "'FOR'", "'FOREIGN'", "'FROM'", 
		    "'FULL'", "'GLOB'", "'GROUP'", "'HAVING'", "'IF'", "'IGNORE'", "'IMMEDIATE'", 
		    "'IN'", "'INDEX'", "'INDEXED'", "'INITIALLY'", "'INNER'", "'INSERT'", 
		    "'INSTEAD'", "'INTERSECT'", "'INTO'", "'IS'", "'ISNULL'", "'JOIN'", 
		    "'KEY'", "'LEFT'", "'LIKE'", "'LIMIT'", "'MATCH'", "'NATURAL'", "'NO'", 
		    "'NOT'", "'NOTNULL'", "'NULL'", "'OF'", "'OFFSET'", "'ON'", "'OR'", 
		    "'ORDER'", "'OUTER'", "'PLAN'", "'PRAGMA'", "'PRIMARY'", "'QUERY'", 
		    "'RAISE'", "'RECURSIVE'", "'REFERENCES'", "'REGEXP'", "'REINDEX'", 
		    "'RELEASE'", "'RENAME'", "'REPLACE'", "'RESTRICT'", "'RETURNING'", 
		    "'RIGHT'", "'ROLLBACK'", "'ROW'", "'ROWS'", "'SAVEPOINT'", "'SELECT'", 
		    "'SET'", "'TABLE'", "'TEMP'", "'TEMPORARY'", "'THEN'", "'TO'", "'TRANSACTION'", 
		    "'TRIGGER'", "'UNION'", "'UNIQUE'", "'UPDATE'", "'USING'", "'VACUUM'", 
		    "'VALUES'", "'VIEW'", "'VIRTUAL'", "'WHEN'", "'WHERE'", "'WITH'", 
		    "'WITHOUT'", "'FIRST_VALUE'", "'OVER'", "'PARTITION'", "'RANGE'", 
		    "'PRECEDING'", "'UNBOUNDED'", "'CURRENT'", "'FOLLOWING'", "'CUME_DIST'", 
		    "'DENSE_RANK'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'NTH_VALUE'", 
		    "'NTILE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'GENERATED'", 
		    "'ALWAYS'", "'STORED'", "'TRUE'", "'FALSE'", "'WINDOW'", "'NULLS'", 
		    "'FIRST'", "'LAST'", "'FILTER'", "'GROUPS'", "'EXCLUDE'", "'TIES'", 
		    "'OTHERS'", "'DO'", "'NOTHING'"
		];

		/**
		 * @var array<string>
		 */
		private const SYMBOLIC_NAMES = [
		    null, "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", "COMMA", "ASSIGN", "STAR", 
		    "PLUS", "MINUS", "TILDE", "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", 
		    "PIPE", "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
		    "ABORT_", "ACTION_", "ADD_", "AFTER_", "ALL_", "ALTER_", "ANALYZE_", 
		    "AND_", "AS_", "ASC_", "ATTACH_", "AUTOINCREMENT_", "BEFORE_", "BEGIN_", 
		    "BETWEEN_", "BY_", "CASCADE_", "CASE_", "CAST_", "CHECK_", "COLLATE_", 
		    "COLUMN_", "COMMIT_", "CONFLICT_", "CONSTRAINT_", "CREATE_", "CROSS_", 
		    "CURRENT_DATE_", "CURRENT_TIME_", "CURRENT_TIMESTAMP_", "DATABASE_", 
		    "DEFAULT_", "DEFERRABLE_", "DEFERRED_", "DELETE_", "DESC_", "DETACH_", 
		    "DISTINCT_", "DROP_", "EACH_", "ELSE_", "END_", "ESCAPE_", "EXCEPT_", 
		    "EXCLUSIVE_", "EXISTS_", "EXPLAIN_", "FAIL_", "FOR_", "FOREIGN_", 
		    "FROM_", "FULL_", "GLOB_", "GROUP_", "HAVING_", "IF_", "IGNORE_", 
		    "IMMEDIATE_", "IN_", "INDEX_", "INDEXED_", "INITIALLY_", "INNER_", 
		    "INSERT_", "INSTEAD_", "INTERSECT_", "INTO_", "IS_", "ISNULL_", "JOIN_", 
		    "KEY_", "LEFT_", "LIKE_", "LIMIT_", "MATCH_", "NATURAL_", "NO_", "NOT_", 
		    "NOTNULL_", "NULL_", "OF_", "OFFSET_", "ON_", "OR_", "ORDER_", "OUTER_", 
		    "PLAN_", "PRAGMA_", "PRIMARY_", "QUERY_", "RAISE_", "RECURSIVE_", 
		    "REFERENCES_", "REGEXP_", "REINDEX_", "RELEASE_", "RENAME_", "REPLACE_", 
		    "RESTRICT_", "RETURNING_", "RIGHT_", "ROLLBACK_", "ROW_", "ROWS_", 
		    "SAVEPOINT_", "SELECT_", "SET_", "TABLE_", "TEMP_", "TEMPORARY_", 
		    "THEN_", "TO_", "TRANSACTION_", "TRIGGER_", "UNION_", "UNIQUE_", "UPDATE_", 
		    "USING_", "VACUUM_", "VALUES_", "VIEW_", "VIRTUAL_", "WHEN_", "WHERE_", 
		    "WITH_", "WITHOUT_", "FIRST_VALUE_", "OVER_", "PARTITION_", "RANGE_", 
		    "PRECEDING_", "UNBOUNDED_", "CURRENT_", "FOLLOWING_", "CUME_DIST_", 
		    "DENSE_RANK_", "LAG_", "LAST_VALUE_", "LEAD_", "NTH_VALUE_", "NTILE_", 
		    "PERCENT_RANK_", "RANK_", "ROW_NUMBER_", "GENERATED_", "ALWAYS_", 
		    "STORED_", "TRUE_", "FALSE_", "WINDOW_", "NULLS_", "FIRST_", "LAST_", 
		    "FILTER_", "GROUPS_", "EXCLUDE_", "TIES_", "OTHERS_", "DO_", "NOTHING_", 
		    "IDENTIFIER", "NUMERIC_LITERAL", "BIND_PARAMETER", "STRING_LITERAL", 
		    "BLOB_LITERAL", "SINGLE_LINE_COMMENT", "MULTILINE_COMMENT", "SPACES", 
		    "UNEXPECTED_CHAR"
		];

		private const SERIALIZED_ATN =
			[4, 1, 193, 2082, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 
		    4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 
		    9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 
		    7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 
		    19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 
		    2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 
		    28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 
		    7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 
		    38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 
		    2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 
		    47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
		    7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 
		    57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 
		    2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 
		    66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 
		    7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 
		    76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 
		    2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 
		    85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 
		    7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 
		    95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 
		    2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
		    104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 
		    7, 108, 2, 109, 7, 109, 2, 110, 7, 110, 1, 0, 5, 0, 224, 8, 0, 10, 
		    0, 12, 0, 227, 9, 0, 1, 0, 1, 0, 1, 1, 5, 1, 232, 8, 1, 10, 1, 12, 
		    1, 235, 9, 1, 1, 1, 1, 1, 4, 1, 239, 8, 1, 11, 1, 12, 1, 240, 1, 1, 
		    5, 1, 244, 8, 1, 10, 1, 12, 1, 247, 9, 1, 1, 1, 5, 1, 250, 8, 1, 10, 
		    1, 12, 1, 253, 9, 1, 1, 2, 1, 2, 1, 2, 3, 2, 258, 8, 2, 3, 2, 260, 
		    8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 
		    1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 
		    1, 2, 1, 2, 1, 2, 3, 2, 286, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 
		    3, 293, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 300, 8, 3, 1, 3, 
		    1, 3, 1, 3, 1, 3, 3, 3, 306, 8, 3, 1, 3, 1, 3, 3, 3, 310, 8, 3, 1, 
		    3, 1, 3, 1, 3, 3, 3, 315, 8, 3, 1, 3, 3, 3, 318, 8, 3, 1, 4, 1, 4, 
		    1, 4, 1, 4, 1, 4, 3, 4, 325, 8, 4, 1, 4, 3, 4, 328, 8, 4, 1, 5, 1, 
		    5, 3, 5, 332, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6, 340, 
		    8, 6, 1, 6, 1, 6, 3, 6, 344, 8, 6, 3, 6, 346, 8, 6, 1, 7, 1, 7, 3, 
		    7, 350, 8, 7, 1, 8, 1, 8, 3, 8, 354, 8, 8, 1, 8, 1, 8, 3, 8, 358, 
		    8, 8, 1, 8, 3, 8, 361, 8, 8, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 3, 10, 
		    368, 8, 10, 1, 10, 1, 10, 1, 11, 1, 11, 3, 11, 374, 8, 11, 1, 11, 
		    1, 11, 1, 11, 1, 11, 3, 11, 380, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11, 
		    385, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 
		    394, 8, 11, 10, 11, 12, 11, 397, 9, 11, 1, 11, 1, 11, 1, 11, 3, 11, 
		    402, 8, 11, 1, 12, 1, 12, 3, 12, 406, 8, 12, 1, 12, 1, 12, 3, 12, 
		    410, 8, 12, 1, 12, 3, 12, 413, 8, 12, 1, 13, 1, 13, 3, 13, 417, 8, 
		    13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 423, 8, 13, 1, 13, 1, 13, 1, 
		    13, 3, 13, 428, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 435, 
		    8, 13, 10, 13, 12, 13, 438, 9, 13, 1, 13, 1, 13, 5, 13, 442, 8, 13, 
		    10, 13, 12, 13, 445, 9, 13, 1, 13, 1, 13, 1, 13, 3, 13, 450, 8, 13, 
		    1, 13, 1, 13, 3, 13, 454, 8, 13, 1, 14, 1, 14, 3, 14, 458, 8, 14, 
		    1, 14, 5, 14, 461, 8, 14, 10, 14, 12, 14, 464, 9, 14, 1, 15, 4, 15, 
		    467, 8, 15, 11, 15, 12, 15, 468, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 
		    1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 481, 8, 15, 1, 16, 1, 16, 
		    3, 16, 485, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 490, 8, 16, 1, 16, 
		    3, 16, 493, 8, 16, 1, 16, 3, 16, 496, 8, 16, 1, 16, 1, 16, 1, 16, 
		    3, 16, 501, 8, 16, 1, 16, 3, 16, 504, 8, 16, 1, 16, 1, 16, 1, 16, 
		    1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 
		    16, 518, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 525, 8, 
		    16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 532, 8, 16, 3, 16, 534, 
		    8, 16, 1, 17, 3, 17, 537, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 3, 18, 
		    543, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 548, 8, 18, 1, 18, 1, 18, 
		    1, 18, 1, 18, 5, 18, 554, 8, 18, 10, 18, 12, 18, 557, 9, 18, 1, 18, 
		    1, 18, 3, 18, 561, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 
		    1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 574, 8, 18, 10, 18, 12, 
		    18, 577, 9, 18, 1, 18, 1, 18, 1, 18, 3, 18, 582, 8, 18, 1, 19, 1, 
		    19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 590, 8, 19, 10, 19, 12, 19, 
		    593, 9, 19, 1, 19, 1, 19, 3, 19, 597, 8, 19, 1, 19, 1, 19, 1, 19, 
		    1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 607, 8, 19, 1, 19, 1, 19, 
		    5, 19, 611, 8, 19, 10, 19, 12, 19, 614, 9, 19, 1, 19, 3, 19, 617, 
		    8, 19, 1, 19, 1, 19, 1, 19, 3, 19, 622, 8, 19, 3, 19, 624, 8, 19, 
		    1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 3, 21, 632, 8, 21, 1, 21, 
		    1, 21, 1, 21, 1, 21, 3, 21, 638, 8, 21, 1, 21, 1, 21, 1, 21, 3, 21, 
		    643, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 650, 8, 21, 
		    1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 659, 8, 21, 
		    10, 21, 12, 21, 662, 9, 21, 3, 21, 664, 8, 21, 3, 21, 666, 8, 21, 
		    1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 673, 8, 21, 1, 21, 1, 21, 
		    3, 21, 677, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 684, 
		    8, 21, 1, 21, 1, 21, 4, 21, 688, 8, 21, 11, 21, 12, 21, 689, 1, 21, 
		    1, 21, 1, 22, 1, 22, 3, 22, 696, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 
		    3, 22, 702, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 707, 8, 22, 1, 22, 
		    1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 714, 8, 22, 10, 22, 12, 22, 717, 
		    9, 22, 1, 22, 1, 22, 3, 22, 721, 8, 22, 1, 22, 1, 22, 1, 22, 1, 23, 
		    1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 732, 8, 23, 1, 23, 1, 23, 
		    1, 23, 3, 23, 737, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 
		    1, 23, 5, 23, 746, 8, 23, 10, 23, 12, 23, 749, 9, 23, 1, 23, 1, 23, 
		    3, 23, 753, 8, 23, 1, 24, 1, 24, 3, 24, 757, 8, 24, 1, 24, 1, 24, 
		    1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 
		    24, 5, 24, 771, 8, 24, 10, 24, 12, 24, 774, 9, 24, 1, 25, 1, 25, 1, 
		    25, 1, 25, 1, 25, 5, 25, 781, 8, 25, 10, 25, 12, 25, 784, 9, 25, 1, 
		    25, 1, 25, 3, 25, 788, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 
		    26, 3, 26, 796, 8, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 
		    27, 1, 27, 5, 27, 806, 8, 27, 10, 27, 12, 27, 809, 9, 27, 1, 27, 1, 
		    27, 3, 27, 813, 8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 3, 
		    28, 821, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 828, 8, 
		    28, 1, 28, 3, 28, 831, 8, 28, 1, 29, 3, 29, 834, 8, 29, 1, 29, 1, 
		    29, 1, 29, 1, 29, 1, 29, 3, 29, 841, 8, 29, 1, 29, 3, 29, 844, 8, 
		    29, 1, 29, 3, 29, 847, 8, 29, 1, 29, 3, 29, 850, 8, 29, 1, 30, 1, 
		    30, 3, 30, 854, 8, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 3, 
		    31, 862, 8, 31, 1, 31, 1, 31, 1, 31, 3, 31, 867, 8, 31, 1, 31, 1, 
		    31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 877, 8, 32, 1, 
		    32, 1, 32, 1, 32, 3, 32, 882, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 
		    32, 1, 32, 1, 32, 3, 32, 891, 8, 32, 1, 32, 1, 32, 1, 32, 5, 32, 896, 
		    8, 32, 10, 32, 12, 32, 899, 9, 32, 1, 32, 3, 32, 902, 8, 32, 1, 32, 
		    1, 32, 3, 32, 906, 8, 32, 1, 32, 3, 32, 909, 8, 32, 1, 32, 1, 32, 
		    1, 32, 1, 32, 5, 32, 915, 8, 32, 10, 32, 12, 32, 918, 9, 32, 1, 32, 
		    1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 
		    32, 930, 8, 32, 1, 32, 3, 32, 933, 8, 32, 1, 32, 1, 32, 1, 32, 1, 
		    32, 1, 32, 1, 32, 3, 32, 941, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 
		    32, 4, 32, 948, 8, 32, 11, 32, 12, 32, 949, 1, 32, 1, 32, 3, 32, 954, 
		    8, 32, 1, 32, 1, 32, 1, 32, 3, 32, 959, 8, 32, 1, 32, 1, 32, 1, 32, 
		    1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 
		    32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 
		    1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 989, 8, 32, 1, 32, 
		    1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 
		    32, 1001, 8, 32, 1, 32, 1, 32, 1, 32, 3, 32, 1006, 8, 32, 1, 32, 1, 
		    32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 
		    1018, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 1024, 8, 32, 1, 32, 
		    1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 1031, 8, 32, 1, 32, 1, 32, 3, 32, 
		    1035, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 1043, 
		    8, 32, 10, 32, 12, 32, 1046, 9, 32, 3, 32, 1048, 8, 32, 1, 32, 1, 
		    32, 1, 32, 1, 32, 3, 32, 1054, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 
		    3, 32, 1060, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 1067, 
		    8, 32, 10, 32, 12, 32, 1070, 9, 32, 3, 32, 1072, 8, 32, 1, 32, 1, 
		    32, 3, 32, 1076, 8, 32, 5, 32, 1078, 8, 32, 10, 32, 12, 32, 1081, 
		    9, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 1089, 8, 33, 
		    1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 3, 35, 1096, 8, 35, 1, 35, 1, 35, 
		    1, 35, 1, 35, 1, 35, 3, 35, 1103, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 
		    3, 35, 1109, 8, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1114, 8, 35, 1, 35, 
		    1, 35, 1, 35, 1, 35, 5, 35, 1120, 8, 35, 10, 35, 12, 35, 1123, 9, 
		    35, 1, 35, 1, 35, 3, 35, 1127, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 
		    1, 35, 5, 35, 1134, 8, 35, 10, 35, 12, 35, 1137, 9, 35, 1, 35, 1, 
		    35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 1145, 8, 35, 10, 35, 12, 35, 
		    1148, 9, 35, 1, 35, 1, 35, 5, 35, 1152, 8, 35, 10, 35, 12, 35, 1155, 
		    9, 35, 1, 35, 3, 35, 1158, 8, 35, 1, 35, 3, 35, 1161, 8, 35, 1, 35, 
		    1, 35, 3, 35, 1165, 8, 35, 1, 35, 3, 35, 1168, 8, 35, 1, 36, 1, 36, 
		    1, 36, 1, 36, 5, 36, 1174, 8, 36, 10, 36, 12, 36, 1177, 9, 36, 1, 
		    37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 1185, 8, 37, 10, 37, 
		    12, 37, 1188, 9, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1193, 8, 37, 3, 37, 
		    1195, 8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1203, 
		    8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1210, 8, 37, 1, 37, 
		    1, 37, 1, 37, 5, 37, 1215, 8, 37, 10, 37, 12, 37, 1218, 9, 37, 1, 
		    37, 1, 37, 3, 37, 1222, 8, 37, 3, 37, 1224, 8, 37, 1, 38, 1, 38, 1, 
		    38, 1, 38, 3, 38, 1230, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 
		    1, 38, 1, 38, 3, 38, 1239, 8, 38, 1, 39, 1, 39, 1, 39, 3, 39, 1244, 
		    8, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 1251, 8, 40, 1, 40, 
		    1, 40, 3, 40, 1255, 8, 40, 3, 40, 1257, 8, 40, 1, 41, 3, 41, 1260, 
		    8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 1266, 8, 41, 10, 41, 12, 
		    41, 1269, 9, 41, 1, 41, 3, 41, 1272, 8, 41, 1, 41, 3, 41, 1275, 8, 
		    41, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1281, 8, 42, 5, 42, 1283, 8, 
		    42, 10, 42, 12, 42, 1286, 9, 42, 1, 43, 1, 43, 3, 43, 1290, 8, 43, 
		    1, 43, 1, 43, 1, 43, 5, 43, 1295, 8, 43, 10, 43, 12, 43, 1298, 9, 
		    43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 1304, 8, 43, 10, 43, 12, 43, 
		    1307, 9, 43, 1, 43, 3, 43, 1310, 8, 43, 3, 43, 1312, 8, 43, 1, 43, 
		    1, 43, 3, 43, 1316, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 
		    1323, 8, 43, 10, 43, 12, 43, 1326, 9, 43, 1, 43, 1, 43, 3, 43, 1330, 
		    8, 43, 3, 43, 1332, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 
		    1, 43, 1, 43, 1, 43, 5, 43, 1343, 8, 43, 10, 43, 12, 43, 1346, 9, 
		    43, 3, 43, 1348, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 
		    1355, 8, 43, 10, 43, 12, 43, 1358, 9, 43, 1, 43, 1, 43, 1, 43, 1, 
		    43, 1, 43, 1, 43, 5, 43, 1366, 8, 43, 10, 43, 12, 43, 1369, 9, 43, 
		    1, 43, 1, 43, 5, 43, 1373, 8, 43, 10, 43, 12, 43, 1376, 9, 43, 3, 
		    43, 1378, 8, 43, 1, 44, 1, 44, 1, 45, 3, 45, 1383, 8, 45, 1, 45, 1, 
		    45, 3, 45, 1387, 8, 45, 1, 45, 3, 45, 1390, 8, 45, 1, 46, 3, 46, 1393, 
		    8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1398, 8, 46, 1, 46, 1, 46, 3, 46, 
		    1402, 8, 46, 1, 46, 4, 46, 1405, 8, 46, 11, 46, 12, 46, 1406, 1, 46, 
		    3, 46, 1410, 8, 46, 1, 46, 3, 46, 1413, 8, 46, 1, 47, 1, 47, 1, 47, 
		    3, 47, 1418, 8, 47, 1, 47, 1, 47, 3, 47, 1422, 8, 47, 1, 47, 3, 47, 
		    1425, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1432, 8, 47, 
		    1, 47, 1, 47, 1, 47, 3, 47, 1437, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 
		    1, 47, 5, 47, 1444, 8, 47, 10, 47, 12, 47, 1447, 9, 47, 1, 47, 1, 
		    47, 3, 47, 1451, 8, 47, 1, 47, 3, 47, 1454, 8, 47, 1, 47, 1, 47, 1, 
		    47, 1, 47, 5, 47, 1460, 8, 47, 10, 47, 12, 47, 1463, 9, 47, 1, 47, 
		    3, 47, 1466, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 
		    1474, 8, 47, 1, 47, 3, 47, 1477, 8, 47, 3, 47, 1479, 8, 47, 1, 48, 
		    1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1488, 8, 48, 1, 48, 
		    3, 48, 1491, 8, 48, 3, 48, 1493, 8, 48, 1, 49, 1, 49, 3, 49, 1497, 
		    8, 49, 1, 49, 1, 49, 3, 49, 1501, 8, 49, 1, 49, 1, 49, 3, 49, 1505, 
		    8, 49, 1, 49, 3, 49, 1508, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 
		    1, 50, 1, 50, 5, 50, 1517, 8, 50, 10, 50, 12, 50, 1520, 9, 50, 1, 
		    50, 1, 50, 3, 50, 1524, 8, 50, 1, 51, 1, 51, 3, 51, 1528, 8, 51, 1, 
		    51, 1, 51, 3, 51, 1532, 8, 51, 1, 52, 3, 52, 1535, 8, 52, 1, 52, 1, 
		    52, 1, 52, 3, 52, 1540, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 
		    1546, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1553, 8, 52, 
		    1, 52, 1, 52, 1, 52, 5, 52, 1558, 8, 52, 10, 52, 12, 52, 1561, 9, 
		    52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 1567, 8, 52, 10, 52, 12, 52, 
		    1570, 9, 52, 1, 52, 3, 52, 1573, 8, 52, 3, 52, 1575, 8, 52, 1, 52, 
		    1, 52, 3, 52, 1579, 8, 52, 1, 52, 3, 52, 1582, 8, 52, 1, 53, 1, 53, 
		    1, 53, 1, 53, 5, 53, 1588, 8, 53, 10, 53, 12, 53, 1591, 9, 53, 1, 
		    53, 1, 53, 1, 54, 3, 54, 1596, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 
		    1601, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1607, 8, 54, 1, 54, 
		    1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1614, 8, 54, 1, 54, 1, 54, 1, 54, 
		    5, 54, 1619, 8, 54, 10, 54, 12, 54, 1622, 9, 54, 1, 54, 1, 54, 3, 
		    54, 1626, 8, 54, 1, 54, 3, 54, 1629, 8, 54, 1, 54, 3, 54, 1632, 8, 
		    54, 1, 54, 3, 54, 1635, 8, 54, 1, 55, 1, 55, 1, 55, 3, 55, 1640, 8, 
		    55, 1, 55, 1, 55, 1, 55, 3, 55, 1645, 8, 55, 1, 55, 1, 55, 1, 55, 
		    1, 55, 1, 55, 3, 55, 1652, 8, 55, 1, 56, 1, 56, 3, 56, 1656, 8, 56, 
		    1, 56, 1, 56, 3, 56, 1660, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 
		    1, 57, 1, 58, 1, 58, 3, 58, 1670, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 
		    1, 58, 5, 58, 1677, 8, 58, 10, 58, 12, 58, 1680, 9, 58, 3, 58, 1682, 
		    8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 1689, 8, 58, 10, 
		    58, 12, 58, 1692, 9, 58, 1, 58, 3, 58, 1695, 8, 58, 1, 58, 1, 58, 
		    1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1703, 8, 59, 1, 59, 1, 59, 1, 59, 
		    1, 59, 1, 59, 5, 59, 1710, 8, 59, 10, 59, 12, 59, 1713, 9, 59, 3, 
		    59, 1715, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 1722, 8, 
		    59, 10, 59, 12, 59, 1725, 9, 59, 3, 59, 1727, 8, 59, 1, 59, 3, 59, 
		    1730, 8, 59, 1, 59, 3, 59, 1733, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 
		    1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1743, 8, 60, 1, 61, 1, 61, 1, 61, 
		    1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1752, 8, 61, 1, 62, 1, 62, 1, 62, 
		    1, 62, 1, 62, 5, 62, 1759, 8, 62, 10, 62, 12, 62, 1762, 9, 62, 1, 
		    62, 3, 62, 1765, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 3, 63, 
		    1772, 8, 63, 1, 63, 1, 63, 1, 63, 5, 63, 1777, 8, 63, 10, 63, 12, 
		    63, 1780, 9, 63, 1, 63, 3, 63, 1783, 8, 63, 1, 63, 1, 63, 3, 63, 1787, 
		    8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 1794, 8, 64, 10, 
		    64, 12, 64, 1797, 9, 64, 1, 64, 3, 64, 1800, 8, 64, 1, 64, 1, 64, 
		    3, 64, 1804, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1809, 8, 64, 1, 65, 
		    1, 65, 3, 65, 1813, 8, 65, 1, 65, 1, 65, 1, 65, 5, 65, 1818, 8, 65, 
		    10, 65, 12, 65, 1821, 9, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 5, 
		    66, 1828, 8, 66, 10, 66, 12, 66, 1831, 9, 66, 1, 67, 1, 67, 1, 67, 
		    1, 67, 3, 67, 1837, 8, 67, 1, 68, 1, 68, 1, 68, 3, 68, 1842, 8, 68, 
		    1, 68, 3, 68, 1845, 8, 68, 1, 68, 1, 68, 3, 68, 1849, 8, 68, 1, 69, 
		    1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 
		    70, 1, 70, 3, 70, 1863, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 
		    1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1875, 8, 71, 1, 72, 1, 72, 
		    1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1884, 8, 72, 1, 73, 1, 73, 
		    1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1893, 8, 73, 1, 73, 1, 73, 
		    3, 73, 1897, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 
		    1, 73, 3, 73, 1907, 8, 73, 1, 73, 3, 73, 1910, 8, 73, 1, 73, 1, 73, 
		    1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1919, 8, 73, 1, 73, 1, 73, 
		    1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1928, 8, 73, 1, 73, 3, 73, 
		    1931, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1937, 8, 73, 1, 73, 
		    1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 
		    73, 1, 73, 3, 73, 1951, 8, 73, 1, 73, 1, 73, 3, 73, 1955, 8, 73, 1, 
		    73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 
		    1966, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1971, 8, 73, 1, 74, 1, 74, 
		    1, 74, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 4, 76, 1982, 8, 76, 
		    11, 76, 12, 76, 1983, 1, 77, 1, 77, 1, 77, 4, 77, 1989, 8, 77, 11, 
		    77, 12, 77, 1990, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 3, 79, 
		    1999, 8, 79, 1, 79, 1, 79, 1, 79, 3, 79, 2004, 8, 79, 5, 79, 2006, 
		    8, 79, 10, 79, 12, 79, 2009, 9, 79, 1, 80, 1, 80, 1, 81, 1, 81, 1, 
		    82, 1, 82, 1, 83, 1, 83, 1, 84, 1, 84, 3, 84, 2021, 8, 84, 1, 85, 
		    1, 85, 1, 86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1, 89, 1, 89, 1, 
		    90, 1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93, 1, 94, 1, 94, 
		    1, 95, 1, 95, 1, 96, 1, 96, 1, 97, 1, 97, 1, 98, 1, 98, 1, 99, 1, 
		    99, 1, 100, 1, 100, 1, 101, 1, 101, 1, 102, 1, 102, 1, 103, 1, 103, 
		    1, 104, 1, 104, 1, 105, 1, 105, 1, 106, 1, 106, 1, 107, 1, 107, 1, 
		    108, 1, 108, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 
		    1, 110, 1, 110, 3, 110, 2080, 8, 110, 1, 110, 2, 436, 468, 1, 64, 
		    111, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 
		    34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 
		    68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 
		    102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 
		    130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 
		    158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 
		    186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 
		    214, 216, 218, 220, 0, 28, 3, 0, 58, 58, 69, 69, 82, 82, 2, 0, 47, 
		    47, 66, 66, 1, 0, 133, 134, 2, 0, 146, 146, 171, 171, 1, 0, 8, 9, 
		    2, 0, 59, 59, 141, 141, 2, 0, 56, 56, 104, 104, 2, 0, 58, 58, 82, 
		    82, 5, 0, 25, 25, 72, 72, 81, 81, 122, 122, 126, 126, 4, 0, 84, 84, 
		    132, 132, 138, 138, 145, 145, 2, 0, 7, 7, 12, 13, 1, 0, 14, 17, 1, 
		    0, 18, 21, 4, 0, 77, 77, 97, 97, 99, 99, 118, 118, 3, 0, 25, 25, 72, 
		    72, 126, 126, 5, 0, 52, 54, 104, 104, 172, 173, 186, 186, 188, 189, 
		    2, 0, 29, 29, 62, 62, 3, 0, 128, 128, 154, 154, 179, 179, 2, 0, 5, 
		    5, 106, 106, 1, 0, 176, 177, 2, 0, 34, 34, 60, 60, 2, 0, 151, 151, 
		    162, 162, 2, 0, 159, 159, 166, 166, 2, 0, 160, 160, 167, 168, 2, 0, 
		    161, 161, 163, 163, 2, 0, 8, 10, 102, 102, 2, 0, 185, 185, 188, 188, 
		    2, 0, 25, 123, 125, 180, 2369, 0, 225, 1, 0, 0, 0, 2, 233, 1, 0, 0, 
		    0, 4, 259, 1, 0, 0, 0, 6, 287, 1, 0, 0, 0, 8, 319, 1, 0, 0, 0, 10, 
		    329, 1, 0, 0, 0, 12, 337, 1, 0, 0, 0, 14, 347, 1, 0, 0, 0, 16, 351, 
		    1, 0, 0, 0, 18, 362, 1, 0, 0, 0, 20, 365, 1, 0, 0, 0, 22, 371, 1, 
		    0, 0, 0, 24, 405, 1, 0, 0, 0, 26, 414, 1, 0, 0, 0, 28, 455, 1, 0, 
		    0, 0, 30, 466, 1, 0, 0, 0, 32, 484, 1, 0, 0, 0, 34, 536, 1, 0, 0, 
		    0, 36, 542, 1, 0, 0, 0, 38, 583, 1, 0, 0, 0, 40, 625, 1, 0, 0, 0, 
		    42, 629, 1, 0, 0, 0, 44, 693, 1, 0, 0, 0, 46, 725, 1, 0, 0, 0, 48, 
		    754, 1, 0, 0, 0, 50, 775, 1, 0, 0, 0, 52, 789, 1, 0, 0, 0, 54, 800, 
		    1, 0, 0, 0, 56, 820, 1, 0, 0, 0, 58, 833, 1, 0, 0, 0, 60, 851, 1, 
		    0, 0, 0, 62, 857, 1, 0, 0, 0, 64, 958, 1, 0, 0, 0, 66, 1082, 1, 0, 
		    0, 0, 68, 1092, 1, 0, 0, 0, 70, 1095, 1, 0, 0, 0, 72, 1169, 1, 0, 
		    0, 0, 74, 1178, 1, 0, 0, 0, 76, 1225, 1, 0, 0, 0, 78, 1243, 1, 0, 
		    0, 0, 80, 1245, 1, 0, 0, 0, 82, 1259, 1, 0, 0, 0, 84, 1276, 1, 0, 
		    0, 0, 86, 1377, 1, 0, 0, 0, 88, 1379, 1, 0, 0, 0, 90, 1382, 1, 0, 
		    0, 0, 92, 1392, 1, 0, 0, 0, 94, 1478, 1, 0, 0, 0, 96, 1492, 1, 0, 
		    0, 0, 98, 1507, 1, 0, 0, 0, 100, 1523, 1, 0, 0, 0, 102, 1531, 1, 0, 
		    0, 0, 104, 1534, 1, 0, 0, 0, 106, 1583, 1, 0, 0, 0, 108, 1595, 1, 
		    0, 0, 0, 110, 1639, 1, 0, 0, 0, 112, 1653, 1, 0, 0, 0, 114, 1661, 
		    1, 0, 0, 0, 116, 1667, 1, 0, 0, 0, 118, 1698, 1, 0, 0, 0, 120, 1734, 
		    1, 0, 0, 0, 122, 1744, 1, 0, 0, 0, 124, 1753, 1, 0, 0, 0, 126, 1768, 
		    1, 0, 0, 0, 128, 1788, 1, 0, 0, 0, 130, 1810, 1, 0, 0, 0, 132, 1822, 
		    1, 0, 0, 0, 134, 1832, 1, 0, 0, 0, 136, 1838, 1, 0, 0, 0, 138, 1850, 
		    1, 0, 0, 0, 140, 1862, 1, 0, 0, 0, 142, 1874, 1, 0, 0, 0, 144, 1883, 
		    1, 0, 0, 0, 146, 1970, 1, 0, 0, 0, 148, 1972, 1, 0, 0, 0, 150, 1975, 
		    1, 0, 0, 0, 152, 1978, 1, 0, 0, 0, 154, 1985, 1, 0, 0, 0, 156, 1992, 
		    1, 0, 0, 0, 158, 1996, 1, 0, 0, 0, 160, 2010, 1, 0, 0, 0, 162, 2012, 
		    1, 0, 0, 0, 164, 2014, 1, 0, 0, 0, 166, 2016, 1, 0, 0, 0, 168, 2020, 
		    1, 0, 0, 0, 170, 2022, 1, 0, 0, 0, 172, 2024, 1, 0, 0, 0, 174, 2026, 
		    1, 0, 0, 0, 176, 2028, 1, 0, 0, 0, 178, 2030, 1, 0, 0, 0, 180, 2032, 
		    1, 0, 0, 0, 182, 2034, 1, 0, 0, 0, 184, 2036, 1, 0, 0, 0, 186, 2038, 
		    1, 0, 0, 0, 188, 2040, 1, 0, 0, 0, 190, 2042, 1, 0, 0, 0, 192, 2044, 
		    1, 0, 0, 0, 194, 2046, 1, 0, 0, 0, 196, 2048, 1, 0, 0, 0, 198, 2050, 
		    1, 0, 0, 0, 200, 2052, 1, 0, 0, 0, 202, 2054, 1, 0, 0, 0, 204, 2056, 
		    1, 0, 0, 0, 206, 2058, 1, 0, 0, 0, 208, 2060, 1, 0, 0, 0, 210, 2062, 
		    1, 0, 0, 0, 212, 2064, 1, 0, 0, 0, 214, 2066, 1, 0, 0, 0, 216, 2068, 
		    1, 0, 0, 0, 218, 2070, 1, 0, 0, 0, 220, 2079, 1, 0, 0, 0, 222, 224, 
		    3, 2, 1, 0, 223, 222, 1, 0, 0, 0, 224, 227, 1, 0, 0, 0, 225, 223, 
		    1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 228, 1, 0, 0, 0, 227, 225, 
		    1, 0, 0, 0, 228, 229, 5, 0, 0, 1, 229, 1, 1, 0, 0, 0, 230, 232, 5, 
		    1, 0, 0, 231, 230, 1, 0, 0, 0, 232, 235, 1, 0, 0, 0, 233, 231, 1, 
		    0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 236, 1, 0, 0, 0, 235, 233, 1, 
		    0, 0, 0, 236, 245, 3, 4, 2, 0, 237, 239, 5, 1, 0, 0, 238, 237, 1, 
		    0, 0, 0, 239, 240, 1, 0, 0, 0, 240, 238, 1, 0, 0, 0, 240, 241, 1, 
		    0, 0, 0, 241, 242, 1, 0, 0, 0, 242, 244, 3, 4, 2, 0, 243, 238, 1, 
		    0, 0, 0, 244, 247, 1, 0, 0, 0, 245, 243, 1, 0, 0, 0, 245, 246, 1, 
		    0, 0, 0, 246, 251, 1, 0, 0, 0, 247, 245, 1, 0, 0, 0, 248, 250, 5, 
		    1, 0, 0, 249, 248, 1, 0, 0, 0, 250, 253, 1, 0, 0, 0, 251, 249, 1, 
		    0, 0, 0, 251, 252, 1, 0, 0, 0, 252, 3, 1, 0, 0, 0, 253, 251, 1, 0, 
		    0, 0, 254, 257, 5, 71, 0, 0, 255, 256, 5, 114, 0, 0, 256, 258, 5, 
		    111, 0, 0, 257, 255, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 260, 1, 
		    0, 0, 0, 259, 254, 1, 0, 0, 0, 259, 260, 1, 0, 0, 0, 260, 285, 1, 
		    0, 0, 0, 261, 286, 3, 6, 3, 0, 262, 286, 3, 8, 4, 0, 263, 286, 3, 
		    10, 5, 0, 264, 286, 3, 12, 6, 0, 265, 286, 3, 14, 7, 0, 266, 286, 
		    3, 22, 11, 0, 267, 286, 3, 26, 13, 0, 268, 286, 3, 42, 21, 0, 269, 
		    286, 3, 44, 22, 0, 270, 286, 3, 46, 23, 0, 271, 286, 3, 56, 28, 0, 
		    272, 286, 3, 58, 29, 0, 273, 286, 3, 60, 30, 0, 274, 286, 3, 62, 31, 
		    0, 275, 286, 3, 70, 35, 0, 276, 286, 3, 76, 38, 0, 277, 286, 3, 80, 
		    40, 0, 278, 286, 3, 20, 10, 0, 279, 286, 3, 16, 8, 0, 280, 286, 3, 
		    18, 9, 0, 281, 286, 3, 82, 41, 0, 282, 286, 3, 104, 52, 0, 283, 286, 
		    3, 108, 54, 0, 284, 286, 3, 112, 56, 0, 285, 261, 1, 0, 0, 0, 285, 
		    262, 1, 0, 0, 0, 285, 263, 1, 0, 0, 0, 285, 264, 1, 0, 0, 0, 285, 
		    265, 1, 0, 0, 0, 285, 266, 1, 0, 0, 0, 285, 267, 1, 0, 0, 0, 285, 
		    268, 1, 0, 0, 0, 285, 269, 1, 0, 0, 0, 285, 270, 1, 0, 0, 0, 285, 
		    271, 1, 0, 0, 0, 285, 272, 1, 0, 0, 0, 285, 273, 1, 0, 0, 0, 285, 
		    274, 1, 0, 0, 0, 285, 275, 1, 0, 0, 0, 285, 276, 1, 0, 0, 0, 285, 
		    277, 1, 0, 0, 0, 285, 278, 1, 0, 0, 0, 285, 279, 1, 0, 0, 0, 285, 
		    280, 1, 0, 0, 0, 285, 281, 1, 0, 0, 0, 285, 282, 1, 0, 0, 0, 285, 
		    283, 1, 0, 0, 0, 285, 284, 1, 0, 0, 0, 286, 5, 1, 0, 0, 0, 287, 288, 
		    5, 30, 0, 0, 288, 292, 5, 132, 0, 0, 289, 290, 3, 178, 89, 0, 290, 
		    291, 5, 2, 0, 0, 291, 293, 1, 0, 0, 0, 292, 289, 1, 0, 0, 0, 292, 
		    293, 1, 0, 0, 0, 293, 294, 1, 0, 0, 0, 294, 317, 3, 180, 90, 0, 295, 
		    305, 5, 121, 0, 0, 296, 297, 5, 136, 0, 0, 297, 306, 3, 180, 90, 0, 
		    298, 300, 5, 46, 0, 0, 299, 298, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 
		    300, 301, 1, 0, 0, 0, 301, 302, 3, 184, 92, 0, 302, 303, 5, 136, 0, 
		    0, 303, 304, 3, 184, 92, 0, 304, 306, 1, 0, 0, 0, 305, 296, 1, 0, 
		    0, 0, 305, 299, 1, 0, 0, 0, 306, 318, 1, 0, 0, 0, 307, 309, 5, 27, 
		    0, 0, 308, 310, 5, 46, 0, 0, 309, 308, 1, 0, 0, 0, 309, 310, 1, 0, 
		    0, 0, 310, 311, 1, 0, 0, 0, 311, 318, 3, 28, 14, 0, 312, 314, 5, 63, 
		    0, 0, 313, 315, 5, 46, 0, 0, 314, 313, 1, 0, 0, 0, 314, 315, 1, 0, 
		    0, 0, 315, 316, 1, 0, 0, 0, 316, 318, 3, 184, 92, 0, 317, 295, 1, 
		    0, 0, 0, 317, 307, 1, 0, 0, 0, 317, 312, 1, 0, 0, 0, 318, 7, 1, 0, 
		    0, 0, 319, 327, 5, 31, 0, 0, 320, 328, 3, 178, 89, 0, 321, 322, 3, 
		    178, 89, 0, 322, 323, 5, 2, 0, 0, 323, 325, 1, 0, 0, 0, 324, 321, 
		    1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0, 326, 328, 
		    3, 182, 91, 0, 327, 320, 1, 0, 0, 0, 327, 324, 1, 0, 0, 0, 327, 328, 
		    1, 0, 0, 0, 328, 9, 1, 0, 0, 0, 329, 331, 5, 35, 0, 0, 330, 332, 5, 
		    55, 0, 0, 331, 330, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 333, 1, 
		    0, 0, 0, 333, 334, 3, 64, 32, 0, 334, 335, 5, 33, 0, 0, 335, 336, 
		    3, 178, 89, 0, 336, 11, 1, 0, 0, 0, 337, 339, 5, 38, 0, 0, 338, 340, 
		    7, 0, 0, 0, 339, 338, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 345, 
		    1, 0, 0, 0, 341, 343, 5, 137, 0, 0, 342, 344, 3, 204, 102, 0, 343, 
		    342, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 346, 1, 0, 0, 0, 345, 
		    341, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 13, 1, 0, 0, 0, 347, 349, 
		    7, 1, 0, 0, 348, 350, 5, 137, 0, 0, 349, 348, 1, 0, 0, 0, 349, 350, 
		    1, 0, 0, 0, 350, 15, 1, 0, 0, 0, 351, 353, 5, 126, 0, 0, 352, 354, 
		    5, 137, 0, 0, 353, 352, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 360, 
		    1, 0, 0, 0, 355, 357, 5, 136, 0, 0, 356, 358, 5, 129, 0, 0, 357, 356, 
		    1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 359, 1, 0, 0, 0, 359, 361, 
		    3, 200, 100, 0, 360, 355, 1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 17, 
		    1, 0, 0, 0, 362, 363, 5, 129, 0, 0, 363, 364, 3, 200, 100, 0, 364, 
		    19, 1, 0, 0, 0, 365, 367, 5, 120, 0, 0, 366, 368, 5, 129, 0, 0, 367, 
		    366, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 
		    370, 3, 200, 100, 0, 370, 21, 1, 0, 0, 0, 371, 373, 5, 50, 0, 0, 372, 
		    374, 5, 140, 0, 0, 373, 372, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374, 
		    375, 1, 0, 0, 0, 375, 379, 5, 84, 0, 0, 376, 377, 5, 80, 0, 0, 377, 
		    378, 5, 102, 0, 0, 378, 380, 5, 70, 0, 0, 379, 376, 1, 0, 0, 0, 379, 
		    380, 1, 0, 0, 0, 380, 384, 1, 0, 0, 0, 381, 382, 3, 178, 89, 0, 382, 
		    383, 5, 2, 0, 0, 383, 385, 1, 0, 0, 0, 384, 381, 1, 0, 0, 0, 384, 
		    385, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 387, 3, 190, 95, 0, 387, 
		    388, 5, 107, 0, 0, 388, 389, 3, 180, 90, 0, 389, 390, 5, 3, 0, 0, 
		    390, 395, 3, 24, 12, 0, 391, 392, 5, 5, 0, 0, 392, 394, 3, 24, 12, 
		    0, 393, 391, 1, 0, 0, 0, 394, 397, 1, 0, 0, 0, 395, 393, 1, 0, 0, 
		    0, 395, 396, 1, 0, 0, 0, 396, 398, 1, 0, 0, 0, 397, 395, 1, 0, 0, 
		    0, 398, 401, 5, 4, 0, 0, 399, 400, 5, 148, 0, 0, 400, 402, 3, 64, 
		    32, 0, 401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 23, 1, 0, 
		    0, 0, 403, 406, 3, 184, 92, 0, 404, 406, 3, 64, 32, 0, 405, 403, 1, 
		    0, 0, 0, 405, 404, 1, 0, 0, 0, 406, 409, 1, 0, 0, 0, 407, 408, 5, 
		    45, 0, 0, 408, 410, 3, 186, 93, 0, 409, 407, 1, 0, 0, 0, 409, 410, 
		    1, 0, 0, 0, 410, 412, 1, 0, 0, 0, 411, 413, 3, 138, 69, 0, 412, 411, 
		    1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 25, 1, 0, 0, 0, 414, 416, 5, 
		    50, 0, 0, 415, 417, 7, 2, 0, 0, 416, 415, 1, 0, 0, 0, 416, 417, 1, 
		    0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 422, 5, 132, 0, 0, 419, 420, 5, 
		    80, 0, 0, 420, 421, 5, 102, 0, 0, 421, 423, 5, 70, 0, 0, 422, 419, 
		    1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423, 427, 1, 0, 0, 0, 424, 425, 
		    3, 178, 89, 0, 425, 426, 5, 2, 0, 0, 426, 428, 1, 0, 0, 0, 427, 424, 
		    1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 453, 
		    3, 180, 90, 0, 430, 431, 5, 3, 0, 0, 431, 436, 3, 28, 14, 0, 432, 
		    433, 5, 5, 0, 0, 433, 435, 3, 28, 14, 0, 434, 432, 1, 0, 0, 0, 435, 
		    438, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 437, 
		    443, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 439, 440, 5, 5, 0, 0, 440, 
		    442, 3, 36, 18, 0, 441, 439, 1, 0, 0, 0, 442, 445, 1, 0, 0, 0, 443, 
		    441, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 446, 1, 0, 0, 0, 445, 
		    443, 1, 0, 0, 0, 446, 449, 5, 4, 0, 0, 447, 448, 5, 150, 0, 0, 448, 
		    450, 5, 185, 0, 0, 449, 447, 1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 
		    454, 1, 0, 0, 0, 451, 452, 5, 33, 0, 0, 452, 454, 3, 82, 41, 0, 453, 
		    430, 1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 454, 27, 1, 0, 0, 0, 455, 457, 
		    3, 184, 92, 0, 456, 458, 3, 30, 15, 0, 457, 456, 1, 0, 0, 0, 457, 
		    458, 1, 0, 0, 0, 458, 462, 1, 0, 0, 0, 459, 461, 3, 32, 16, 0, 460, 
		    459, 1, 0, 0, 0, 461, 464, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 462, 
		    463, 1, 0, 0, 0, 463, 29, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 465, 467, 
		    3, 174, 87, 0, 466, 465, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 469, 
		    1, 0, 0, 0, 468, 466, 1, 0, 0, 0, 469, 480, 1, 0, 0, 0, 470, 471, 
		    5, 3, 0, 0, 471, 472, 3, 34, 17, 0, 472, 473, 5, 4, 0, 0, 473, 481, 
		    1, 0, 0, 0, 474, 475, 5, 3, 0, 0, 475, 476, 3, 34, 17, 0, 476, 477, 
		    5, 5, 0, 0, 477, 478, 3, 34, 17, 0, 478, 479, 5, 4, 0, 0, 479, 481, 
		    1, 0, 0, 0, 480, 470, 1, 0, 0, 0, 480, 474, 1, 0, 0, 0, 480, 481, 
		    1, 0, 0, 0, 481, 31, 1, 0, 0, 0, 482, 483, 5, 49, 0, 0, 483, 485, 
		    3, 174, 87, 0, 484, 482, 1, 0, 0, 0, 484, 485, 1, 0, 0, 0, 485, 533, 
		    1, 0, 0, 0, 486, 487, 5, 113, 0, 0, 487, 489, 5, 95, 0, 0, 488, 490, 
		    3, 138, 69, 0, 489, 488, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 492, 
		    1, 0, 0, 0, 491, 493, 3, 40, 20, 0, 492, 491, 1, 0, 0, 0, 492, 493, 
		    1, 0, 0, 0, 493, 495, 1, 0, 0, 0, 494, 496, 5, 36, 0, 0, 495, 494, 
		    1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 534, 1, 0, 0, 0, 497, 498, 
		    5, 102, 0, 0, 498, 501, 5, 104, 0, 0, 499, 501, 5, 140, 0, 0, 500, 
		    497, 1, 0, 0, 0, 500, 499, 1, 0, 0, 0, 501, 503, 1, 0, 0, 0, 502, 
		    504, 3, 40, 20, 0, 503, 502, 1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 
		    534, 1, 0, 0, 0, 505, 506, 5, 44, 0, 0, 506, 507, 5, 3, 0, 0, 507, 
		    508, 3, 64, 32, 0, 508, 509, 5, 4, 0, 0, 509, 534, 1, 0, 0, 0, 510, 
		    517, 5, 56, 0, 0, 511, 518, 3, 34, 17, 0, 512, 518, 3, 68, 34, 0, 
		    513, 514, 5, 3, 0, 0, 514, 515, 3, 64, 32, 0, 515, 516, 5, 4, 0, 0, 
		    516, 518, 1, 0, 0, 0, 517, 511, 1, 0, 0, 0, 517, 512, 1, 0, 0, 0, 
		    517, 513, 1, 0, 0, 0, 518, 534, 1, 0, 0, 0, 519, 520, 5, 45, 0, 0, 
		    520, 534, 3, 186, 93, 0, 521, 534, 3, 38, 19, 0, 522, 523, 5, 169, 
		    0, 0, 523, 525, 5, 170, 0, 0, 524, 522, 1, 0, 0, 0, 524, 525, 1, 0, 
		    0, 0, 525, 526, 1, 0, 0, 0, 526, 527, 5, 33, 0, 0, 527, 528, 5, 3, 
		    0, 0, 528, 529, 3, 64, 32, 0, 529, 531, 5, 4, 0, 0, 530, 532, 7, 3, 
		    0, 0, 531, 530, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 534, 1, 0, 
		    0, 0, 533, 486, 1, 0, 0, 0, 533, 500, 1, 0, 0, 0, 533, 505, 1, 0, 
		    0, 0, 533, 510, 1, 0, 0, 0, 533, 519, 1, 0, 0, 0, 533, 521, 1, 0, 
		    0, 0, 533, 524, 1, 0, 0, 0, 534, 33, 1, 0, 0, 0, 535, 537, 7, 4, 0, 
		    0, 536, 535, 1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 538, 1, 0, 0, 
		    0, 538, 539, 5, 186, 0, 0, 539, 35, 1, 0, 0, 0, 540, 541, 5, 49, 0, 
		    0, 541, 543, 3, 174, 87, 0, 542, 540, 1, 0, 0, 0, 542, 543, 1, 0, 
		    0, 0, 543, 581, 1, 0, 0, 0, 544, 545, 5, 113, 0, 0, 545, 548, 5, 95, 
		    0, 0, 546, 548, 5, 140, 0, 0, 547, 544, 1, 0, 0, 0, 547, 546, 1, 0, 
		    0, 0, 548, 549, 1, 0, 0, 0, 549, 550, 5, 3, 0, 0, 550, 555, 3, 24, 
		    12, 0, 551, 552, 5, 5, 0, 0, 552, 554, 3, 24, 12, 0, 553, 551, 1, 
		    0, 0, 0, 554, 557, 1, 0, 0, 0, 555, 553, 1, 0, 0, 0, 555, 556, 1, 
		    0, 0, 0, 556, 558, 1, 0, 0, 0, 557, 555, 1, 0, 0, 0, 558, 560, 5, 
		    4, 0, 0, 559, 561, 3, 40, 20, 0, 560, 559, 1, 0, 0, 0, 560, 561, 1, 
		    0, 0, 0, 561, 582, 1, 0, 0, 0, 562, 563, 5, 44, 0, 0, 563, 564, 5, 
		    3, 0, 0, 564, 565, 3, 64, 32, 0, 565, 566, 5, 4, 0, 0, 566, 582, 1, 
		    0, 0, 0, 567, 568, 5, 74, 0, 0, 568, 569, 5, 95, 0, 0, 569, 570, 5, 
		    3, 0, 0, 570, 575, 3, 184, 92, 0, 571, 572, 5, 5, 0, 0, 572, 574, 
		    3, 184, 92, 0, 573, 571, 1, 0, 0, 0, 574, 577, 1, 0, 0, 0, 575, 573, 
		    1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 578, 1, 0, 0, 0, 577, 575, 
		    1, 0, 0, 0, 578, 579, 5, 4, 0, 0, 579, 580, 3, 38, 19, 0, 580, 582, 
		    1, 0, 0, 0, 581, 547, 1, 0, 0, 0, 581, 562, 1, 0, 0, 0, 581, 567, 
		    1, 0, 0, 0, 582, 37, 1, 0, 0, 0, 583, 584, 5, 117, 0, 0, 584, 596, 
		    3, 188, 94, 0, 585, 586, 5, 3, 0, 0, 586, 591, 3, 184, 92, 0, 587, 
		    588, 5, 5, 0, 0, 588, 590, 3, 184, 92, 0, 589, 587, 1, 0, 0, 0, 590, 
		    593, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0, 592, 
		    594, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0, 594, 595, 5, 4, 0, 0, 595, 
		    597, 1, 0, 0, 0, 596, 585, 1, 0, 0, 0, 596, 597, 1, 0, 0, 0, 597, 
		    612, 1, 0, 0, 0, 598, 599, 5, 107, 0, 0, 599, 606, 7, 5, 0, 0, 600, 
		    601, 5, 131, 0, 0, 601, 607, 7, 6, 0, 0, 602, 607, 5, 41, 0, 0, 603, 
		    607, 5, 123, 0, 0, 604, 605, 5, 101, 0, 0, 605, 607, 5, 26, 0, 0, 
		    606, 600, 1, 0, 0, 0, 606, 602, 1, 0, 0, 0, 606, 603, 1, 0, 0, 0, 
		    606, 604, 1, 0, 0, 0, 607, 611, 1, 0, 0, 0, 608, 609, 5, 99, 0, 0, 
		    609, 611, 3, 174, 87, 0, 610, 598, 1, 0, 0, 0, 610, 608, 1, 0, 0, 
		    0, 611, 614, 1, 0, 0, 0, 612, 610, 1, 0, 0, 0, 612, 613, 1, 0, 0, 
		    0, 613, 623, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0, 615, 617, 5, 102, 0, 
		    0, 616, 615, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 618, 1, 0, 0, 
		    0, 618, 621, 5, 57, 0, 0, 619, 620, 5, 86, 0, 0, 620, 622, 7, 7, 0, 
		    0, 621, 619, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 624, 1, 0, 0, 
		    0, 623, 616, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 39, 1, 0, 0, 0, 
		    625, 626, 5, 107, 0, 0, 626, 627, 5, 48, 0, 0, 627, 628, 7, 8, 0, 
		    0, 628, 41, 1, 0, 0, 0, 629, 631, 5, 50, 0, 0, 630, 632, 7, 2, 0, 
		    0, 631, 630, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 633, 1, 0, 0, 
		    0, 633, 637, 5, 138, 0, 0, 634, 635, 5, 80, 0, 0, 635, 636, 5, 102, 
		    0, 0, 636, 638, 5, 70, 0, 0, 637, 634, 1, 0, 0, 0, 637, 638, 1, 0, 
		    0, 0, 638, 642, 1, 0, 0, 0, 639, 640, 3, 178, 89, 0, 640, 641, 5, 
		    2, 0, 0, 641, 643, 1, 0, 0, 0, 642, 639, 1, 0, 0, 0, 642, 643, 1, 
		    0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 649, 3, 192, 96, 0, 645, 650, 
		    5, 37, 0, 0, 646, 650, 5, 28, 0, 0, 647, 648, 5, 89, 0, 0, 648, 650, 
		    5, 105, 0, 0, 649, 645, 1, 0, 0, 0, 649, 646, 1, 0, 0, 0, 649, 647, 
		    1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 665, 1, 0, 0, 0, 651, 666, 
		    5, 59, 0, 0, 652, 666, 5, 88, 0, 0, 653, 663, 5, 141, 0, 0, 654, 655, 
		    5, 105, 0, 0, 655, 660, 3, 184, 92, 0, 656, 657, 5, 5, 0, 0, 657, 
		    659, 3, 184, 92, 0, 658, 656, 1, 0, 0, 0, 659, 662, 1, 0, 0, 0, 660, 
		    658, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 664, 1, 0, 0, 0, 662, 
		    660, 1, 0, 0, 0, 663, 654, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 
		    666, 1, 0, 0, 0, 665, 651, 1, 0, 0, 0, 665, 652, 1, 0, 0, 0, 665, 
		    653, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 668, 5, 107, 0, 0, 668, 
		    672, 3, 180, 90, 0, 669, 670, 5, 73, 0, 0, 670, 671, 5, 64, 0, 0, 
		    671, 673, 5, 127, 0, 0, 672, 669, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 
		    673, 676, 1, 0, 0, 0, 674, 675, 5, 147, 0, 0, 675, 677, 3, 64, 32, 
		    0, 676, 674, 1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 678, 1, 0, 0, 
		    0, 678, 687, 5, 38, 0, 0, 679, 684, 3, 104, 52, 0, 680, 684, 3, 70, 
		    35, 0, 681, 684, 3, 56, 28, 0, 682, 684, 3, 82, 41, 0, 683, 679, 1, 
		    0, 0, 0, 683, 680, 1, 0, 0, 0, 683, 681, 1, 0, 0, 0, 683, 682, 1, 
		    0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 5, 1, 0, 0, 686, 688, 1, 
		    0, 0, 0, 687, 683, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 687, 1, 
		    0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 692, 5, 
		    66, 0, 0, 692, 43, 1, 0, 0, 0, 693, 695, 5, 50, 0, 0, 694, 696, 7, 
		    2, 0, 0, 695, 694, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 
		    0, 0, 0, 697, 701, 5, 145, 0, 0, 698, 699, 5, 80, 0, 0, 699, 700, 
		    5, 102, 0, 0, 700, 702, 5, 70, 0, 0, 701, 698, 1, 0, 0, 0, 701, 702, 
		    1, 0, 0, 0, 702, 706, 1, 0, 0, 0, 703, 704, 3, 178, 89, 0, 704, 705, 
		    5, 2, 0, 0, 705, 707, 1, 0, 0, 0, 706, 703, 1, 0, 0, 0, 706, 707, 
		    1, 0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 720, 3, 194, 97, 0, 709, 710, 
		    5, 3, 0, 0, 710, 715, 3, 184, 92, 0, 711, 712, 5, 5, 0, 0, 712, 714, 
		    3, 184, 92, 0, 713, 711, 1, 0, 0, 0, 714, 717, 1, 0, 0, 0, 715, 713, 
		    1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 718, 1, 0, 0, 0, 717, 715, 
		    1, 0, 0, 0, 718, 719, 5, 4, 0, 0, 719, 721, 1, 0, 0, 0, 720, 709, 
		    1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 723, 
		    5, 33, 0, 0, 723, 724, 3, 82, 41, 0, 724, 45, 1, 0, 0, 0, 725, 726, 
		    5, 50, 0, 0, 726, 727, 5, 146, 0, 0, 727, 731, 5, 132, 0, 0, 728, 
		    729, 5, 80, 0, 0, 729, 730, 5, 102, 0, 0, 730, 732, 5, 70, 0, 0, 731, 
		    728, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732, 736, 1, 0, 0, 0, 733, 
		    734, 3, 178, 89, 0, 734, 735, 5, 2, 0, 0, 735, 737, 1, 0, 0, 0, 736, 
		    733, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 
		    739, 3, 180, 90, 0, 739, 740, 5, 142, 0, 0, 740, 752, 3, 196, 98, 
		    0, 741, 742, 5, 3, 0, 0, 742, 747, 3, 168, 84, 0, 743, 744, 5, 5, 
		    0, 0, 744, 746, 3, 168, 84, 0, 745, 743, 1, 0, 0, 0, 746, 749, 1, 
		    0, 0, 0, 747, 745, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 750, 1, 
		    0, 0, 0, 749, 747, 1, 0, 0, 0, 750, 751, 5, 4, 0, 0, 751, 753, 1, 
		    0, 0, 0, 752, 741, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 47, 1, 0, 
		    0, 0, 754, 756, 5, 149, 0, 0, 755, 757, 5, 116, 0, 0, 756, 755, 1, 
		    0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 759, 3, 
		    50, 25, 0, 759, 760, 5, 33, 0, 0, 760, 761, 5, 3, 0, 0, 761, 762, 
		    3, 82, 41, 0, 762, 772, 5, 4, 0, 0, 763, 764, 5, 5, 0, 0, 764, 765, 
		    3, 50, 25, 0, 765, 766, 5, 33, 0, 0, 766, 767, 5, 3, 0, 0, 767, 768, 
		    3, 82, 41, 0, 768, 769, 5, 4, 0, 0, 769, 771, 1, 0, 0, 0, 770, 763, 
		    1, 0, 0, 0, 771, 774, 1, 0, 0, 0, 772, 770, 1, 0, 0, 0, 772, 773, 
		    1, 0, 0, 0, 773, 49, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 775, 787, 3, 
		    180, 90, 0, 776, 777, 5, 3, 0, 0, 777, 782, 3, 184, 92, 0, 778, 779, 
		    5, 5, 0, 0, 779, 781, 3, 184, 92, 0, 780, 778, 1, 0, 0, 0, 781, 784, 
		    1, 0, 0, 0, 782, 780, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 785, 
		    1, 0, 0, 0, 784, 782, 1, 0, 0, 0, 785, 786, 5, 4, 0, 0, 786, 788, 
		    1, 0, 0, 0, 787, 776, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 51, 1, 
		    0, 0, 0, 789, 790, 3, 50, 25, 0, 790, 791, 5, 33, 0, 0, 791, 792, 
		    5, 3, 0, 0, 792, 793, 3, 160, 80, 0, 793, 795, 5, 139, 0, 0, 794, 
		    796, 5, 29, 0, 0, 795, 794, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 
		    797, 1, 0, 0, 0, 797, 798, 3, 162, 81, 0, 798, 799, 5, 4, 0, 0, 799, 
		    53, 1, 0, 0, 0, 800, 812, 3, 180, 90, 0, 801, 802, 5, 3, 0, 0, 802, 
		    807, 3, 184, 92, 0, 803, 804, 5, 5, 0, 0, 804, 806, 3, 184, 92, 0, 
		    805, 803, 1, 0, 0, 0, 806, 809, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 
		    807, 808, 1, 0, 0, 0, 808, 810, 1, 0, 0, 0, 809, 807, 1, 0, 0, 0, 
		    810, 811, 5, 4, 0, 0, 811, 813, 1, 0, 0, 0, 812, 801, 1, 0, 0, 0, 
		    812, 813, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 815, 5, 33, 0, 0, 
		    815, 816, 5, 3, 0, 0, 816, 817, 3, 82, 41, 0, 817, 818, 5, 4, 0, 0, 
		    818, 55, 1, 0, 0, 0, 819, 821, 3, 48, 24, 0, 820, 819, 1, 0, 0, 0, 
		    820, 821, 1, 0, 0, 0, 821, 822, 1, 0, 0, 0, 822, 823, 5, 59, 0, 0, 
		    823, 824, 5, 75, 0, 0, 824, 827, 3, 110, 55, 0, 825, 826, 5, 148, 
		    0, 0, 826, 828, 3, 64, 32, 0, 827, 825, 1, 0, 0, 0, 827, 828, 1, 0, 
		    0, 0, 828, 830, 1, 0, 0, 0, 829, 831, 3, 72, 36, 0, 830, 829, 1, 0, 
		    0, 0, 830, 831, 1, 0, 0, 0, 831, 57, 1, 0, 0, 0, 832, 834, 3, 48, 
		    24, 0, 833, 832, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 835, 1, 0, 
		    0, 0, 835, 836, 5, 59, 0, 0, 836, 837, 5, 75, 0, 0, 837, 840, 3, 110, 
		    55, 0, 838, 839, 5, 148, 0, 0, 839, 841, 3, 64, 32, 0, 840, 838, 1, 
		    0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 843, 1, 0, 0, 0, 842, 844, 3, 
		    72, 36, 0, 843, 842, 1, 0, 0, 0, 843, 844, 1, 0, 0, 0, 844, 849, 1, 
		    0, 0, 0, 845, 847, 3, 132, 66, 0, 846, 845, 1, 0, 0, 0, 846, 847, 
		    1, 0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 850, 3, 134, 67, 0, 849, 846, 
		    1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 59, 1, 0, 0, 0, 851, 853, 5, 
		    61, 0, 0, 852, 854, 5, 55, 0, 0, 853, 852, 1, 0, 0, 0, 853, 854, 1, 
		    0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 856, 3, 178, 89, 0, 856, 61, 1, 
		    0, 0, 0, 857, 858, 5, 63, 0, 0, 858, 861, 7, 9, 0, 0, 859, 860, 5, 
		    80, 0, 0, 860, 862, 5, 70, 0, 0, 861, 859, 1, 0, 0, 0, 861, 862, 1, 
		    0, 0, 0, 862, 866, 1, 0, 0, 0, 863, 864, 3, 178, 89, 0, 864, 865, 
		    5, 2, 0, 0, 865, 867, 1, 0, 0, 0, 866, 863, 1, 0, 0, 0, 866, 867, 
		    1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 869, 3, 220, 110, 0, 869, 63, 
		    1, 0, 0, 0, 870, 871, 6, 32, -1, 0, 871, 959, 3, 68, 34, 0, 872, 959, 
		    5, 187, 0, 0, 873, 874, 3, 178, 89, 0, 874, 875, 5, 2, 0, 0, 875, 
		    877, 1, 0, 0, 0, 876, 873, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 
		    878, 1, 0, 0, 0, 878, 879, 3, 180, 90, 0, 879, 880, 5, 2, 0, 0, 880, 
		    882, 1, 0, 0, 0, 881, 876, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 
		    883, 1, 0, 0, 0, 883, 959, 3, 184, 92, 0, 884, 885, 3, 164, 82, 0, 
		    885, 886, 3, 64, 32, 21, 886, 959, 1, 0, 0, 0, 887, 888, 3, 176, 88, 
		    0, 888, 901, 5, 3, 0, 0, 889, 891, 5, 62, 0, 0, 890, 889, 1, 0, 0, 
		    0, 890, 891, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 897, 3, 64, 32, 
		    0, 893, 894, 5, 5, 0, 0, 894, 896, 3, 64, 32, 0, 895, 893, 1, 0, 0, 
		    0, 896, 899, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897, 898, 1, 0, 0, 
		    0, 898, 902, 1, 0, 0, 0, 899, 897, 1, 0, 0, 0, 900, 902, 5, 7, 0, 
		    0, 901, 890, 1, 0, 0, 0, 901, 900, 1, 0, 0, 0, 901, 902, 1, 0, 0, 
		    0, 902, 903, 1, 0, 0, 0, 903, 905, 5, 4, 0, 0, 904, 906, 3, 114, 57, 
		    0, 905, 904, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 906, 908, 1, 0, 0, 
		    0, 907, 909, 3, 118, 59, 0, 908, 907, 1, 0, 0, 0, 908, 909, 1, 0, 
		    0, 0, 909, 959, 1, 0, 0, 0, 910, 911, 5, 3, 0, 0, 911, 916, 3, 64, 
		    32, 0, 912, 913, 5, 5, 0, 0, 913, 915, 3, 64, 32, 0, 914, 912, 1, 
		    0, 0, 0, 915, 918, 1, 0, 0, 0, 916, 914, 1, 0, 0, 0, 916, 917, 1, 
		    0, 0, 0, 917, 919, 1, 0, 0, 0, 918, 916, 1, 0, 0, 0, 919, 920, 5, 
		    4, 0, 0, 920, 959, 1, 0, 0, 0, 921, 922, 5, 43, 0, 0, 922, 923, 5, 
		    3, 0, 0, 923, 924, 3, 64, 32, 0, 924, 925, 5, 33, 0, 0, 925, 926, 
		    3, 30, 15, 0, 926, 927, 5, 4, 0, 0, 927, 959, 1, 0, 0, 0, 928, 930, 
		    5, 102, 0, 0, 929, 928, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 931, 
		    1, 0, 0, 0, 931, 933, 5, 70, 0, 0, 932, 929, 1, 0, 0, 0, 932, 933, 
		    1, 0, 0, 0, 933, 934, 1, 0, 0, 0, 934, 935, 5, 3, 0, 0, 935, 936, 
		    3, 82, 41, 0, 936, 937, 5, 4, 0, 0, 937, 959, 1, 0, 0, 0, 938, 940, 
		    5, 42, 0, 0, 939, 941, 3, 64, 32, 0, 940, 939, 1, 0, 0, 0, 940, 941, 
		    1, 0, 0, 0, 941, 947, 1, 0, 0, 0, 942, 943, 5, 147, 0, 0, 943, 944, 
		    3, 64, 32, 0, 944, 945, 5, 135, 0, 0, 945, 946, 3, 64, 32, 0, 946, 
		    948, 1, 0, 0, 0, 947, 942, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 
		    947, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 953, 1, 0, 0, 0, 951, 
		    952, 5, 65, 0, 0, 952, 954, 3, 64, 32, 0, 953, 951, 1, 0, 0, 0, 953, 
		    954, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 956, 5, 66, 0, 0, 956, 
		    959, 1, 0, 0, 0, 957, 959, 3, 66, 33, 0, 958, 870, 1, 0, 0, 0, 958, 
		    872, 1, 0, 0, 0, 958, 881, 1, 0, 0, 0, 958, 884, 1, 0, 0, 0, 958, 
		    887, 1, 0, 0, 0, 958, 910, 1, 0, 0, 0, 958, 921, 1, 0, 0, 0, 958, 
		    932, 1, 0, 0, 0, 958, 938, 1, 0, 0, 0, 958, 957, 1, 0, 0, 0, 959, 
		    1079, 1, 0, 0, 0, 960, 961, 10, 20, 0, 0, 961, 962, 5, 11, 0, 0, 962, 
		    1078, 3, 64, 32, 21, 963, 964, 10, 19, 0, 0, 964, 965, 7, 10, 0, 0, 
		    965, 1078, 3, 64, 32, 20, 966, 967, 10, 18, 0, 0, 967, 968, 7, 4, 
		    0, 0, 968, 1078, 3, 64, 32, 19, 969, 970, 10, 17, 0, 0, 970, 971, 
		    7, 11, 0, 0, 971, 1078, 3, 64, 32, 18, 972, 973, 10, 16, 0, 0, 973, 
		    974, 7, 12, 0, 0, 974, 1078, 3, 64, 32, 17, 975, 988, 10, 15, 0, 0, 
		    976, 989, 5, 6, 0, 0, 977, 989, 5, 22, 0, 0, 978, 989, 5, 23, 0, 0, 
		    979, 989, 5, 24, 0, 0, 980, 989, 5, 92, 0, 0, 981, 982, 5, 92, 0, 
		    0, 982, 989, 5, 102, 0, 0, 983, 989, 5, 83, 0, 0, 984, 989, 5, 97, 
		    0, 0, 985, 989, 5, 77, 0, 0, 986, 989, 5, 99, 0, 0, 987, 989, 5, 118, 
		    0, 0, 988, 976, 1, 0, 0, 0, 988, 977, 1, 0, 0, 0, 988, 978, 1, 0, 
		    0, 0, 988, 979, 1, 0, 0, 0, 988, 980, 1, 0, 0, 0, 988, 981, 1, 0, 
		    0, 0, 988, 983, 1, 0, 0, 0, 988, 984, 1, 0, 0, 0, 988, 985, 1, 0, 
		    0, 0, 988, 986, 1, 0, 0, 0, 988, 987, 1, 0, 0, 0, 989, 990, 1, 0, 
		    0, 0, 990, 1078, 3, 64, 32, 16, 991, 992, 10, 14, 0, 0, 992, 993, 
		    5, 32, 0, 0, 993, 1078, 3, 64, 32, 15, 994, 995, 10, 13, 0, 0, 995, 
		    996, 5, 108, 0, 0, 996, 1078, 3, 64, 32, 14, 997, 998, 10, 6, 0, 0, 
		    998, 1000, 5, 92, 0, 0, 999, 1001, 5, 102, 0, 0, 1000, 999, 1, 0, 
		    0, 0, 1000, 1001, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1078, 
		    3, 64, 32, 7, 1003, 1005, 10, 5, 0, 0, 1004, 1006, 5, 102, 0, 0, 1005, 
		    1004, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 
		    1007, 1008, 5, 39, 0, 0, 1008, 1009, 3, 64, 32, 0, 1009, 1010, 5, 
		    32, 0, 0, 1010, 1011, 3, 64, 32, 6, 1011, 1078, 1, 0, 0, 0, 1012, 
		    1013, 10, 9, 0, 0, 1013, 1014, 5, 45, 0, 0, 1014, 1078, 3, 186, 93, 
		    0, 1015, 1017, 10, 8, 0, 0, 1016, 1018, 5, 102, 0, 0, 1017, 1016, 
		    1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1019, 1, 0, 0, 0, 1019, 
		    1020, 7, 13, 0, 0, 1020, 1023, 3, 64, 32, 0, 1021, 1022, 5, 67, 0, 
		    0, 1022, 1024, 3, 64, 32, 0, 1023, 1021, 1, 0, 0, 0, 1023, 1024, 1, 
		    0, 0, 0, 1024, 1078, 1, 0, 0, 0, 1025, 1030, 10, 7, 0, 0, 1026, 1031, 
		    5, 93, 0, 0, 1027, 1031, 5, 103, 0, 0, 1028, 1029, 5, 102, 0, 0, 1029, 
		    1031, 5, 104, 0, 0, 1030, 1026, 1, 0, 0, 0, 1030, 1027, 1, 0, 0, 0, 
		    1030, 1028, 1, 0, 0, 0, 1031, 1078, 1, 0, 0, 0, 1032, 1034, 10, 4, 
		    0, 0, 1033, 1035, 5, 102, 0, 0, 1034, 1033, 1, 0, 0, 0, 1034, 1035, 
		    1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1075, 5, 83, 0, 0, 1037, 
		    1047, 5, 3, 0, 0, 1038, 1048, 3, 82, 41, 0, 1039, 1044, 3, 64, 32, 
		    0, 1040, 1041, 5, 5, 0, 0, 1041, 1043, 3, 64, 32, 0, 1042, 1040, 1, 
		    0, 0, 0, 1043, 1046, 1, 0, 0, 0, 1044, 1042, 1, 0, 0, 0, 1044, 1045, 
		    1, 0, 0, 0, 1045, 1048, 1, 0, 0, 0, 1046, 1044, 1, 0, 0, 0, 1047, 
		    1038, 1, 0, 0, 0, 1047, 1039, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 
		    1048, 1049, 1, 0, 0, 0, 1049, 1076, 5, 4, 0, 0, 1050, 1051, 3, 178, 
		    89, 0, 1051, 1052, 5, 2, 0, 0, 1052, 1054, 1, 0, 0, 0, 1053, 1050, 
		    1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 
		    1076, 3, 180, 90, 0, 1056, 1057, 3, 178, 89, 0, 1057, 1058, 5, 2, 
		    0, 0, 1058, 1060, 1, 0, 0, 0, 1059, 1056, 1, 0, 0, 0, 1059, 1060, 
		    1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1062, 3, 218, 109, 0, 1062, 
		    1071, 5, 3, 0, 0, 1063, 1068, 3, 64, 32, 0, 1064, 1065, 5, 5, 0, 0, 
		    1065, 1067, 3, 64, 32, 0, 1066, 1064, 1, 0, 0, 0, 1067, 1070, 1, 0, 
		    0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1072, 
		    1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 1063, 1, 0, 0, 0, 1071, 
		    1072, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1074, 5, 4, 0, 0, 
		    1074, 1076, 1, 0, 0, 0, 1075, 1037, 1, 0, 0, 0, 1075, 1053, 1, 0, 
		    0, 0, 1075, 1059, 1, 0, 0, 0, 1076, 1078, 1, 0, 0, 0, 1077, 960, 1, 
		    0, 0, 0, 1077, 963, 1, 0, 0, 0, 1077, 966, 1, 0, 0, 0, 1077, 969, 
		    1, 0, 0, 0, 1077, 972, 1, 0, 0, 0, 1077, 975, 1, 0, 0, 0, 1077, 991, 
		    1, 0, 0, 0, 1077, 994, 1, 0, 0, 0, 1077, 997, 1, 0, 0, 0, 1077, 1003, 
		    1, 0, 0, 0, 1077, 1012, 1, 0, 0, 0, 1077, 1015, 1, 0, 0, 0, 1077, 
		    1025, 1, 0, 0, 0, 1077, 1032, 1, 0, 0, 0, 1078, 1081, 1, 0, 0, 0, 
		    1079, 1077, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 65, 1, 0, 0, 
		    0, 1081, 1079, 1, 0, 0, 0, 1082, 1083, 5, 115, 0, 0, 1083, 1088, 5, 
		    3, 0, 0, 1084, 1089, 5, 81, 0, 0, 1085, 1086, 7, 14, 0, 0, 1086, 1087, 
		    5, 5, 0, 0, 1087, 1089, 3, 166, 83, 0, 1088, 1084, 1, 0, 0, 0, 1088, 
		    1085, 1, 0, 0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 1091, 5, 4, 0, 0, 
		    1091, 67, 1, 0, 0, 0, 1092, 1093, 7, 15, 0, 0, 1093, 69, 1, 0, 0, 
		    0, 1094, 1096, 3, 48, 24, 0, 1095, 1094, 1, 0, 0, 0, 1095, 1096, 1, 
		    0, 0, 0, 1096, 1102, 1, 0, 0, 0, 1097, 1103, 5, 88, 0, 0, 1098, 1103, 
		    5, 122, 0, 0, 1099, 1100, 5, 88, 0, 0, 1100, 1101, 5, 108, 0, 0, 1101, 
		    1103, 7, 8, 0, 0, 1102, 1097, 1, 0, 0, 0, 1102, 1098, 1, 0, 0, 0, 
		    1102, 1099, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 1108, 5, 91, 
		    0, 0, 1105, 1106, 3, 178, 89, 0, 1106, 1107, 5, 2, 0, 0, 1107, 1109, 
		    1, 0, 0, 0, 1108, 1105, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 
		    1110, 1, 0, 0, 0, 1110, 1113, 3, 180, 90, 0, 1111, 1112, 5, 33, 0, 
		    0, 1112, 1114, 3, 202, 101, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1114, 
		    1, 0, 0, 0, 1114, 1126, 1, 0, 0, 0, 1115, 1116, 5, 3, 0, 0, 1116, 
		    1121, 3, 184, 92, 0, 1117, 1118, 5, 5, 0, 0, 1118, 1120, 3, 184, 92, 
		    0, 1119, 1117, 1, 0, 0, 0, 1120, 1123, 1, 0, 0, 0, 1121, 1119, 1, 
		    0, 0, 0, 1121, 1122, 1, 0, 0, 0, 1122, 1124, 1, 0, 0, 0, 1123, 1121, 
		    1, 0, 0, 0, 1124, 1125, 5, 4, 0, 0, 1125, 1127, 1, 0, 0, 0, 1126, 
		    1115, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1164, 1, 0, 0, 0, 
		    1128, 1129, 5, 144, 0, 0, 1129, 1130, 5, 3, 0, 0, 1130, 1135, 3, 64, 
		    32, 0, 1131, 1132, 5, 5, 0, 0, 1132, 1134, 3, 64, 32, 0, 1133, 1131, 
		    1, 0, 0, 0, 1134, 1137, 1, 0, 0, 0, 1135, 1133, 1, 0, 0, 0, 1135, 
		    1136, 1, 0, 0, 0, 1136, 1138, 1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0, 
		    1138, 1153, 5, 4, 0, 0, 1139, 1140, 5, 5, 0, 0, 1140, 1141, 5, 3, 
		    0, 0, 1141, 1146, 3, 64, 32, 0, 1142, 1143, 5, 5, 0, 0, 1143, 1145, 
		    3, 64, 32, 0, 1144, 1142, 1, 0, 0, 0, 1145, 1148, 1, 0, 0, 0, 1146, 
		    1144, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1149, 1, 0, 0, 0, 
		    1148, 1146, 1, 0, 0, 0, 1149, 1150, 5, 4, 0, 0, 1150, 1152, 1, 0, 
		    0, 0, 1151, 1139, 1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151, 
		    1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 1158, 1, 0, 0, 0, 1155, 
		    1153, 1, 0, 0, 0, 1156, 1158, 3, 82, 41, 0, 1157, 1128, 1, 0, 0, 0, 
		    1157, 1156, 1, 0, 0, 0, 1158, 1160, 1, 0, 0, 0, 1159, 1161, 3, 74, 
		    37, 0, 1160, 1159, 1, 0, 0, 0, 1160, 1161, 1, 0, 0, 0, 1161, 1165, 
		    1, 0, 0, 0, 1162, 1163, 5, 56, 0, 0, 1163, 1165, 5, 144, 0, 0, 1164, 
		    1157, 1, 0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1165, 1167, 1, 0, 0, 0, 
		    1166, 1168, 3, 72, 36, 0, 1167, 1166, 1, 0, 0, 0, 1167, 1168, 1, 0, 
		    0, 0, 1168, 71, 1, 0, 0, 0, 1169, 1170, 5, 124, 0, 0, 1170, 1175, 
		    3, 96, 48, 0, 1171, 1172, 5, 5, 0, 0, 1172, 1174, 3, 96, 48, 0, 1173, 
		    1171, 1, 0, 0, 0, 1174, 1177, 1, 0, 0, 0, 1175, 1173, 1, 0, 0, 0, 
		    1175, 1176, 1, 0, 0, 0, 1176, 73, 1, 0, 0, 0, 1177, 1175, 1, 0, 0, 
		    0, 1178, 1179, 5, 107, 0, 0, 1179, 1194, 5, 48, 0, 0, 1180, 1181, 
		    5, 3, 0, 0, 1181, 1186, 3, 24, 12, 0, 1182, 1183, 5, 5, 0, 0, 1183, 
		    1185, 3, 24, 12, 0, 1184, 1182, 1, 0, 0, 0, 1185, 1188, 1, 0, 0, 0, 
		    1186, 1184, 1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1189, 1, 0, 
		    0, 0, 1188, 1186, 1, 0, 0, 0, 1189, 1192, 5, 4, 0, 0, 1190, 1191, 
		    5, 148, 0, 0, 1191, 1193, 3, 64, 32, 0, 1192, 1190, 1, 0, 0, 0, 1192, 
		    1193, 1, 0, 0, 0, 1193, 1195, 1, 0, 0, 0, 1194, 1180, 1, 0, 0, 0, 
		    1194, 1195, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1223, 5, 183, 
		    0, 0, 1197, 1224, 5, 184, 0, 0, 1198, 1199, 5, 141, 0, 0, 1199, 1202, 
		    5, 131, 0, 0, 1200, 1203, 3, 184, 92, 0, 1201, 1203, 3, 106, 53, 0, 
		    1202, 1200, 1, 0, 0, 0, 1202, 1201, 1, 0, 0, 0, 1203, 1204, 1, 0, 
		    0, 0, 1204, 1205, 5, 6, 0, 0, 1205, 1216, 3, 64, 32, 0, 1206, 1209, 
		    5, 5, 0, 0, 1207, 1210, 3, 184, 92, 0, 1208, 1210, 3, 106, 53, 0, 
		    1209, 1207, 1, 0, 0, 0, 1209, 1208, 1, 0, 0, 0, 1210, 1211, 1, 0, 
		    0, 0, 1211, 1212, 5, 6, 0, 0, 1212, 1213, 3, 64, 32, 0, 1213, 1215, 
		    1, 0, 0, 0, 1214, 1206, 1, 0, 0, 0, 1215, 1218, 1, 0, 0, 0, 1216, 
		    1214, 1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 1217, 1221, 1, 0, 0, 0, 
		    1218, 1216, 1, 0, 0, 0, 1219, 1220, 5, 148, 0, 0, 1220, 1222, 3, 64, 
		    32, 0, 1221, 1219, 1, 0, 0, 0, 1221, 1222, 1, 0, 0, 0, 1222, 1224, 
		    1, 0, 0, 0, 1223, 1197, 1, 0, 0, 0, 1223, 1198, 1, 0, 0, 0, 1224, 
		    75, 1, 0, 0, 0, 1225, 1229, 5, 112, 0, 0, 1226, 1227, 3, 178, 89, 
		    0, 1227, 1228, 5, 2, 0, 0, 1228, 1230, 1, 0, 0, 0, 1229, 1226, 1, 
		    0, 0, 0, 1229, 1230, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 1238, 
		    3, 198, 99, 0, 1232, 1233, 5, 6, 0, 0, 1233, 1239, 3, 78, 39, 0, 1234, 
		    1235, 5, 3, 0, 0, 1235, 1236, 3, 78, 39, 0, 1236, 1237, 5, 4, 0, 0, 
		    1237, 1239, 1, 0, 0, 0, 1238, 1232, 1, 0, 0, 0, 1238, 1234, 1, 0, 
		    0, 0, 1238, 1239, 1, 0, 0, 0, 1239, 77, 1, 0, 0, 0, 1240, 1244, 3, 
		    34, 17, 0, 1241, 1244, 3, 174, 87, 0, 1242, 1244, 5, 188, 0, 0, 1243, 
		    1240, 1, 0, 0, 0, 1243, 1241, 1, 0, 0, 0, 1243, 1242, 1, 0, 0, 0, 
		    1244, 79, 1, 0, 0, 0, 1245, 1256, 5, 119, 0, 0, 1246, 1257, 3, 186, 
		    93, 0, 1247, 1248, 3, 178, 89, 0, 1248, 1249, 5, 2, 0, 0, 1249, 1251, 
		    1, 0, 0, 0, 1250, 1247, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 
		    1254, 1, 0, 0, 0, 1252, 1255, 3, 180, 90, 0, 1253, 1255, 3, 190, 95, 
		    0, 1254, 1252, 1, 0, 0, 0, 1254, 1253, 1, 0, 0, 0, 1255, 1257, 1, 
		    0, 0, 0, 1256, 1246, 1, 0, 0, 0, 1256, 1250, 1, 0, 0, 0, 1256, 1257, 
		    1, 0, 0, 0, 1257, 81, 1, 0, 0, 0, 1258, 1260, 3, 130, 65, 0, 1259, 
		    1258, 1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 
		    1261, 1267, 3, 86, 43, 0, 1262, 1263, 3, 102, 51, 0, 1263, 1264, 3, 
		    86, 43, 0, 1264, 1266, 1, 0, 0, 0, 1265, 1262, 1, 0, 0, 0, 1266, 1269, 
		    1, 0, 0, 0, 1267, 1265, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268, 
		    1271, 1, 0, 0, 0, 1269, 1267, 1, 0, 0, 0, 1270, 1272, 3, 132, 66, 
		    0, 1271, 1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1274, 1, 
		    0, 0, 0, 1273, 1275, 3, 134, 67, 0, 1274, 1273, 1, 0, 0, 0, 1274, 
		    1275, 1, 0, 0, 0, 1275, 83, 1, 0, 0, 0, 1276, 1284, 3, 94, 47, 0, 
		    1277, 1278, 3, 98, 49, 0, 1278, 1280, 3, 94, 47, 0, 1279, 1281, 3, 
		    100, 50, 0, 1280, 1279, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281, 
		    1283, 1, 0, 0, 0, 1282, 1277, 1, 0, 0, 0, 1283, 1286, 1, 0, 0, 0, 
		    1284, 1282, 1, 0, 0, 0, 1284, 1285, 1, 0, 0, 0, 1285, 85, 1, 0, 0, 
		    0, 1286, 1284, 1, 0, 0, 0, 1287, 1289, 5, 130, 0, 0, 1288, 1290, 7, 
		    16, 0, 0, 1289, 1288, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1291, 
		    1, 0, 0, 0, 1291, 1296, 3, 96, 48, 0, 1292, 1293, 5, 5, 0, 0, 1293, 
		    1295, 3, 96, 48, 0, 1294, 1292, 1, 0, 0, 0, 1295, 1298, 1, 0, 0, 0, 
		    1296, 1294, 1, 0, 0, 0, 1296, 1297, 1, 0, 0, 0, 1297, 1311, 1, 0, 
		    0, 0, 1298, 1296, 1, 0, 0, 0, 1299, 1309, 5, 75, 0, 0, 1300, 1305, 
		    3, 94, 47, 0, 1301, 1302, 5, 5, 0, 0, 1302, 1304, 3, 94, 47, 0, 1303, 
		    1301, 1, 0, 0, 0, 1304, 1307, 1, 0, 0, 0, 1305, 1303, 1, 0, 0, 0, 
		    1305, 1306, 1, 0, 0, 0, 1306, 1310, 1, 0, 0, 0, 1307, 1305, 1, 0, 
		    0, 0, 1308, 1310, 3, 84, 42, 0, 1309, 1300, 1, 0, 0, 0, 1309, 1308, 
		    1, 0, 0, 0, 1310, 1312, 1, 0, 0, 0, 1311, 1299, 1, 0, 0, 0, 1311, 
		    1312, 1, 0, 0, 0, 1312, 1315, 1, 0, 0, 0, 1313, 1314, 5, 148, 0, 0, 
		    1314, 1316, 3, 64, 32, 0, 1315, 1313, 1, 0, 0, 0, 1315, 1316, 1, 0, 
		    0, 0, 1316, 1331, 1, 0, 0, 0, 1317, 1318, 5, 78, 0, 0, 1318, 1319, 
		    5, 40, 0, 0, 1319, 1324, 3, 64, 32, 0, 1320, 1321, 5, 5, 0, 0, 1321, 
		    1323, 3, 64, 32, 0, 1322, 1320, 1, 0, 0, 0, 1323, 1326, 1, 0, 0, 0, 
		    1324, 1322, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1329, 1, 0, 
		    0, 0, 1326, 1324, 1, 0, 0, 0, 1327, 1328, 5, 79, 0, 0, 1328, 1330, 
		    3, 64, 32, 0, 1329, 1327, 1, 0, 0, 0, 1329, 1330, 1, 0, 0, 0, 1330, 
		    1332, 1, 0, 0, 0, 1331, 1317, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 
		    1332, 1347, 1, 0, 0, 0, 1333, 1334, 5, 174, 0, 0, 1334, 1335, 3, 206, 
		    103, 0, 1335, 1336, 5, 33, 0, 0, 1336, 1344, 3, 116, 58, 0, 1337, 
		    1338, 5, 5, 0, 0, 1338, 1339, 3, 206, 103, 0, 1339, 1340, 5, 33, 0, 
		    0, 1340, 1341, 3, 116, 58, 0, 1341, 1343, 1, 0, 0, 0, 1342, 1337, 
		    1, 0, 0, 0, 1343, 1346, 1, 0, 0, 0, 1344, 1342, 1, 0, 0, 0, 1344, 
		    1345, 1, 0, 0, 0, 1345, 1348, 1, 0, 0, 0, 1346, 1344, 1, 0, 0, 0, 
		    1347, 1333, 1, 0, 0, 0, 1347, 1348, 1, 0, 0, 0, 1348, 1378, 1, 0, 
		    0, 0, 1349, 1350, 5, 144, 0, 0, 1350, 1351, 5, 3, 0, 0, 1351, 1356, 
		    3, 64, 32, 0, 1352, 1353, 5, 5, 0, 0, 1353, 1355, 3, 64, 32, 0, 1354, 
		    1352, 1, 0, 0, 0, 1355, 1358, 1, 0, 0, 0, 1356, 1354, 1, 0, 0, 0, 
		    1356, 1357, 1, 0, 0, 0, 1357, 1359, 1, 0, 0, 0, 1358, 1356, 1, 0, 
		    0, 0, 1359, 1374, 5, 4, 0, 0, 1360, 1361, 5, 5, 0, 0, 1361, 1362, 
		    5, 3, 0, 0, 1362, 1367, 3, 64, 32, 0, 1363, 1364, 5, 5, 0, 0, 1364, 
		    1366, 3, 64, 32, 0, 1365, 1363, 1, 0, 0, 0, 1366, 1369, 1, 0, 0, 0, 
		    1367, 1365, 1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368, 1370, 1, 0, 
		    0, 0, 1369, 1367, 1, 0, 0, 0, 1370, 1371, 5, 4, 0, 0, 1371, 1373, 
		    1, 0, 0, 0, 1372, 1360, 1, 0, 0, 0, 1373, 1376, 1, 0, 0, 0, 1374, 
		    1372, 1, 0, 0, 0, 1374, 1375, 1, 0, 0, 0, 1375, 1378, 1, 0, 0, 0, 
		    1376, 1374, 1, 0, 0, 0, 1377, 1287, 1, 0, 0, 0, 1377, 1349, 1, 0, 
		    0, 0, 1378, 87, 1, 0, 0, 0, 1379, 1380, 3, 82, 41, 0, 1380, 89, 1, 
		    0, 0, 0, 1381, 1383, 3, 130, 65, 0, 1382, 1381, 1, 0, 0, 0, 1382, 
		    1383, 1, 0, 0, 0, 1383, 1384, 1, 0, 0, 0, 1384, 1386, 3, 86, 43, 0, 
		    1385, 1387, 3, 132, 66, 0, 1386, 1385, 1, 0, 0, 0, 1386, 1387, 1, 
		    0, 0, 0, 1387, 1389, 1, 0, 0, 0, 1388, 1390, 3, 134, 67, 0, 1389, 
		    1388, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 91, 1, 0, 0, 0, 1391, 
		    1393, 3, 130, 65, 0, 1392, 1391, 1, 0, 0, 0, 1392, 1393, 1, 0, 0, 
		    0, 1393, 1394, 1, 0, 0, 0, 1394, 1404, 3, 86, 43, 0, 1395, 1397, 5, 
		    139, 0, 0, 1396, 1398, 5, 29, 0, 0, 1397, 1396, 1, 0, 0, 0, 1397, 
		    1398, 1, 0, 0, 0, 1398, 1402, 1, 0, 0, 0, 1399, 1402, 5, 90, 0, 0, 
		    1400, 1402, 5, 68, 0, 0, 1401, 1395, 1, 0, 0, 0, 1401, 1399, 1, 0, 
		    0, 0, 1401, 1400, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1405, 
		    3, 86, 43, 0, 1404, 1401, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406, 
		    1404, 1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1409, 1, 0, 0, 0, 
		    1408, 1410, 3, 132, 66, 0, 1409, 1408, 1, 0, 0, 0, 1409, 1410, 1, 
		    0, 0, 0, 1410, 1412, 1, 0, 0, 0, 1411, 1413, 3, 134, 67, 0, 1412, 
		    1411, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413, 93, 1, 0, 0, 0, 1414, 
		    1415, 3, 178, 89, 0, 1415, 1416, 5, 2, 0, 0, 1416, 1418, 1, 0, 0, 
		    0, 1417, 1414, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1419, 1, 
		    0, 0, 0, 1419, 1424, 3, 180, 90, 0, 1420, 1422, 5, 33, 0, 0, 1421, 
		    1420, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422, 1423, 1, 0, 0, 0, 
		    1423, 1425, 3, 202, 101, 0, 1424, 1421, 1, 0, 0, 0, 1424, 1425, 1, 
		    0, 0, 0, 1425, 1431, 1, 0, 0, 0, 1426, 1427, 5, 85, 0, 0, 1427, 1428, 
		    5, 40, 0, 0, 1428, 1432, 3, 190, 95, 0, 1429, 1430, 5, 102, 0, 0, 
		    1430, 1432, 5, 85, 0, 0, 1431, 1426, 1, 0, 0, 0, 1431, 1429, 1, 0, 
		    0, 0, 1431, 1432, 1, 0, 0, 0, 1432, 1479, 1, 0, 0, 0, 1433, 1434, 
		    3, 178, 89, 0, 1434, 1435, 5, 2, 0, 0, 1435, 1437, 1, 0, 0, 0, 1436, 
		    1433, 1, 0, 0, 0, 1436, 1437, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 
		    1438, 1439, 3, 218, 109, 0, 1439, 1440, 5, 3, 0, 0, 1440, 1445, 3, 
		    64, 32, 0, 1441, 1442, 5, 5, 0, 0, 1442, 1444, 3, 64, 32, 0, 1443, 
		    1441, 1, 0, 0, 0, 1444, 1447, 1, 0, 0, 0, 1445, 1443, 1, 0, 0, 0, 
		    1445, 1446, 1, 0, 0, 0, 1446, 1448, 1, 0, 0, 0, 1447, 1445, 1, 0, 
		    0, 0, 1448, 1453, 5, 4, 0, 0, 1449, 1451, 5, 33, 0, 0, 1450, 1449, 
		    1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 
		    1454, 3, 202, 101, 0, 1453, 1450, 1, 0, 0, 0, 1453, 1454, 1, 0, 0, 
		    0, 1454, 1479, 1, 0, 0, 0, 1455, 1465, 5, 3, 0, 0, 1456, 1461, 3, 
		    94, 47, 0, 1457, 1458, 5, 5, 0, 0, 1458, 1460, 3, 94, 47, 0, 1459, 
		    1457, 1, 0, 0, 0, 1460, 1463, 1, 0, 0, 0, 1461, 1459, 1, 0, 0, 0, 
		    1461, 1462, 1, 0, 0, 0, 1462, 1466, 1, 0, 0, 0, 1463, 1461, 1, 0, 
		    0, 0, 1464, 1466, 3, 84, 42, 0, 1465, 1456, 1, 0, 0, 0, 1465, 1464, 
		    1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467, 1468, 5, 4, 0, 0, 1468, 
		    1479, 1, 0, 0, 0, 1469, 1470, 5, 3, 0, 0, 1470, 1471, 3, 82, 41, 0, 
		    1471, 1476, 5, 4, 0, 0, 1472, 1474, 5, 33, 0, 0, 1473, 1472, 1, 0, 
		    0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1477, 
		    3, 202, 101, 0, 1476, 1473, 1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 
		    1479, 1, 0, 0, 0, 1478, 1417, 1, 0, 0, 0, 1478, 1436, 1, 0, 0, 0, 
		    1478, 1455, 1, 0, 0, 0, 1478, 1469, 1, 0, 0, 0, 1479, 95, 1, 0, 0, 
		    0, 1480, 1493, 5, 7, 0, 0, 1481, 1482, 3, 180, 90, 0, 1482, 1483, 
		    5, 2, 0, 0, 1483, 1484, 5, 7, 0, 0, 1484, 1493, 1, 0, 0, 0, 1485, 
		    1490, 3, 64, 32, 0, 1486, 1488, 5, 33, 0, 0, 1487, 1486, 1, 0, 0, 
		    0, 1487, 1488, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1491, 3, 
		    170, 85, 0, 1490, 1487, 1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0, 1491, 
		    1493, 1, 0, 0, 0, 1492, 1480, 1, 0, 0, 0, 1492, 1481, 1, 0, 0, 0, 
		    1492, 1485, 1, 0, 0, 0, 1493, 97, 1, 0, 0, 0, 1494, 1508, 5, 5, 0, 
		    0, 1495, 1497, 5, 100, 0, 0, 1496, 1495, 1, 0, 0, 0, 1496, 1497, 1, 
		    0, 0, 0, 1497, 1504, 1, 0, 0, 0, 1498, 1500, 5, 96, 0, 0, 1499, 1501, 
		    5, 110, 0, 0, 1500, 1499, 1, 0, 0, 0, 1500, 1501, 1, 0, 0, 0, 1501, 
		    1505, 1, 0, 0, 0, 1502, 1505, 5, 87, 0, 0, 1503, 1505, 5, 51, 0, 0, 
		    1504, 1498, 1, 0, 0, 0, 1504, 1502, 1, 0, 0, 0, 1504, 1503, 1, 0, 
		    0, 0, 1504, 1505, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1508, 
		    5, 94, 0, 0, 1507, 1494, 1, 0, 0, 0, 1507, 1496, 1, 0, 0, 0, 1508, 
		    99, 1, 0, 0, 0, 1509, 1510, 5, 107, 0, 0, 1510, 1524, 3, 64, 32, 0, 
		    1511, 1512, 5, 142, 0, 0, 1512, 1513, 5, 3, 0, 0, 1513, 1518, 3, 184, 
		    92, 0, 1514, 1515, 5, 5, 0, 0, 1515, 1517, 3, 184, 92, 0, 1516, 1514, 
		    1, 0, 0, 0, 1517, 1520, 1, 0, 0, 0, 1518, 1516, 1, 0, 0, 0, 1518, 
		    1519, 1, 0, 0, 0, 1519, 1521, 1, 0, 0, 0, 1520, 1518, 1, 0, 0, 0, 
		    1521, 1522, 5, 4, 0, 0, 1522, 1524, 1, 0, 0, 0, 1523, 1509, 1, 0, 
		    0, 0, 1523, 1511, 1, 0, 0, 0, 1524, 101, 1, 0, 0, 0, 1525, 1527, 5, 
		    139, 0, 0, 1526, 1528, 5, 29, 0, 0, 1527, 1526, 1, 0, 0, 0, 1527, 
		    1528, 1, 0, 0, 0, 1528, 1532, 1, 0, 0, 0, 1529, 1532, 5, 90, 0, 0, 
		    1530, 1532, 5, 68, 0, 0, 1531, 1525, 1, 0, 0, 0, 1531, 1529, 1, 0, 
		    0, 0, 1531, 1530, 1, 0, 0, 0, 1532, 103, 1, 0, 0, 0, 1533, 1535, 3, 
		    48, 24, 0, 1534, 1533, 1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 1536, 
		    1, 0, 0, 0, 1536, 1539, 5, 141, 0, 0, 1537, 1538, 5, 108, 0, 0, 1538, 
		    1540, 7, 8, 0, 0, 1539, 1537, 1, 0, 0, 0, 1539, 1540, 1, 0, 0, 0, 
		    1540, 1541, 1, 0, 0, 0, 1541, 1542, 3, 110, 55, 0, 1542, 1545, 5, 
		    131, 0, 0, 1543, 1546, 3, 184, 92, 0, 1544, 1546, 3, 106, 53, 0, 1545, 
		    1543, 1, 0, 0, 0, 1545, 1544, 1, 0, 0, 0, 1546, 1547, 1, 0, 0, 0, 
		    1547, 1548, 5, 6, 0, 0, 1548, 1559, 3, 64, 32, 0, 1549, 1552, 5, 5, 
		    0, 0, 1550, 1553, 3, 184, 92, 0, 1551, 1553, 3, 106, 53, 0, 1552, 
		    1550, 1, 0, 0, 0, 1552, 1551, 1, 0, 0, 0, 1553, 1554, 1, 0, 0, 0, 
		    1554, 1555, 5, 6, 0, 0, 1555, 1556, 3, 64, 32, 0, 1556, 1558, 1, 0, 
		    0, 0, 1557, 1549, 1, 0, 0, 0, 1558, 1561, 1, 0, 0, 0, 1559, 1557, 
		    1, 0, 0, 0, 1559, 1560, 1, 0, 0, 0, 1560, 1574, 1, 0, 0, 0, 1561, 
		    1559, 1, 0, 0, 0, 1562, 1572, 5, 75, 0, 0, 1563, 1568, 3, 94, 47, 
		    0, 1564, 1565, 5, 5, 0, 0, 1565, 1567, 3, 94, 47, 0, 1566, 1564, 1, 
		    0, 0, 0, 1567, 1570, 1, 0, 0, 0, 1568, 1566, 1, 0, 0, 0, 1568, 1569, 
		    1, 0, 0, 0, 1569, 1573, 1, 0, 0, 0, 1570, 1568, 1, 0, 0, 0, 1571, 
		    1573, 3, 84, 42, 0, 1572, 1563, 1, 0, 0, 0, 1572, 1571, 1, 0, 0, 0, 
		    1573, 1575, 1, 0, 0, 0, 1574, 1562, 1, 0, 0, 0, 1574, 1575, 1, 0, 
		    0, 0, 1575, 1578, 1, 0, 0, 0, 1576, 1577, 5, 148, 0, 0, 1577, 1579, 
		    3, 64, 32, 0, 1578, 1576, 1, 0, 0, 0, 1578, 1579, 1, 0, 0, 0, 1579, 
		    1581, 1, 0, 0, 0, 1580, 1582, 3, 72, 36, 0, 1581, 1580, 1, 0, 0, 0, 
		    1581, 1582, 1, 0, 0, 0, 1582, 105, 1, 0, 0, 0, 1583, 1584, 5, 3, 0, 
		    0, 1584, 1589, 3, 184, 92, 0, 1585, 1586, 5, 5, 0, 0, 1586, 1588, 
		    3, 184, 92, 0, 1587, 1585, 1, 0, 0, 0, 1588, 1591, 1, 0, 0, 0, 1589, 
		    1587, 1, 0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 1592, 1, 0, 0, 0, 
		    1591, 1589, 1, 0, 0, 0, 1592, 1593, 5, 4, 0, 0, 1593, 107, 1, 0, 0, 
		    0, 1594, 1596, 3, 48, 24, 0, 1595, 1594, 1, 0, 0, 0, 1595, 1596, 1, 
		    0, 0, 0, 1596, 1597, 1, 0, 0, 0, 1597, 1600, 5, 141, 0, 0, 1598, 1599, 
		    5, 108, 0, 0, 1599, 1601, 7, 8, 0, 0, 1600, 1598, 1, 0, 0, 0, 1600, 
		    1601, 1, 0, 0, 0, 1601, 1602, 1, 0, 0, 0, 1602, 1603, 3, 110, 55, 
		    0, 1603, 1606, 5, 131, 0, 0, 1604, 1607, 3, 184, 92, 0, 1605, 1607, 
		    3, 106, 53, 0, 1606, 1604, 1, 0, 0, 0, 1606, 1605, 1, 0, 0, 0, 1607, 
		    1608, 1, 0, 0, 0, 1608, 1609, 5, 6, 0, 0, 1609, 1620, 3, 64, 32, 0, 
		    1610, 1613, 5, 5, 0, 0, 1611, 1614, 3, 184, 92, 0, 1612, 1614, 3, 
		    106, 53, 0, 1613, 1611, 1, 0, 0, 0, 1613, 1612, 1, 0, 0, 0, 1614, 
		    1615, 1, 0, 0, 0, 1615, 1616, 5, 6, 0, 0, 1616, 1617, 3, 64, 32, 0, 
		    1617, 1619, 1, 0, 0, 0, 1618, 1610, 1, 0, 0, 0, 1619, 1622, 1, 0, 
		    0, 0, 1620, 1618, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1625, 
		    1, 0, 0, 0, 1622, 1620, 1, 0, 0, 0, 1623, 1624, 5, 148, 0, 0, 1624, 
		    1626, 3, 64, 32, 0, 1625, 1623, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 
		    1626, 1628, 1, 0, 0, 0, 1627, 1629, 3, 72, 36, 0, 1628, 1627, 1, 0, 
		    0, 0, 1628, 1629, 1, 0, 0, 0, 1629, 1634, 1, 0, 0, 0, 1630, 1632, 
		    3, 132, 66, 0, 1631, 1630, 1, 0, 0, 0, 1631, 1632, 1, 0, 0, 0, 1632, 
		    1633, 1, 0, 0, 0, 1633, 1635, 3, 134, 67, 0, 1634, 1631, 1, 0, 0, 
		    0, 1634, 1635, 1, 0, 0, 0, 1635, 109, 1, 0, 0, 0, 1636, 1637, 3, 178, 
		    89, 0, 1637, 1638, 5, 2, 0, 0, 1638, 1640, 1, 0, 0, 0, 1639, 1636, 
		    1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 
		    1644, 3, 180, 90, 0, 1642, 1643, 5, 33, 0, 0, 1643, 1645, 3, 208, 
		    104, 0, 1644, 1642, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1651, 
		    1, 0, 0, 0, 1646, 1647, 5, 85, 0, 0, 1647, 1648, 5, 40, 0, 0, 1648, 
		    1652, 3, 190, 95, 0, 1649, 1650, 5, 102, 0, 0, 1650, 1652, 5, 85, 
		    0, 0, 1651, 1646, 1, 0, 0, 0, 1651, 1649, 1, 0, 0, 0, 1651, 1652, 
		    1, 0, 0, 0, 1652, 111, 1, 0, 0, 0, 1653, 1655, 5, 143, 0, 0, 1654, 
		    1656, 3, 178, 89, 0, 1655, 1654, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 
		    0, 1656, 1659, 1, 0, 0, 0, 1657, 1658, 5, 91, 0, 0, 1658, 1660, 3, 
		    210, 105, 0, 1659, 1657, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 
		    113, 1, 0, 0, 0, 1661, 1662, 5, 178, 0, 0, 1662, 1663, 5, 3, 0, 0, 
		    1663, 1664, 5, 148, 0, 0, 1664, 1665, 3, 64, 32, 0, 1665, 1666, 5, 
		    4, 0, 0, 1666, 115, 1, 0, 0, 0, 1667, 1669, 5, 3, 0, 0, 1668, 1670, 
		    3, 212, 106, 0, 1669, 1668, 1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 
		    1681, 1, 0, 0, 0, 1671, 1672, 5, 153, 0, 0, 1672, 1673, 5, 40, 0, 
		    0, 1673, 1678, 3, 64, 32, 0, 1674, 1675, 5, 5, 0, 0, 1675, 1677, 3, 
		    64, 32, 0, 1676, 1674, 1, 0, 0, 0, 1677, 1680, 1, 0, 0, 0, 1678, 1676, 
		    1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 1682, 1, 0, 0, 0, 1680, 
		    1678, 1, 0, 0, 0, 1681, 1671, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 
		    1682, 1683, 1, 0, 0, 0, 1683, 1684, 5, 109, 0, 0, 1684, 1685, 5, 40, 
		    0, 0, 1685, 1690, 3, 136, 68, 0, 1686, 1687, 5, 5, 0, 0, 1687, 1689, 
		    3, 136, 68, 0, 1688, 1686, 1, 0, 0, 0, 1689, 1692, 1, 0, 0, 0, 1690, 
		    1688, 1, 0, 0, 0, 1690, 1691, 1, 0, 0, 0, 1691, 1694, 1, 0, 0, 0, 
		    1692, 1690, 1, 0, 0, 0, 1693, 1695, 3, 120, 60, 0, 1694, 1693, 1, 
		    0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 1696, 1, 0, 0, 0, 1696, 1697, 
		    5, 4, 0, 0, 1697, 117, 1, 0, 0, 0, 1698, 1732, 5, 152, 0, 0, 1699, 
		    1733, 3, 206, 103, 0, 1700, 1702, 5, 3, 0, 0, 1701, 1703, 3, 212, 
		    106, 0, 1702, 1701, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 1714, 
		    1, 0, 0, 0, 1704, 1705, 5, 153, 0, 0, 1705, 1706, 5, 40, 0, 0, 1706, 
		    1711, 3, 64, 32, 0, 1707, 1708, 5, 5, 0, 0, 1708, 1710, 3, 64, 32, 
		    0, 1709, 1707, 1, 0, 0, 0, 1710, 1713, 1, 0, 0, 0, 1711, 1709, 1, 
		    0, 0, 0, 1711, 1712, 1, 0, 0, 0, 1712, 1715, 1, 0, 0, 0, 1713, 1711, 
		    1, 0, 0, 0, 1714, 1704, 1, 0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715, 
		    1726, 1, 0, 0, 0, 1716, 1717, 5, 109, 0, 0, 1717, 1718, 5, 40, 0, 
		    0, 1718, 1723, 3, 136, 68, 0, 1719, 1720, 5, 5, 0, 0, 1720, 1722, 
		    3, 136, 68, 0, 1721, 1719, 1, 0, 0, 0, 1722, 1725, 1, 0, 0, 0, 1723, 
		    1721, 1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0, 1724, 1727, 1, 0, 0, 0, 
		    1725, 1723, 1, 0, 0, 0, 1726, 1716, 1, 0, 0, 0, 1726, 1727, 1, 0, 
		    0, 0, 1727, 1729, 1, 0, 0, 0, 1728, 1730, 3, 120, 60, 0, 1729, 1728, 
		    1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730, 1731, 1, 0, 0, 0, 1731, 
		    1733, 5, 4, 0, 0, 1732, 1699, 1, 0, 0, 0, 1732, 1700, 1, 0, 0, 0, 
		    1733, 119, 1, 0, 0, 0, 1734, 1742, 3, 122, 61, 0, 1735, 1736, 5, 180, 
		    0, 0, 1736, 1737, 5, 101, 0, 0, 1737, 1743, 5, 182, 0, 0, 1738, 1739, 
		    5, 157, 0, 0, 1739, 1743, 5, 127, 0, 0, 1740, 1743, 5, 78, 0, 0, 1741, 
		    1743, 5, 181, 0, 0, 1742, 1735, 1, 0, 0, 0, 1742, 1738, 1, 0, 0, 0, 
		    1742, 1740, 1, 0, 0, 0, 1742, 1741, 1, 0, 0, 0, 1742, 1743, 1, 0, 
		    0, 0, 1743, 121, 1, 0, 0, 0, 1744, 1751, 7, 17, 0, 0, 1745, 1752, 
		    3, 144, 72, 0, 1746, 1747, 5, 39, 0, 0, 1747, 1748, 3, 140, 70, 0, 
		    1748, 1749, 5, 32, 0, 0, 1749, 1750, 3, 142, 71, 0, 1750, 1752, 1, 
		    0, 0, 0, 1751, 1745, 1, 0, 0, 0, 1751, 1746, 1, 0, 0, 0, 1752, 123, 
		    1, 0, 0, 0, 1753, 1754, 3, 214, 107, 0, 1754, 1764, 5, 3, 0, 0, 1755, 
		    1760, 3, 64, 32, 0, 1756, 1757, 5, 5, 0, 0, 1757, 1759, 3, 64, 32, 
		    0, 1758, 1756, 1, 0, 0, 0, 1759, 1762, 1, 0, 0, 0, 1760, 1758, 1, 
		    0, 0, 0, 1760, 1761, 1, 0, 0, 0, 1761, 1765, 1, 0, 0, 0, 1762, 1760, 
		    1, 0, 0, 0, 1763, 1765, 5, 7, 0, 0, 1764, 1755, 1, 0, 0, 0, 1764, 
		    1763, 1, 0, 0, 0, 1765, 1766, 1, 0, 0, 0, 1766, 1767, 5, 4, 0, 0, 
		    1767, 125, 1, 0, 0, 0, 1768, 1769, 3, 216, 108, 0, 1769, 1782, 5, 
		    3, 0, 0, 1770, 1772, 5, 62, 0, 0, 1771, 1770, 1, 0, 0, 0, 1771, 1772, 
		    1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773, 1778, 3, 64, 32, 0, 1774, 
		    1775, 5, 5, 0, 0, 1775, 1777, 3, 64, 32, 0, 1776, 1774, 1, 0, 0, 0, 
		    1777, 1780, 1, 0, 0, 0, 1778, 1776, 1, 0, 0, 0, 1778, 1779, 1, 0, 
		    0, 0, 1779, 1783, 1, 0, 0, 0, 1780, 1778, 1, 0, 0, 0, 1781, 1783, 
		    5, 7, 0, 0, 1782, 1771, 1, 0, 0, 0, 1782, 1781, 1, 0, 0, 0, 1782, 
		    1783, 1, 0, 0, 0, 1783, 1784, 1, 0, 0, 0, 1784, 1786, 5, 4, 0, 0, 
		    1785, 1787, 3, 114, 57, 0, 1786, 1785, 1, 0, 0, 0, 1786, 1787, 1, 
		    0, 0, 0, 1787, 127, 1, 0, 0, 0, 1788, 1789, 3, 146, 73, 0, 1789, 1799, 
		    5, 3, 0, 0, 1790, 1795, 3, 64, 32, 0, 1791, 1792, 5, 5, 0, 0, 1792, 
		    1794, 3, 64, 32, 0, 1793, 1791, 1, 0, 0, 0, 1794, 1797, 1, 0, 0, 0, 
		    1795, 1793, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796, 1800, 1, 0, 
		    0, 0, 1797, 1795, 1, 0, 0, 0, 1798, 1800, 5, 7, 0, 0, 1799, 1790, 
		    1, 0, 0, 0, 1799, 1798, 1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 
		    1801, 1, 0, 0, 0, 1801, 1803, 5, 4, 0, 0, 1802, 1804, 3, 114, 57, 
		    0, 1803, 1802, 1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1805, 1, 
		    0, 0, 0, 1805, 1808, 5, 152, 0, 0, 1806, 1809, 3, 116, 58, 0, 1807, 
		    1809, 3, 206, 103, 0, 1808, 1806, 1, 0, 0, 0, 1808, 1807, 1, 0, 0, 
		    0, 1809, 129, 1, 0, 0, 0, 1810, 1812, 5, 149, 0, 0, 1811, 1813, 5, 
		    116, 0, 0, 1812, 1811, 1, 0, 0, 0, 1812, 1813, 1, 0, 0, 0, 1813, 1814, 
		    1, 0, 0, 0, 1814, 1819, 3, 54, 27, 0, 1815, 1816, 5, 5, 0, 0, 1816, 
		    1818, 3, 54, 27, 0, 1817, 1815, 1, 0, 0, 0, 1818, 1821, 1, 0, 0, 0, 
		    1819, 1817, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 131, 1, 0, 0, 
		    0, 1821, 1819, 1, 0, 0, 0, 1822, 1823, 5, 109, 0, 0, 1823, 1824, 5, 
		    40, 0, 0, 1824, 1829, 3, 136, 68, 0, 1825, 1826, 5, 5, 0, 0, 1826, 
		    1828, 3, 136, 68, 0, 1827, 1825, 1, 0, 0, 0, 1828, 1831, 1, 0, 0, 
		    0, 1829, 1827, 1, 0, 0, 0, 1829, 1830, 1, 0, 0, 0, 1830, 133, 1, 0, 
		    0, 0, 1831, 1829, 1, 0, 0, 0, 1832, 1833, 5, 98, 0, 0, 1833, 1836, 
		    3, 64, 32, 0, 1834, 1835, 7, 18, 0, 0, 1835, 1837, 3, 64, 32, 0, 1836, 
		    1834, 1, 0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837, 135, 1, 0, 0, 0, 1838, 
		    1841, 3, 64, 32, 0, 1839, 1840, 5, 45, 0, 0, 1840, 1842, 3, 186, 93, 
		    0, 1841, 1839, 1, 0, 0, 0, 1841, 1842, 1, 0, 0, 0, 1842, 1844, 1, 
		    0, 0, 0, 1843, 1845, 3, 138, 69, 0, 1844, 1843, 1, 0, 0, 0, 1844, 
		    1845, 1, 0, 0, 0, 1845, 1848, 1, 0, 0, 0, 1846, 1847, 5, 175, 0, 0, 
		    1847, 1849, 7, 19, 0, 0, 1848, 1846, 1, 0, 0, 0, 1848, 1849, 1, 0, 
		    0, 0, 1849, 137, 1, 0, 0, 0, 1850, 1851, 7, 20, 0, 0, 1851, 139, 1, 
		    0, 0, 0, 1852, 1853, 3, 64, 32, 0, 1853, 1854, 5, 155, 0, 0, 1854, 
		    1863, 1, 0, 0, 0, 1855, 1856, 3, 64, 32, 0, 1856, 1857, 5, 158, 0, 
		    0, 1857, 1863, 1, 0, 0, 0, 1858, 1859, 5, 157, 0, 0, 1859, 1863, 5, 
		    127, 0, 0, 1860, 1861, 5, 156, 0, 0, 1861, 1863, 5, 155, 0, 0, 1862, 
		    1852, 1, 0, 0, 0, 1862, 1855, 1, 0, 0, 0, 1862, 1858, 1, 0, 0, 0, 
		    1862, 1860, 1, 0, 0, 0, 1863, 141, 1, 0, 0, 0, 1864, 1865, 3, 64, 
		    32, 0, 1865, 1866, 5, 155, 0, 0, 1866, 1875, 1, 0, 0, 0, 1867, 1868, 
		    3, 64, 32, 0, 1868, 1869, 5, 158, 0, 0, 1869, 1875, 1, 0, 0, 0, 1870, 
		    1871, 5, 157, 0, 0, 1871, 1875, 5, 127, 0, 0, 1872, 1873, 5, 156, 
		    0, 0, 1873, 1875, 5, 158, 0, 0, 1874, 1864, 1, 0, 0, 0, 1874, 1867, 
		    1, 0, 0, 0, 1874, 1870, 1, 0, 0, 0, 1874, 1872, 1, 0, 0, 0, 1875, 
		    143, 1, 0, 0, 0, 1876, 1877, 3, 64, 32, 0, 1877, 1878, 5, 155, 0, 
		    0, 1878, 1884, 1, 0, 0, 0, 1879, 1880, 5, 156, 0, 0, 1880, 1884, 5, 
		    155, 0, 0, 1881, 1882, 5, 157, 0, 0, 1882, 1884, 5, 127, 0, 0, 1883, 
		    1876, 1, 0, 0, 0, 1883, 1879, 1, 0, 0, 0, 1883, 1881, 1, 0, 0, 0, 
		    1884, 145, 1, 0, 0, 0, 1885, 1886, 7, 21, 0, 0, 1886, 1887, 5, 3, 
		    0, 0, 1887, 1888, 3, 64, 32, 0, 1888, 1889, 5, 4, 0, 0, 1889, 1890, 
		    5, 152, 0, 0, 1890, 1892, 5, 3, 0, 0, 1891, 1893, 3, 152, 76, 0, 1892, 
		    1891, 1, 0, 0, 0, 1892, 1893, 1, 0, 0, 0, 1893, 1894, 1, 0, 0, 0, 
		    1894, 1896, 3, 156, 78, 0, 1895, 1897, 3, 122, 61, 0, 1896, 1895, 
		    1, 0, 0, 0, 1896, 1897, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 
		    1899, 5, 4, 0, 0, 1899, 1971, 1, 0, 0, 0, 1900, 1901, 7, 22, 0, 0, 
		    1901, 1902, 5, 3, 0, 0, 1902, 1903, 5, 4, 0, 0, 1903, 1904, 5, 152, 
		    0, 0, 1904, 1906, 5, 3, 0, 0, 1905, 1907, 3, 152, 76, 0, 1906, 1905, 
		    1, 0, 0, 0, 1906, 1907, 1, 0, 0, 0, 1907, 1909, 1, 0, 0, 0, 1908, 
		    1910, 3, 154, 77, 0, 1909, 1908, 1, 0, 0, 0, 1909, 1910, 1, 0, 0, 
		    0, 1910, 1911, 1, 0, 0, 0, 1911, 1971, 5, 4, 0, 0, 1912, 1913, 7, 
		    23, 0, 0, 1913, 1914, 5, 3, 0, 0, 1914, 1915, 5, 4, 0, 0, 1915, 1916, 
		    5, 152, 0, 0, 1916, 1918, 5, 3, 0, 0, 1917, 1919, 3, 152, 76, 0, 1918, 
		    1917, 1, 0, 0, 0, 1918, 1919, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 
		    1920, 1921, 3, 156, 78, 0, 1921, 1922, 5, 4, 0, 0, 1922, 1971, 1, 
		    0, 0, 0, 1923, 1924, 7, 24, 0, 0, 1924, 1925, 5, 3, 0, 0, 1925, 1927, 
		    3, 64, 32, 0, 1926, 1928, 3, 148, 74, 0, 1927, 1926, 1, 0, 0, 0, 1927, 
		    1928, 1, 0, 0, 0, 1928, 1930, 1, 0, 0, 0, 1929, 1931, 3, 150, 75, 
		    0, 1930, 1929, 1, 0, 0, 0, 1930, 1931, 1, 0, 0, 0, 1931, 1932, 1, 
		    0, 0, 0, 1932, 1933, 5, 4, 0, 0, 1933, 1934, 5, 152, 0, 0, 1934, 1936, 
		    5, 3, 0, 0, 1935, 1937, 3, 152, 76, 0, 1936, 1935, 1, 0, 0, 0, 1936, 
		    1937, 1, 0, 0, 0, 1937, 1938, 1, 0, 0, 0, 1938, 1939, 3, 156, 78, 
		    0, 1939, 1940, 5, 4, 0, 0, 1940, 1971, 1, 0, 0, 0, 1941, 1942, 5, 
		    164, 0, 0, 1942, 1943, 5, 3, 0, 0, 1943, 1944, 3, 64, 32, 0, 1944, 
		    1945, 5, 5, 0, 0, 1945, 1946, 3, 34, 17, 0, 1946, 1947, 5, 4, 0, 0, 
		    1947, 1948, 5, 152, 0, 0, 1948, 1950, 5, 3, 0, 0, 1949, 1951, 3, 152, 
		    76, 0, 1950, 1949, 1, 0, 0, 0, 1950, 1951, 1, 0, 0, 0, 1951, 1952, 
		    1, 0, 0, 0, 1952, 1954, 3, 156, 78, 0, 1953, 1955, 3, 122, 61, 0, 
		    1954, 1953, 1, 0, 0, 0, 1954, 1955, 1, 0, 0, 0, 1955, 1956, 1, 0, 
		    0, 0, 1956, 1957, 5, 4, 0, 0, 1957, 1971, 1, 0, 0, 0, 1958, 1959, 
		    5, 165, 0, 0, 1959, 1960, 5, 3, 0, 0, 1960, 1961, 3, 64, 32, 0, 1961, 
		    1962, 5, 4, 0, 0, 1962, 1963, 5, 152, 0, 0, 1963, 1965, 5, 3, 0, 0, 
		    1964, 1966, 3, 152, 76, 0, 1965, 1964, 1, 0, 0, 0, 1965, 1966, 1, 
		    0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1968, 3, 156, 78, 0, 1968, 
		    1969, 5, 4, 0, 0, 1969, 1971, 1, 0, 0, 0, 1970, 1885, 1, 0, 0, 0, 
		    1970, 1900, 1, 0, 0, 0, 1970, 1912, 1, 0, 0, 0, 1970, 1923, 1, 0, 
		    0, 0, 1970, 1941, 1, 0, 0, 0, 1970, 1958, 1, 0, 0, 0, 1971, 147, 1, 
		    0, 0, 0, 1972, 1973, 5, 5, 0, 0, 1973, 1974, 3, 34, 17, 0, 1974, 149, 
		    1, 0, 0, 0, 1975, 1976, 5, 5, 0, 0, 1976, 1977, 3, 34, 17, 0, 1977, 
		    151, 1, 0, 0, 0, 1978, 1979, 5, 153, 0, 0, 1979, 1981, 5, 40, 0, 0, 
		    1980, 1982, 3, 64, 32, 0, 1981, 1980, 1, 0, 0, 0, 1982, 1983, 1, 0, 
		    0, 0, 1983, 1981, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 153, 1, 
		    0, 0, 0, 1985, 1986, 5, 109, 0, 0, 1986, 1988, 5, 40, 0, 0, 1987, 
		    1989, 3, 64, 32, 0, 1988, 1987, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 
		    1990, 1988, 1, 0, 0, 0, 1990, 1991, 1, 0, 0, 0, 1991, 155, 1, 0, 0, 
		    0, 1992, 1993, 5, 109, 0, 0, 1993, 1994, 5, 40, 0, 0, 1994, 1995, 
		    3, 158, 79, 0, 1995, 157, 1, 0, 0, 0, 1996, 1998, 3, 64, 32, 0, 1997, 
		    1999, 3, 138, 69, 0, 1998, 1997, 1, 0, 0, 0, 1998, 1999, 1, 0, 0, 
		    0, 1999, 2007, 1, 0, 0, 0, 2000, 2001, 5, 5, 0, 0, 2001, 2003, 3, 
		    64, 32, 0, 2002, 2004, 3, 138, 69, 0, 2003, 2002, 1, 0, 0, 0, 2003, 
		    2004, 1, 0, 0, 0, 2004, 2006, 1, 0, 0, 0, 2005, 2000, 1, 0, 0, 0, 
		    2006, 2009, 1, 0, 0, 0, 2007, 2005, 1, 0, 0, 0, 2007, 2008, 1, 0, 
		    0, 0, 2008, 159, 1, 0, 0, 0, 2009, 2007, 1, 0, 0, 0, 2010, 2011, 3, 
		    82, 41, 0, 2011, 161, 1, 0, 0, 0, 2012, 2013, 3, 82, 41, 0, 2013, 
		    163, 1, 0, 0, 0, 2014, 2015, 7, 25, 0, 0, 2015, 165, 1, 0, 0, 0, 2016, 
		    2017, 5, 188, 0, 0, 2017, 167, 1, 0, 0, 0, 2018, 2021, 3, 64, 32, 
		    0, 2019, 2021, 3, 28, 14, 0, 2020, 2018, 1, 0, 0, 0, 2020, 2019, 1, 
		    0, 0, 0, 2021, 169, 1, 0, 0, 0, 2022, 2023, 7, 26, 0, 0, 2023, 171, 
		    1, 0, 0, 0, 2024, 2025, 7, 27, 0, 0, 2025, 173, 1, 0, 0, 0, 2026, 
		    2027, 3, 220, 110, 0, 2027, 175, 1, 0, 0, 0, 2028, 2029, 3, 220, 110, 
		    0, 2029, 177, 1, 0, 0, 0, 2030, 2031, 3, 220, 110, 0, 2031, 179, 1, 
		    0, 0, 0, 2032, 2033, 3, 220, 110, 0, 2033, 181, 1, 0, 0, 0, 2034, 
		    2035, 3, 220, 110, 0, 2035, 183, 1, 0, 0, 0, 2036, 2037, 3, 220, 110, 
		    0, 2037, 185, 1, 0, 0, 0, 2038, 2039, 3, 220, 110, 0, 2039, 187, 1, 
		    0, 0, 0, 2040, 2041, 3, 220, 110, 0, 2041, 189, 1, 0, 0, 0, 2042, 
		    2043, 3, 220, 110, 0, 2043, 191, 1, 0, 0, 0, 2044, 2045, 3, 220, 110, 
		    0, 2045, 193, 1, 0, 0, 0, 2046, 2047, 3, 220, 110, 0, 2047, 195, 1, 
		    0, 0, 0, 2048, 2049, 3, 220, 110, 0, 2049, 197, 1, 0, 0, 0, 2050, 
		    2051, 3, 220, 110, 0, 2051, 199, 1, 0, 0, 0, 2052, 2053, 3, 220, 110, 
		    0, 2053, 201, 1, 0, 0, 0, 2054, 2055, 3, 220, 110, 0, 2055, 203, 1, 
		    0, 0, 0, 2056, 2057, 3, 220, 110, 0, 2057, 205, 1, 0, 0, 0, 2058, 
		    2059, 3, 220, 110, 0, 2059, 207, 1, 0, 0, 0, 2060, 2061, 3, 220, 110, 
		    0, 2061, 209, 1, 0, 0, 0, 2062, 2063, 3, 220, 110, 0, 2063, 211, 1, 
		    0, 0, 0, 2064, 2065, 3, 220, 110, 0, 2065, 213, 1, 0, 0, 0, 2066, 
		    2067, 3, 220, 110, 0, 2067, 215, 1, 0, 0, 0, 2068, 2069, 3, 220, 110, 
		    0, 2069, 217, 1, 0, 0, 0, 2070, 2071, 3, 220, 110, 0, 2071, 219, 1, 
		    0, 0, 0, 2072, 2080, 5, 185, 0, 0, 2073, 2080, 3, 172, 86, 0, 2074, 
		    2080, 5, 188, 0, 0, 2075, 2076, 5, 3, 0, 0, 2076, 2077, 3, 220, 110, 
		    0, 2077, 2078, 5, 4, 0, 0, 2078, 2080, 1, 0, 0, 0, 2079, 2072, 1, 
		    0, 0, 0, 2079, 2073, 1, 0, 0, 0, 2079, 2074, 1, 0, 0, 0, 2079, 2075, 
		    1, 0, 0, 0, 2080, 221, 1, 0, 0, 0, 298, 225, 233, 240, 245, 251, 257, 
		    259, 285, 292, 299, 305, 309, 314, 317, 324, 327, 331, 339, 343, 345, 
		    349, 353, 357, 360, 367, 373, 379, 384, 395, 401, 405, 409, 412, 416, 
		    422, 427, 436, 443, 449, 453, 457, 462, 468, 480, 484, 489, 492, 495, 
		    500, 503, 517, 524, 531, 533, 536, 542, 547, 555, 560, 575, 581, 591, 
		    596, 606, 610, 612, 616, 621, 623, 631, 637, 642, 649, 660, 663, 665, 
		    672, 676, 683, 689, 695, 701, 706, 715, 720, 731, 736, 747, 752, 756, 
		    772, 782, 787, 795, 807, 812, 820, 827, 830, 833, 840, 843, 846, 849, 
		    853, 861, 866, 876, 881, 890, 897, 901, 905, 908, 916, 929, 932, 940, 
		    949, 953, 958, 988, 1000, 1005, 1017, 1023, 1030, 1034, 1044, 1047, 
		    1053, 1059, 1068, 1071, 1075, 1077, 1079, 1088, 1095, 1102, 1108, 
		    1113, 1121, 1126, 1135, 1146, 1153, 1157, 1160, 1164, 1167, 1175, 
		    1186, 1192, 1194, 1202, 1209, 1216, 1221, 1223, 1229, 1238, 1243, 
		    1250, 1254, 1256, 1259, 1267, 1271, 1274, 1280, 1284, 1289, 1296, 
		    1305, 1309, 1311, 1315, 1324, 1329, 1331, 1344, 1347, 1356, 1367, 
		    1374, 1377, 1382, 1386, 1389, 1392, 1397, 1401, 1406, 1409, 1412, 
		    1417, 1421, 1424, 1431, 1436, 1445, 1450, 1453, 1461, 1465, 1473, 
		    1476, 1478, 1487, 1490, 1492, 1496, 1500, 1504, 1507, 1518, 1523, 
		    1527, 1531, 1534, 1539, 1545, 1552, 1559, 1568, 1572, 1574, 1578, 
		    1581, 1589, 1595, 1600, 1606, 1613, 1620, 1625, 1628, 1631, 1634, 
		    1639, 1644, 1651, 1655, 1659, 1669, 1678, 1681, 1690, 1694, 1702, 
		    1711, 1714, 1723, 1726, 1729, 1732, 1742, 1751, 1760, 1764, 1771, 
		    1778, 1782, 1786, 1795, 1799, 1803, 1808, 1812, 1819, 1829, 1836, 
		    1841, 1844, 1848, 1862, 1874, 1883, 1892, 1896, 1906, 1909, 1918, 
		    1927, 1930, 1936, 1950, 1954, 1965, 1970, 1983, 1990, 1998, 2003, 
		    2007, 2020, 2079];
		protected static $atn;
		protected static $decisionToDFA;
		protected static $sharedContextCache;

		public function __construct(TokenStream $input)
		{
			parent::__construct($input);

			self::initialize();

			$this->interp = new ParserATNSimulator($this, self::$atn, self::$decisionToDFA, self::$sharedContextCache);
		}

		private static function initialize(): void
		{
			if (self::$atn !== null) {
				return;
			}

			RuntimeMetaData::checkVersion('4.10', RuntimeMetaData::VERSION);

			$atn = (new ATNDeserializer())->deserialize(self::SERIALIZED_ATN);

			$decisionToDFA = [];
			for ($i = 0, $count = $atn->getNumberOfDecisions(); $i < $count; $i++) {
				$decisionToDFA[] = new DFA($atn->getDecisionState($i), $i);
			}

			self::$atn = $atn;
			self::$decisionToDFA = $decisionToDFA;
			self::$sharedContextCache = new PredictionContextCache();
		}

		public function getGrammarFileName(): string
		{
			return "SQLiteParser.g4";
		}

		public function getRuleNames(): array
		{
			return self::RULE_NAMES;
		}

		public function getSerializedATN(): array
		{
			return self::SERIALIZED_ATN;
		}

		public function getATN(): ATN
		{
			return self::$atn;
		}

		public function getVocabulary(): Vocabulary
        {
            static $vocabulary;

			return $vocabulary = $vocabulary ?? new VocabularyImpl(self::LITERAL_NAMES, self::SYMBOLIC_NAMES);
        }

		/**
		 * @throws RecognitionException
		 */
		public function parse(): Context\ParseContext
		{
		    $localContext = new Context\ParseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 0, self::RULE_parse);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(225);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ((($_la) & ~0x3f) === 0 && ((1 << $_la) & -6339801325483589630) !== 0 || ((($_la - 66)) & ~0x3f) === 0 && ((1 << ($_la - 66)) & -7971300971697405919) !== 0 || ((($_la - 130)) & ~0x3f) === 0 && ((1 << ($_la - 130)) & 550913) !== 0) {
		        	$this->setState(222);
		        	$this->sql_stmt_list();
		        	$this->setState(227);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(228);
		        $this->match(self::EOF);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function sql_stmt_list(): Context\Sql_stmt_listContext
		{
		    $localContext = new Context\Sql_stmt_listContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 2, self::RULE_sql_stmt_list);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(233);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::SCOL) {
		        	$this->setState(230);
		        	$this->match(self::SCOL);
		        	$this->setState(235);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(236);
		        $this->sql_stmt();
		        $this->setState(245);
		        $this->errorHandler->sync($this);

		        $alt = $this->getInterpreter()->adaptivePredict($this->input, 3, $this->ctx);

		        while ($alt !== 2 && $alt !== ATN::INVALID_ALT_NUMBER) {
		        	if ($alt === 1) {
		        		$this->setState(238); 
		        		$this->errorHandler->sync($this);

		        		$_la = $this->input->LA(1);
		        		do {
		        			$this->setState(237);
		        			$this->match(self::SCOL);
		        			$this->setState(240); 
		        			$this->errorHandler->sync($this);
		        			$_la = $this->input->LA(1);
		        		} while ($_la === self::SCOL);
		        		$this->setState(242);
		        		$this->sql_stmt(); 
		        	}

		        	$this->setState(247);
		        	$this->errorHandler->sync($this);

		        	$alt = $this->getInterpreter()->adaptivePredict($this->input, 3, $this->ctx);
		        }
		        $this->setState(251);
		        $this->errorHandler->sync($this);

		        $alt = $this->getInterpreter()->adaptivePredict($this->input, 4, $this->ctx);

		        while ($alt !== 2 && $alt !== ATN::INVALID_ALT_NUMBER) {
		        	if ($alt === 1) {
		        		$this->setState(248);
		        		$this->match(self::SCOL); 
		        	}

		        	$this->setState(253);
		        	$this->errorHandler->sync($this);

		        	$alt = $this->getInterpreter()->adaptivePredict($this->input, 4, $this->ctx);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function sql_stmt(): Context\Sql_stmtContext
		{
		    $localContext = new Context\Sql_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 4, self::RULE_sql_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(259);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::EXPLAIN_) {
		        	$this->setState(254);
		        	$this->match(self::EXPLAIN_);
		        	$this->setState(257);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);

		        	if ($_la === self::QUERY_) {
		        		$this->setState(255);
		        		$this->match(self::QUERY_);
		        		$this->setState(256);
		        		$this->match(self::PLAN_);
		        	}
		        }
		        $this->setState(285);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 7, $this->ctx)) {
		        	case 1:
		        	    $this->setState(261);
		        	    $this->alter_table_stmt();
		        	break;

		        	case 2:
		        	    $this->setState(262);
		        	    $this->analyze_stmt();
		        	break;

		        	case 3:
		        	    $this->setState(263);
		        	    $this->attach_stmt();
		        	break;

		        	case 4:
		        	    $this->setState(264);
		        	    $this->begin_stmt();
		        	break;

		        	case 5:
		        	    $this->setState(265);
		        	    $this->commit_stmt();
		        	break;

		        	case 6:
		        	    $this->setState(266);
		        	    $this->create_index_stmt();
		        	break;

		        	case 7:
		        	    $this->setState(267);
		        	    $this->create_table_stmt();
		        	break;

		        	case 8:
		        	    $this->setState(268);
		        	    $this->create_trigger_stmt();
		        	break;

		        	case 9:
		        	    $this->setState(269);
		        	    $this->create_view_stmt();
		        	break;

		        	case 10:
		        	    $this->setState(270);
		        	    $this->create_virtual_table_stmt();
		        	break;

		        	case 11:
		        	    $this->setState(271);
		        	    $this->delete_stmt();
		        	break;

		        	case 12:
		        	    $this->setState(272);
		        	    $this->delete_stmt_limited();
		        	break;

		        	case 13:
		        	    $this->setState(273);
		        	    $this->detach_stmt();
		        	break;

		        	case 14:
		        	    $this->setState(274);
		        	    $this->drop_stmt();
		        	break;

		        	case 15:
		        	    $this->setState(275);
		        	    $this->insert_stmt();
		        	break;

		        	case 16:
		        	    $this->setState(276);
		        	    $this->pragma_stmt();
		        	break;

		        	case 17:
		        	    $this->setState(277);
		        	    $this->reindex_stmt();
		        	break;

		        	case 18:
		        	    $this->setState(278);
		        	    $this->release_stmt();
		        	break;

		        	case 19:
		        	    $this->setState(279);
		        	    $this->rollback_stmt();
		        	break;

		        	case 20:
		        	    $this->setState(280);
		        	    $this->savepoint_stmt();
		        	break;

		        	case 21:
		        	    $this->setState(281);
		        	    $this->select_stmt();
		        	break;

		        	case 22:
		        	    $this->setState(282);
		        	    $this->update_stmt();
		        	break;

		        	case 23:
		        	    $this->setState(283);
		        	    $this->update_stmt_limited();
		        	break;

		        	case 24:
		        	    $this->setState(284);
		        	    $this->vacuum_stmt();
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function alter_table_stmt(): Context\Alter_table_stmtContext
		{
		    $localContext = new Context\Alter_table_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 6, self::RULE_alter_table_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(287);
		        $this->match(self::ALTER_);
		        $this->setState(288);
		        $this->match(self::TABLE_);
		        $this->setState(292);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 8, $this->ctx)) {
		            case 1:
		        	    $this->setState(289);
		        	    $this->schema_name();
		        	    $this->setState(290);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(294);
		        $this->table_name();
		        $this->setState(317);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::RENAME_:
		            	$this->setState(295);
		            	$this->match(self::RENAME_);
		            	$this->setState(305);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 10, $this->ctx)) {
		            		case 1:
		            		    $this->setState(296);
		            		    $this->match(self::TO_);
		            		    $this->setState(297);
		            		    $localContext->new_table_name = $this->table_name();
		            		break;

		            		case 2:
		            		    $this->setState(299);
		            		    $this->errorHandler->sync($this);

		            		    switch ($this->getInterpreter()->adaptivePredict($this->input, 9, $this->ctx)) {
		            		        case 1:
		            		    	    $this->setState(298);
		            		    	    $this->match(self::COLUMN_);
		            		    	break;
		            		    }
		            		    $this->setState(301);
		            		    $localContext->old_column_name = $this->column_name();
		            		    $this->setState(302);
		            		    $this->match(self::TO_);
		            		    $this->setState(303);
		            		    $localContext->new_column_name = $this->column_name();
		            		break;
		            	}
		            	break;

		            case self::ADD_:
		            	$this->setState(307);
		            	$this->match(self::ADD_);
		            	$this->setState(309);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 11, $this->ctx)) {
		            	    case 1:
		            		    $this->setState(308);
		            		    $this->match(self::COLUMN_);
		            		break;
		            	}
		            	$this->setState(311);
		            	$this->column_def();
		            	break;

		            case self::DROP_:
		            	$this->setState(312);
		            	$this->match(self::DROP_);
		            	$this->setState(314);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 12, $this->ctx)) {
		            	    case 1:
		            		    $this->setState(313);
		            		    $this->match(self::COLUMN_);
		            		break;
		            	}
		            	$this->setState(316);
		            	$this->column_name();
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function analyze_stmt(): Context\Analyze_stmtContext
		{
		    $localContext = new Context\Analyze_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 8, self::RULE_analyze_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(319);
		        $this->match(self::ANALYZE_);
		        $this->setState(327);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 15, $this->ctx)) {
		            case 1:
		        	    $this->setState(320);
		        	    $this->schema_name();
		        	break;

		            case 2:
		        	    $this->setState(324);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 14, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(321);
		        	    	    $this->schema_name();
		        	    	    $this->setState(322);
		        	    	    $this->match(self::DOT);
		        	    	break;
		        	    }
		        	    $this->setState(326);
		        	    $this->table_or_index_name();
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function attach_stmt(): Context\Attach_stmtContext
		{
		    $localContext = new Context\Attach_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 10, self::RULE_attach_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(329);
		        $this->match(self::ATTACH_);
		        $this->setState(331);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 16, $this->ctx)) {
		            case 1:
		        	    $this->setState(330);
		        	    $this->match(self::DATABASE_);
		        	break;
		        }
		        $this->setState(333);
		        $this->recursiveExpr(0);
		        $this->setState(334);
		        $this->match(self::AS_);
		        $this->setState(335);
		        $this->schema_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function begin_stmt(): Context\Begin_stmtContext
		{
		    $localContext = new Context\Begin_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 12, self::RULE_begin_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(337);
		        $this->match(self::BEGIN_);
		        $this->setState(339);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if (((($_la - 58)) & ~0x3f) === 0 && ((1 << ($_la - 58)) & 16779265) !== 0) {
		        	$this->setState(338);

		        	$_la = $this->input->LA(1);

		        	if (!(((($_la - 58)) & ~0x3f) === 0 && ((1 << ($_la - 58)) & 16779265) !== 0)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        }
		        $this->setState(345);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TRANSACTION_) {
		        	$this->setState(341);
		        	$this->match(self::TRANSACTION_);
		        	$this->setState(343);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 18, $this->ctx)) {
		        	    case 1:
		        		    $this->setState(342);
		        		    $this->transaction_name();
		        		break;
		        	}
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function commit_stmt(): Context\Commit_stmtContext
		{
		    $localContext = new Context\Commit_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 14, self::RULE_commit_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(347);

		        $_la = $this->input->LA(1);

		        if (!($_la === self::COMMIT_ || $_la === self::END_)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		        $this->setState(349);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TRANSACTION_) {
		        	$this->setState(348);
		        	$this->match(self::TRANSACTION_);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function rollback_stmt(): Context\Rollback_stmtContext
		{
		    $localContext = new Context\Rollback_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 16, self::RULE_rollback_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(351);
		        $this->match(self::ROLLBACK_);
		        $this->setState(353);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TRANSACTION_) {
		        	$this->setState(352);
		        	$this->match(self::TRANSACTION_);
		        }
		        $this->setState(360);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TO_) {
		        	$this->setState(355);
		        	$this->match(self::TO_);
		        	$this->setState(357);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 22, $this->ctx)) {
		        	    case 1:
		        		    $this->setState(356);
		        		    $this->match(self::SAVEPOINT_);
		        		break;
		        	}
		        	$this->setState(359);
		        	$this->savepoint_name();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function savepoint_stmt(): Context\Savepoint_stmtContext
		{
		    $localContext = new Context\Savepoint_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 18, self::RULE_savepoint_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(362);
		        $this->match(self::SAVEPOINT_);
		        $this->setState(363);
		        $this->savepoint_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function release_stmt(): Context\Release_stmtContext
		{
		    $localContext = new Context\Release_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 20, self::RULE_release_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(365);
		        $this->match(self::RELEASE_);
		        $this->setState(367);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 24, $this->ctx)) {
		            case 1:
		        	    $this->setState(366);
		        	    $this->match(self::SAVEPOINT_);
		        	break;
		        }
		        $this->setState(369);
		        $this->savepoint_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function create_index_stmt(): Context\Create_index_stmtContext
		{
		    $localContext = new Context\Create_index_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 22, self::RULE_create_index_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(371);
		        $this->match(self::CREATE_);
		        $this->setState(373);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::UNIQUE_) {
		        	$this->setState(372);
		        	$this->match(self::UNIQUE_);
		        }
		        $this->setState(375);
		        $this->match(self::INDEX_);
		        $this->setState(379);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 26, $this->ctx)) {
		            case 1:
		        	    $this->setState(376);
		        	    $this->match(self::IF_);
		        	    $this->setState(377);
		        	    $this->match(self::NOT_);
		        	    $this->setState(378);
		        	    $this->match(self::EXISTS_);
		        	break;
		        }
		        $this->setState(384);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 27, $this->ctx)) {
		            case 1:
		        	    $this->setState(381);
		        	    $this->schema_name();
		        	    $this->setState(382);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(386);
		        $this->index_name();
		        $this->setState(387);
		        $this->match(self::ON_);
		        $this->setState(388);
		        $this->table_name();
		        $this->setState(389);
		        $this->match(self::OPEN_PAR);
		        $this->setState(390);
		        $this->indexed_column();
		        $this->setState(395);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(391);
		        	$this->match(self::COMMA);
		        	$this->setState(392);
		        	$this->indexed_column();
		        	$this->setState(397);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(398);
		        $this->match(self::CLOSE_PAR);
		        $this->setState(401);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WHERE_) {
		        	$this->setState(399);
		        	$this->match(self::WHERE_);
		        	$this->setState(400);
		        	$this->recursiveExpr(0);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function indexed_column(): Context\Indexed_columnContext
		{
		    $localContext = new Context\Indexed_columnContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 24, self::RULE_indexed_column);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(405);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 30, $this->ctx)) {
		        	case 1:
		        	    $this->setState(403);
		        	    $this->column_name();
		        	break;

		        	case 2:
		        	    $this->setState(404);
		        	    $this->recursiveExpr(0);
		        	break;
		        }
		        $this->setState(409);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::COLLATE_) {
		        	$this->setState(407);
		        	$this->match(self::COLLATE_);
		        	$this->setState(408);
		        	$this->collation_name();
		        }
		        $this->setState(412);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ASC_ || $_la === self::DESC_) {
		        	$this->setState(411);
		        	$this->asc_desc();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function create_table_stmt(): Context\Create_table_stmtContext
		{
		    $localContext = new Context\Create_table_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 26, self::RULE_create_table_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(414);
		        $this->match(self::CREATE_);
		        $this->setState(416);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TEMP_ || $_la === self::TEMPORARY_) {
		        	$this->setState(415);

		        	$_la = $this->input->LA(1);

		        	if (!($_la === self::TEMP_ || $_la === self::TEMPORARY_)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        }
		        $this->setState(418);
		        $this->match(self::TABLE_);
		        $this->setState(422);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 34, $this->ctx)) {
		            case 1:
		        	    $this->setState(419);
		        	    $this->match(self::IF_);
		        	    $this->setState(420);
		        	    $this->match(self::NOT_);
		        	    $this->setState(421);
		        	    $this->match(self::EXISTS_);
		        	break;
		        }
		        $this->setState(427);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 35, $this->ctx)) {
		            case 1:
		        	    $this->setState(424);
		        	    $this->schema_name();
		        	    $this->setState(425);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(429);
		        $this->table_name();
		        $this->setState(453);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::OPEN_PAR:
		            	$this->setState(430);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(431);
		            	$this->column_def();
		            	$this->setState(436);
		            	$this->errorHandler->sync($this);

		            	$alt = $this->getInterpreter()->adaptivePredict($this->input, 36, $this->ctx);

		            	while ($alt !== 1 && $alt !== ATN::INVALID_ALT_NUMBER) {
		            		if ($alt === 1+1) {
		            			$this->setState(432);
		            			$this->match(self::COMMA);
		            			$this->setState(433);
		            			$this->column_def(); 
		            		}

		            		$this->setState(438);
		            		$this->errorHandler->sync($this);

		            		$alt = $this->getInterpreter()->adaptivePredict($this->input, 36, $this->ctx);
		            	}
		            	$this->setState(443);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(439);
		            		$this->match(self::COMMA);
		            		$this->setState(440);
		            		$this->table_constraint();
		            		$this->setState(445);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(446);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(449);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::WITHOUT_) {
		            		$this->setState(447);
		            		$this->match(self::WITHOUT_);
		            		$this->setState(448);
		            		$localContext->row_ROW_ID = $this->match(self::IDENTIFIER);
		            	}
		            	break;

		            case self::AS_:
		            	$this->setState(451);
		            	$this->match(self::AS_);
		            	$this->setState(452);
		            	$this->select_stmt();
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function column_def(): Context\Column_defContext
		{
		    $localContext = new Context\Column_defContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 28, self::RULE_column_def);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(455);
		        $this->column_name();
		        $this->setState(457);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 40, $this->ctx)) {
		            case 1:
		        	    $this->setState(456);
		        	    $this->type_name();
		        	break;
		        }
		        $this->setState(462);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ((($_la) & ~0x3f) === 0 && ((1 << $_la) & 72673329139417088) !== 0 || ((($_la - 102)) & ~0x3f) === 0 && ((1 << ($_la - 102)) & 274877941761) !== 0 || $_la === self::GENERATED_) {
		        	$this->setState(459);
		        	$this->column_constraint();
		        	$this->setState(464);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function type_name(): Context\Type_nameContext
		{
		    $localContext = new Context\Type_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 30, self::RULE_type_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(466); 
		        $this->errorHandler->sync($this);

		        $alt = 1+1;

		        do {
		        	switch ($alt) {
		        	case 1+1:
		        		$this->setState(465);
		        		$this->name();
		        		break;
		        	default:
		        		throw new NoViableAltException($this);
		        	}

		        	$this->setState(468); 
		        	$this->errorHandler->sync($this);

		        	$alt = $this->getInterpreter()->adaptivePredict($this->input, 42, $this->ctx);
		        } while ($alt !== 1 && $alt !== ATN::INVALID_ALT_NUMBER);
		        $this->setState(480);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 43, $this->ctx)) {
		            case 1:
		        	    $this->setState(470);
		        	    $this->match(self::OPEN_PAR);
		        	    $this->setState(471);
		        	    $this->signed_number();
		        	    $this->setState(472);
		        	    $this->match(self::CLOSE_PAR);
		        	break;

		            case 2:
		        	    $this->setState(474);
		        	    $this->match(self::OPEN_PAR);
		        	    $this->setState(475);
		        	    $this->signed_number();
		        	    $this->setState(476);
		        	    $this->match(self::COMMA);
		        	    $this->setState(477);
		        	    $this->signed_number();
		        	    $this->setState(478);
		        	    $this->match(self::CLOSE_PAR);
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function column_constraint(): Context\Column_constraintContext
		{
		    $localContext = new Context\Column_constraintContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 32, self::RULE_column_constraint);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(484);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::CONSTRAINT_) {
		        	$this->setState(482);
		        	$this->match(self::CONSTRAINT_);
		        	$this->setState(483);
		        	$this->name();
		        }
		        $this->setState(533);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::PRIMARY_:
		            	$this->setState(486);
		            	$this->match(self::PRIMARY_);
		            	$this->setState(487);
		            	$this->match(self::KEY_);
		            	$this->setState(489);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ASC_ || $_la === self::DESC_) {
		            		$this->setState(488);
		            		$this->asc_desc();
		            	}
		            	$this->setState(492);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ON_) {
		            		$this->setState(491);
		            		$this->conflict_clause();
		            	}
		            	$this->setState(495);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::AUTOINCREMENT_) {
		            		$this->setState(494);
		            		$this->match(self::AUTOINCREMENT_);
		            	}
		            	break;

		            case self::NOT_:
		            case self::UNIQUE_:
		            	$this->setState(500);
		            	$this->errorHandler->sync($this);

		            	switch ($this->input->LA(1)) {
		            	    case self::NOT_:
		            	    	$this->setState(497);
		            	    	$this->match(self::NOT_);
		            	    	$this->setState(498);
		            	    	$this->match(self::NULL_);
		            	    	break;

		            	    case self::UNIQUE_:
		            	    	$this->setState(499);
		            	    	$this->match(self::UNIQUE_);
		            	    	break;

		            	default:
		            		throw new NoViableAltException($this);
		            	}
		            	$this->setState(503);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ON_) {
		            		$this->setState(502);
		            		$this->conflict_clause();
		            	}
		            	break;

		            case self::CHECK_:
		            	$this->setState(505);
		            	$this->match(self::CHECK_);
		            	$this->setState(506);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(507);
		            	$this->recursiveExpr(0);
		            	$this->setState(508);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::DEFAULT_:
		            	$this->setState(510);
		            	$this->match(self::DEFAULT_);
		            	$this->setState(517);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 50, $this->ctx)) {
		            		case 1:
		            		    $this->setState(511);
		            		    $this->signed_number();
		            		break;

		            		case 2:
		            		    $this->setState(512);
		            		    $this->literal_value();
		            		break;

		            		case 3:
		            		    $this->setState(513);
		            		    $this->match(self::OPEN_PAR);
		            		    $this->setState(514);
		            		    $this->recursiveExpr(0);
		            		    $this->setState(515);
		            		    $this->match(self::CLOSE_PAR);
		            		break;
		            	}
		            	break;

		            case self::COLLATE_:
		            	$this->setState(519);
		            	$this->match(self::COLLATE_);
		            	$this->setState(520);
		            	$this->collation_name();
		            	break;

		            case self::REFERENCES_:
		            	$this->setState(521);
		            	$this->foreign_key_clause();
		            	break;

		            case self::AS_:
		            case self::GENERATED_:
		            	$this->setState(524);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::GENERATED_) {
		            		$this->setState(522);
		            		$this->match(self::GENERATED_);
		            		$this->setState(523);
		            		$this->match(self::ALWAYS_);
		            	}
		            	$this->setState(526);
		            	$this->match(self::AS_);
		            	$this->setState(527);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(528);
		            	$this->recursiveExpr(0);
		            	$this->setState(529);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(531);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::VIRTUAL_ || $_la === self::STORED_) {
		            		$this->setState(530);

		            		$_la = $this->input->LA(1);

		            		if (!($_la === self::VIRTUAL_ || $_la === self::STORED_)) {
		            		$this->errorHandler->recoverInline($this);
		            		} else {
		            			if ($this->input->LA(1) === Token::EOF) {
		            			    $this->matchedEOF = true;
		            		    }

		            			$this->errorHandler->reportMatch($this);
		            			$this->consume();
		            		}
		            	}
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function signed_number(): Context\Signed_numberContext
		{
		    $localContext = new Context\Signed_numberContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 34, self::RULE_signed_number);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(536);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::PLUS || $_la === self::MINUS) {
		        	$this->setState(535);

		        	$_la = $this->input->LA(1);

		        	if (!($_la === self::PLUS || $_la === self::MINUS)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        }
		        $this->setState(538);
		        $this->match(self::NUMERIC_LITERAL);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function table_constraint(): Context\Table_constraintContext
		{
		    $localContext = new Context\Table_constraintContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 36, self::RULE_table_constraint);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(542);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::CONSTRAINT_) {
		        	$this->setState(540);
		        	$this->match(self::CONSTRAINT_);
		        	$this->setState(541);
		        	$this->name();
		        }
		        $this->setState(581);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::PRIMARY_:
		            case self::UNIQUE_:
		            	$this->setState(547);
		            	$this->errorHandler->sync($this);

		            	switch ($this->input->LA(1)) {
		            	    case self::PRIMARY_:
		            	    	$this->setState(544);
		            	    	$this->match(self::PRIMARY_);
		            	    	$this->setState(545);
		            	    	$this->match(self::KEY_);
		            	    	break;

		            	    case self::UNIQUE_:
		            	    	$this->setState(546);
		            	    	$this->match(self::UNIQUE_);
		            	    	break;

		            	default:
		            		throw new NoViableAltException($this);
		            	}
		            	$this->setState(549);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(550);
		            	$this->indexed_column();
		            	$this->setState(555);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(551);
		            		$this->match(self::COMMA);
		            		$this->setState(552);
		            		$this->indexed_column();
		            		$this->setState(557);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(558);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(560);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ON_) {
		            		$this->setState(559);
		            		$this->conflict_clause();
		            	}
		            	break;

		            case self::CHECK_:
		            	$this->setState(562);
		            	$this->match(self::CHECK_);
		            	$this->setState(563);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(564);
		            	$this->recursiveExpr(0);
		            	$this->setState(565);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::FOREIGN_:
		            	$this->setState(567);
		            	$this->match(self::FOREIGN_);
		            	$this->setState(568);
		            	$this->match(self::KEY_);
		            	$this->setState(569);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(570);
		            	$this->column_name();
		            	$this->setState(575);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(571);
		            		$this->match(self::COMMA);
		            		$this->setState(572);
		            		$this->column_name();
		            		$this->setState(577);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(578);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(579);
		            	$this->foreign_key_clause();
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function foreign_key_clause(): Context\Foreign_key_clauseContext
		{
		    $localContext = new Context\Foreign_key_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 38, self::RULE_foreign_key_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(583);
		        $this->match(self::REFERENCES_);
		        $this->setState(584);
		        $this->foreign_table();
		        $this->setState(596);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(585);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(586);
		        	$this->column_name();
		        	$this->setState(591);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(587);
		        		$this->match(self::COMMA);
		        		$this->setState(588);
		        		$this->column_name();
		        		$this->setState(593);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(594);
		        	$this->match(self::CLOSE_PAR);
		        }
		        $this->setState(612);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::MATCH_ || $_la === self::ON_) {
		        	$this->setState(610);
		        	$this->errorHandler->sync($this);

		        	switch ($this->input->LA(1)) {
		        	    case self::ON_:
		        	    	$this->setState(598);
		        	    	$this->match(self::ON_);
		        	    	$this->setState(599);

		        	    	$_la = $this->input->LA(1);

		        	    	if (!($_la === self::DELETE_ || $_la === self::UPDATE_)) {
		        	    	$this->errorHandler->recoverInline($this);
		        	    	} else {
		        	    		if ($this->input->LA(1) === Token::EOF) {
		        	    		    $this->matchedEOF = true;
		        	    	    }

		        	    		$this->errorHandler->reportMatch($this);
		        	    		$this->consume();
		        	    	}
		        	    	$this->setState(606);
		        	    	$this->errorHandler->sync($this);

		        	    	switch ($this->input->LA(1)) {
		        	    	    case self::SET_:
		        	    	    	$this->setState(600);
		        	    	    	$this->match(self::SET_);
		        	    	    	$this->setState(601);

		        	    	    	$_la = $this->input->LA(1);

		        	    	    	if (!($_la === self::DEFAULT_ || $_la === self::NULL_)) {
		        	    	    	$this->errorHandler->recoverInline($this);
		        	    	    	} else {
		        	    	    		if ($this->input->LA(1) === Token::EOF) {
		        	    	    		    $this->matchedEOF = true;
		        	    	    	    }

		        	    	    		$this->errorHandler->reportMatch($this);
		        	    	    		$this->consume();
		        	    	    	}
		        	    	    	break;

		        	    	    case self::CASCADE_:
		        	    	    	$this->setState(602);
		        	    	    	$this->match(self::CASCADE_);
		        	    	    	break;

		        	    	    case self::RESTRICT_:
		        	    	    	$this->setState(603);
		        	    	    	$this->match(self::RESTRICT_);
		        	    	    	break;

		        	    	    case self::NO_:
		        	    	    	$this->setState(604);
		        	    	    	$this->match(self::NO_);
		        	    	    	$this->setState(605);
		        	    	    	$this->match(self::ACTION_);
		        	    	    	break;

		        	    	default:
		        	    		throw new NoViableAltException($this);
		        	    	}
		        	    	break;

		        	    case self::MATCH_:
		        	    	$this->setState(608);
		        	    	$this->match(self::MATCH_);
		        	    	$this->setState(609);
		        	    	$this->name();
		        	    	break;

		        	default:
		        		throw new NoViableAltException($this);
		        	}
		        	$this->setState(614);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(623);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 68, $this->ctx)) {
		            case 1:
		        	    $this->setState(616);
		        	    $this->errorHandler->sync($this);
		        	    $_la = $this->input->LA(1);

		        	    if ($_la === self::NOT_) {
		        	    	$this->setState(615);
		        	    	$this->match(self::NOT_);
		        	    }
		        	    $this->setState(618);
		        	    $this->match(self::DEFERRABLE_);
		        	    $this->setState(621);
		        	    $this->errorHandler->sync($this);
		        	    $_la = $this->input->LA(1);

		        	    if ($_la === self::INITIALLY_) {
		        	    	$this->setState(619);
		        	    	$this->match(self::INITIALLY_);
		        	    	$this->setState(620);

		        	    	$_la = $this->input->LA(1);

		        	    	if (!($_la === self::DEFERRED_ || $_la === self::IMMEDIATE_)) {
		        	    	$this->errorHandler->recoverInline($this);
		        	    	} else {
		        	    		if ($this->input->LA(1) === Token::EOF) {
		        	    		    $this->matchedEOF = true;
		        	    	    }

		        	    		$this->errorHandler->reportMatch($this);
		        	    		$this->consume();
		        	    	}
		        	    }
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function conflict_clause(): Context\Conflict_clauseContext
		{
		    $localContext = new Context\Conflict_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 40, self::RULE_conflict_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(625);
		        $this->match(self::ON_);
		        $this->setState(626);
		        $this->match(self::CONFLICT_);
		        $this->setState(627);

		        $_la = $this->input->LA(1);

		        if (!($_la === self::ABORT_ || ((($_la - 72)) & ~0x3f) === 0 && ((1 << ($_la - 72)) & 19140298416325121) !== 0)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function create_trigger_stmt(): Context\Create_trigger_stmtContext
		{
		    $localContext = new Context\Create_trigger_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 42, self::RULE_create_trigger_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(629);
		        $this->match(self::CREATE_);
		        $this->setState(631);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TEMP_ || $_la === self::TEMPORARY_) {
		        	$this->setState(630);

		        	$_la = $this->input->LA(1);

		        	if (!($_la === self::TEMP_ || $_la === self::TEMPORARY_)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        }
		        $this->setState(633);
		        $this->match(self::TRIGGER_);
		        $this->setState(637);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 70, $this->ctx)) {
		            case 1:
		        	    $this->setState(634);
		        	    $this->match(self::IF_);
		        	    $this->setState(635);
		        	    $this->match(self::NOT_);
		        	    $this->setState(636);
		        	    $this->match(self::EXISTS_);
		        	break;
		        }
		        $this->setState(642);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 71, $this->ctx)) {
		            case 1:
		        	    $this->setState(639);
		        	    $this->schema_name();
		        	    $this->setState(640);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(644);
		        $this->trigger_name();
		        $this->setState(649);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::BEFORE_:
		            	$this->setState(645);
		            	$this->match(self::BEFORE_);
		            	break;

		            case self::AFTER_:
		            	$this->setState(646);
		            	$this->match(self::AFTER_);
		            	break;

		            case self::INSTEAD_:
		            	$this->setState(647);
		            	$this->match(self::INSTEAD_);
		            	$this->setState(648);
		            	$this->match(self::OF_);
		            	break;

		            case self::DELETE_:
		            case self::INSERT_:
		            case self::UPDATE_:
		            	break;

		        default:
		        	break;
		        }
		        $this->setState(665);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::DELETE_:
		            	$this->setState(651);
		            	$this->match(self::DELETE_);
		            	break;

		            case self::INSERT_:
		            	$this->setState(652);
		            	$this->match(self::INSERT_);
		            	break;

		            case self::UPDATE_:
		            	$this->setState(653);
		            	$this->match(self::UPDATE_);
		            	$this->setState(663);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::OF_) {
		            		$this->setState(654);
		            		$this->match(self::OF_);
		            		$this->setState(655);
		            		$this->column_name();
		            		$this->setState(660);
		            		$this->errorHandler->sync($this);

		            		$_la = $this->input->LA(1);
		            		while ($_la === self::COMMA) {
		            			$this->setState(656);
		            			$this->match(self::COMMA);
		            			$this->setState(657);
		            			$this->column_name();
		            			$this->setState(662);
		            			$this->errorHandler->sync($this);
		            			$_la = $this->input->LA(1);
		            		}
		            	}
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		        $this->setState(667);
		        $this->match(self::ON_);
		        $this->setState(668);
		        $this->table_name();
		        $this->setState(672);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::FOR_) {
		        	$this->setState(669);
		        	$this->match(self::FOR_);
		        	$this->setState(670);
		        	$this->match(self::EACH_);
		        	$this->setState(671);
		        	$this->match(self::ROW_);
		        }
		        $this->setState(676);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WHEN_) {
		        	$this->setState(674);
		        	$this->match(self::WHEN_);
		        	$this->setState(675);
		        	$this->recursiveExpr(0);
		        }
		        $this->setState(678);
		        $this->match(self::BEGIN_);
		        $this->setState(687); 
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        do {
		        	$this->setState(683);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 78, $this->ctx)) {
		        		case 1:
		        		    $this->setState(679);
		        		    $this->update_stmt();
		        		break;

		        		case 2:
		        		    $this->setState(680);
		        		    $this->insert_stmt();
		        		break;

		        		case 3:
		        		    $this->setState(681);
		        		    $this->delete_stmt();
		        		break;

		        		case 4:
		        		    $this->setState(682);
		        		    $this->select_stmt();
		        		break;
		        	}
		        	$this->setState(685);
		        	$this->match(self::SCOL);
		        	$this->setState(689); 
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        } while ($_la === self::DELETE_ || ((($_la - 88)) & ~0x3f) === 0 && ((1 << ($_la - 88)) & 2386912217732743169) !== 0);
		        $this->setState(691);
		        $this->match(self::END_);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function create_view_stmt(): Context\Create_view_stmtContext
		{
		    $localContext = new Context\Create_view_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 44, self::RULE_create_view_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(693);
		        $this->match(self::CREATE_);
		        $this->setState(695);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::TEMP_ || $_la === self::TEMPORARY_) {
		        	$this->setState(694);

		        	$_la = $this->input->LA(1);

		        	if (!($_la === self::TEMP_ || $_la === self::TEMPORARY_)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        }
		        $this->setState(697);
		        $this->match(self::VIEW_);
		        $this->setState(701);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 81, $this->ctx)) {
		            case 1:
		        	    $this->setState(698);
		        	    $this->match(self::IF_);
		        	    $this->setState(699);
		        	    $this->match(self::NOT_);
		        	    $this->setState(700);
		        	    $this->match(self::EXISTS_);
		        	break;
		        }
		        $this->setState(706);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 82, $this->ctx)) {
		            case 1:
		        	    $this->setState(703);
		        	    $this->schema_name();
		        	    $this->setState(704);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(708);
		        $this->view_name();
		        $this->setState(720);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(709);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(710);
		        	$this->column_name();
		        	$this->setState(715);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(711);
		        		$this->match(self::COMMA);
		        		$this->setState(712);
		        		$this->column_name();
		        		$this->setState(717);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(718);
		        	$this->match(self::CLOSE_PAR);
		        }
		        $this->setState(722);
		        $this->match(self::AS_);
		        $this->setState(723);
		        $this->select_stmt();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function create_virtual_table_stmt(): Context\Create_virtual_table_stmtContext
		{
		    $localContext = new Context\Create_virtual_table_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 46, self::RULE_create_virtual_table_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(725);
		        $this->match(self::CREATE_);
		        $this->setState(726);
		        $this->match(self::VIRTUAL_);
		        $this->setState(727);
		        $this->match(self::TABLE_);
		        $this->setState(731);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 85, $this->ctx)) {
		            case 1:
		        	    $this->setState(728);
		        	    $this->match(self::IF_);
		        	    $this->setState(729);
		        	    $this->match(self::NOT_);
		        	    $this->setState(730);
		        	    $this->match(self::EXISTS_);
		        	break;
		        }
		        $this->setState(736);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 86, $this->ctx)) {
		            case 1:
		        	    $this->setState(733);
		        	    $this->schema_name();
		        	    $this->setState(734);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(738);
		        $this->table_name();
		        $this->setState(739);
		        $this->match(self::USING_);
		        $this->setState(740);
		        $this->module_name();
		        $this->setState(752);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(741);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(742);
		        	$this->module_argument();
		        	$this->setState(747);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(743);
		        		$this->match(self::COMMA);
		        		$this->setState(744);
		        		$this->module_argument();
		        		$this->setState(749);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(750);
		        	$this->match(self::CLOSE_PAR);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function with_clause(): Context\With_clauseContext
		{
		    $localContext = new Context\With_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 48, self::RULE_with_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(754);
		        $this->match(self::WITH_);
		        $this->setState(756);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 89, $this->ctx)) {
		            case 1:
		        	    $this->setState(755);
		        	    $this->match(self::RECURSIVE_);
		        	break;
		        }
		        $this->setState(758);
		        $this->cte_table_name();
		        $this->setState(759);
		        $this->match(self::AS_);
		        $this->setState(760);
		        $this->match(self::OPEN_PAR);
		        $this->setState(761);
		        $this->select_stmt();
		        $this->setState(762);
		        $this->match(self::CLOSE_PAR);
		        $this->setState(772);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(763);
		        	$this->match(self::COMMA);
		        	$this->setState(764);
		        	$this->cte_table_name();
		        	$this->setState(765);
		        	$this->match(self::AS_);
		        	$this->setState(766);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(767);
		        	$this->select_stmt();
		        	$this->setState(768);
		        	$this->match(self::CLOSE_PAR);
		        	$this->setState(774);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function cte_table_name(): Context\Cte_table_nameContext
		{
		    $localContext = new Context\Cte_table_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 50, self::RULE_cte_table_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(775);
		        $this->table_name();
		        $this->setState(787);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(776);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(777);
		        	$this->column_name();
		        	$this->setState(782);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(778);
		        		$this->match(self::COMMA);
		        		$this->setState(779);
		        		$this->column_name();
		        		$this->setState(784);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(785);
		        	$this->match(self::CLOSE_PAR);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function recursive_cte(): Context\Recursive_cteContext
		{
		    $localContext = new Context\Recursive_cteContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 52, self::RULE_recursive_cte);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(789);
		        $this->cte_table_name();
		        $this->setState(790);
		        $this->match(self::AS_);
		        $this->setState(791);
		        $this->match(self::OPEN_PAR);
		        $this->setState(792);
		        $this->initial_select();
		        $this->setState(793);
		        $this->match(self::UNION_);
		        $this->setState(795);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ALL_) {
		        	$this->setState(794);
		        	$this->match(self::ALL_);
		        }
		        $this->setState(797);
		        $this->recursive_select();
		        $this->setState(798);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function common_table_expression(): Context\Common_table_expressionContext
		{
		    $localContext = new Context\Common_table_expressionContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 54, self::RULE_common_table_expression);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(800);
		        $this->table_name();
		        $this->setState(812);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(801);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(802);
		        	$this->column_name();
		        	$this->setState(807);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(803);
		        		$this->match(self::COMMA);
		        		$this->setState(804);
		        		$this->column_name();
		        		$this->setState(809);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(810);
		        	$this->match(self::CLOSE_PAR);
		        }
		        $this->setState(814);
		        $this->match(self::AS_);
		        $this->setState(815);
		        $this->match(self::OPEN_PAR);
		        $this->setState(816);
		        $this->select_stmt();
		        $this->setState(817);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function delete_stmt(): Context\Delete_stmtContext
		{
		    $localContext = new Context\Delete_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 56, self::RULE_delete_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(820);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(819);
		        	$this->with_clause();
		        }
		        $this->setState(822);
		        $this->match(self::DELETE_);
		        $this->setState(823);
		        $this->match(self::FROM_);
		        $this->setState(824);
		        $this->qualified_table_name();
		        $this->setState(827);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WHERE_) {
		        	$this->setState(825);
		        	$this->match(self::WHERE_);
		        	$this->setState(826);
		        	$this->recursiveExpr(0);
		        }
		        $this->setState(830);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::RETURNING_) {
		        	$this->setState(829);
		        	$this->returning_clause();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function delete_stmt_limited(): Context\Delete_stmt_limitedContext
		{
		    $localContext = new Context\Delete_stmt_limitedContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 58, self::RULE_delete_stmt_limited);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(833);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(832);
		        	$this->with_clause();
		        }
		        $this->setState(835);
		        $this->match(self::DELETE_);
		        $this->setState(836);
		        $this->match(self::FROM_);
		        $this->setState(837);
		        $this->qualified_table_name();
		        $this->setState(840);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WHERE_) {
		        	$this->setState(838);
		        	$this->match(self::WHERE_);
		        	$this->setState(839);
		        	$this->recursiveExpr(0);
		        }
		        $this->setState(843);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::RETURNING_) {
		        	$this->setState(842);
		        	$this->returning_clause();
		        }
		        $this->setState(849);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::LIMIT_ || $_la === self::ORDER_) {
		        	$this->setState(846);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);

		        	if ($_la === self::ORDER_) {
		        		$this->setState(845);
		        		$this->order_by_stmt();
		        	}
		        	$this->setState(848);
		        	$this->limit_stmt();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function detach_stmt(): Context\Detach_stmtContext
		{
		    $localContext = new Context\Detach_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 60, self::RULE_detach_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(851);
		        $this->match(self::DETACH_);
		        $this->setState(853);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 104, $this->ctx)) {
		            case 1:
		        	    $this->setState(852);
		        	    $this->match(self::DATABASE_);
		        	break;
		        }
		        $this->setState(855);
		        $this->schema_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function drop_stmt(): Context\Drop_stmtContext
		{
		    $localContext = new Context\Drop_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 62, self::RULE_drop_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(857);
		        $this->match(self::DROP_);
		        $this->setState(858);

		        $localContext->object = $this->input->LT(1);
		        $_la = $this->input->LA(1);

		        if (!(((($_la - 84)) & ~0x3f) === 0 && ((1 << ($_la - 84)) & 2324138882699886593) !== 0)) {
		        	    $localContext->object = $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		        $this->setState(861);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 105, $this->ctx)) {
		            case 1:
		        	    $this->setState(859);
		        	    $this->match(self::IF_);
		        	    $this->setState(860);
		        	    $this->match(self::EXISTS_);
		        	break;
		        }
		        $this->setState(866);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 106, $this->ctx)) {
		            case 1:
		        	    $this->setState(863);
		        	    $this->schema_name();
		        	    $this->setState(864);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(868);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function expr(): Context\ExprContext
		{
			return $this->recursiveExpr(0);
		}

		/**
		 * @throws RecognitionException
		 */
		private function recursiveExpr(int $precedence): Context\ExprContext
		{
			$parentContext = $this->ctx;
			$parentState = $this->getState();
			$localContext = new Context\ExprContext($this->ctx, $parentState);
			$previousContext = $localContext;
			$startState = 64;
			$this->enterRecursionRule($localContext, 64, self::RULE_expr, $precedence);

			try {
				$this->enterOuterAlt($localContext, 1);
				$this->setState(958);
				$this->errorHandler->sync($this);

				switch ($this->getInterpreter()->adaptivePredict($this->input, 120, $this->ctx)) {
					case 1:
					    $this->setState(871);
					    $this->literal_value();
					break;

					case 2:
					    $this->setState(872);
					    $this->match(self::BIND_PARAMETER);
					break;

					case 3:
					    $this->setState(881);
					    $this->errorHandler->sync($this);

					    switch ($this->getInterpreter()->adaptivePredict($this->input, 108, $this->ctx)) {
					        case 1:
					    	    $this->setState(876);
					    	    $this->errorHandler->sync($this);

					    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 107, $this->ctx)) {
					    	        case 1:
					    	    	    $this->setState(873);
					    	    	    $this->schema_name();
					    	    	    $this->setState(874);
					    	    	    $this->match(self::DOT);
					    	    	break;
					    	    }
					    	    $this->setState(878);
					    	    $this->table_name();
					    	    $this->setState(879);
					    	    $this->match(self::DOT);
					    	break;
					    }
					    $this->setState(883);
					    $this->column_name();
					break;

					case 4:
					    $this->setState(884);
					    $this->unary_operator();
					    $this->setState(885);
					    $this->recursiveExpr(21);
					break;

					case 5:
					    $this->setState(887);
					    $this->function_name();
					    $this->setState(888);
					    $this->match(self::OPEN_PAR);
					    $this->setState(901);
					    $this->errorHandler->sync($this);

					    switch ($this->input->LA(1)) {
					        case self::OPEN_PAR:
					        case self::PLUS:
					        case self::MINUS:
					        case self::TILDE:
					        case self::ABORT_:
					        case self::ACTION_:
					        case self::ADD_:
					        case self::AFTER_:
					        case self::ALL_:
					        case self::ALTER_:
					        case self::ANALYZE_:
					        case self::AND_:
					        case self::AS_:
					        case self::ASC_:
					        case self::ATTACH_:
					        case self::AUTOINCREMENT_:
					        case self::BEFORE_:
					        case self::BEGIN_:
					        case self::BETWEEN_:
					        case self::BY_:
					        case self::CASCADE_:
					        case self::CASE_:
					        case self::CAST_:
					        case self::CHECK_:
					        case self::COLLATE_:
					        case self::COLUMN_:
					        case self::COMMIT_:
					        case self::CONFLICT_:
					        case self::CONSTRAINT_:
					        case self::CREATE_:
					        case self::CROSS_:
					        case self::CURRENT_DATE_:
					        case self::CURRENT_TIME_:
					        case self::CURRENT_TIMESTAMP_:
					        case self::DATABASE_:
					        case self::DEFAULT_:
					        case self::DEFERRABLE_:
					        case self::DEFERRED_:
					        case self::DELETE_:
					        case self::DESC_:
					        case self::DETACH_:
					        case self::DISTINCT_:
					        case self::DROP_:
					        case self::EACH_:
					        case self::ELSE_:
					        case self::END_:
					        case self::ESCAPE_:
					        case self::EXCEPT_:
					        case self::EXCLUSIVE_:
					        case self::EXISTS_:
					        case self::EXPLAIN_:
					        case self::FAIL_:
					        case self::FOR_:
					        case self::FOREIGN_:
					        case self::FROM_:
					        case self::FULL_:
					        case self::GLOB_:
					        case self::GROUP_:
					        case self::HAVING_:
					        case self::IF_:
					        case self::IGNORE_:
					        case self::IMMEDIATE_:
					        case self::IN_:
					        case self::INDEX_:
					        case self::INDEXED_:
					        case self::INITIALLY_:
					        case self::INNER_:
					        case self::INSERT_:
					        case self::INSTEAD_:
					        case self::INTERSECT_:
					        case self::INTO_:
					        case self::IS_:
					        case self::ISNULL_:
					        case self::JOIN_:
					        case self::KEY_:
					        case self::LEFT_:
					        case self::LIKE_:
					        case self::LIMIT_:
					        case self::MATCH_:
					        case self::NATURAL_:
					        case self::NO_:
					        case self::NOT_:
					        case self::NOTNULL_:
					        case self::NULL_:
					        case self::OF_:
					        case self::OFFSET_:
					        case self::ON_:
					        case self::OR_:
					        case self::ORDER_:
					        case self::OUTER_:
					        case self::PLAN_:
					        case self::PRAGMA_:
					        case self::PRIMARY_:
					        case self::QUERY_:
					        case self::RAISE_:
					        case self::RECURSIVE_:
					        case self::REFERENCES_:
					        case self::REGEXP_:
					        case self::REINDEX_:
					        case self::RELEASE_:
					        case self::RENAME_:
					        case self::REPLACE_:
					        case self::RESTRICT_:
					        case self::RIGHT_:
					        case self::ROLLBACK_:
					        case self::ROW_:
					        case self::ROWS_:
					        case self::SAVEPOINT_:
					        case self::SELECT_:
					        case self::SET_:
					        case self::TABLE_:
					        case self::TEMP_:
					        case self::TEMPORARY_:
					        case self::THEN_:
					        case self::TO_:
					        case self::TRANSACTION_:
					        case self::TRIGGER_:
					        case self::UNION_:
					        case self::UNIQUE_:
					        case self::UPDATE_:
					        case self::USING_:
					        case self::VACUUM_:
					        case self::VALUES_:
					        case self::VIEW_:
					        case self::VIRTUAL_:
					        case self::WHEN_:
					        case self::WHERE_:
					        case self::WITH_:
					        case self::WITHOUT_:
					        case self::FIRST_VALUE_:
					        case self::OVER_:
					        case self::PARTITION_:
					        case self::RANGE_:
					        case self::PRECEDING_:
					        case self::UNBOUNDED_:
					        case self::CURRENT_:
					        case self::FOLLOWING_:
					        case self::CUME_DIST_:
					        case self::DENSE_RANK_:
					        case self::LAG_:
					        case self::LAST_VALUE_:
					        case self::LEAD_:
					        case self::NTH_VALUE_:
					        case self::NTILE_:
					        case self::PERCENT_RANK_:
					        case self::RANK_:
					        case self::ROW_NUMBER_:
					        case self::GENERATED_:
					        case self::ALWAYS_:
					        case self::STORED_:
					        case self::TRUE_:
					        case self::FALSE_:
					        case self::WINDOW_:
					        case self::NULLS_:
					        case self::FIRST_:
					        case self::LAST_:
					        case self::FILTER_:
					        case self::GROUPS_:
					        case self::EXCLUDE_:
					        case self::IDENTIFIER:
					        case self::NUMERIC_LITERAL:
					        case self::BIND_PARAMETER:
					        case self::STRING_LITERAL:
					        case self::BLOB_LITERAL:
					        	$this->setState(890);
					        	$this->errorHandler->sync($this);

					        	switch ($this->getInterpreter()->adaptivePredict($this->input, 109, $this->ctx)) {
					        	    case 1:
					        		    $this->setState(889);
					        		    $this->match(self::DISTINCT_);
					        		break;
					        	}
					        	$this->setState(892);
					        	$this->recursiveExpr(0);
					        	$this->setState(897);
					        	$this->errorHandler->sync($this);

					        	$_la = $this->input->LA(1);
					        	while ($_la === self::COMMA) {
					        		$this->setState(893);
					        		$this->match(self::COMMA);
					        		$this->setState(894);
					        		$this->recursiveExpr(0);
					        		$this->setState(899);
					        		$this->errorHandler->sync($this);
					        		$_la = $this->input->LA(1);
					        	}
					        	break;

					        case self::STAR:
					        	$this->setState(900);
					        	$this->match(self::STAR);
					        	break;

					        case self::CLOSE_PAR:
					        	break;

					    default:
					    	break;
					    }
					    $this->setState(903);
					    $this->match(self::CLOSE_PAR);
					    $this->setState(905);
					    $this->errorHandler->sync($this);

					    switch ($this->getInterpreter()->adaptivePredict($this->input, 112, $this->ctx)) {
					        case 1:
					    	    $this->setState(904);
					    	    $this->filter_clause();
					    	break;
					    }
					    $this->setState(908);
					    $this->errorHandler->sync($this);

					    switch ($this->getInterpreter()->adaptivePredict($this->input, 113, $this->ctx)) {
					        case 1:
					    	    $this->setState(907);
					    	    $this->over_clause();
					    	break;
					    }
					break;

					case 6:
					    $this->setState(910);
					    $this->match(self::OPEN_PAR);
					    $this->setState(911);
					    $this->recursiveExpr(0);
					    $this->setState(916);
					    $this->errorHandler->sync($this);

					    $_la = $this->input->LA(1);
					    while ($_la === self::COMMA) {
					    	$this->setState(912);
					    	$this->match(self::COMMA);
					    	$this->setState(913);
					    	$this->recursiveExpr(0);
					    	$this->setState(918);
					    	$this->errorHandler->sync($this);
					    	$_la = $this->input->LA(1);
					    }
					    $this->setState(919);
					    $this->match(self::CLOSE_PAR);
					break;

					case 7:
					    $this->setState(921);
					    $this->match(self::CAST_);
					    $this->setState(922);
					    $this->match(self::OPEN_PAR);
					    $this->setState(923);
					    $this->recursiveExpr(0);
					    $this->setState(924);
					    $this->match(self::AS_);
					    $this->setState(925);
					    $this->type_name();
					    $this->setState(926);
					    $this->match(self::CLOSE_PAR);
					break;

					case 8:
					    $this->setState(932);
					    $this->errorHandler->sync($this);
					    $_la = $this->input->LA(1);

					    if ($_la === self::EXISTS_ || $_la === self::NOT_) {
					    	$this->setState(929);
					    	$this->errorHandler->sync($this);
					    	$_la = $this->input->LA(1);

					    	if ($_la === self::NOT_) {
					    		$this->setState(928);
					    		$this->match(self::NOT_);
					    	}
					    	$this->setState(931);
					    	$this->match(self::EXISTS_);
					    }
					    $this->setState(934);
					    $this->match(self::OPEN_PAR);
					    $this->setState(935);
					    $this->select_stmt();
					    $this->setState(936);
					    $this->match(self::CLOSE_PAR);
					break;

					case 9:
					    $this->setState(938);
					    $this->match(self::CASE_);
					    $this->setState(940);
					    $this->errorHandler->sync($this);

					    switch ($this->getInterpreter()->adaptivePredict($this->input, 117, $this->ctx)) {
					        case 1:
					    	    $this->setState(939);
					    	    $this->recursiveExpr(0);
					    	break;
					    }
					    $this->setState(947); 
					    $this->errorHandler->sync($this);

					    $_la = $this->input->LA(1);
					    do {
					    	$this->setState(942);
					    	$this->match(self::WHEN_);
					    	$this->setState(943);
					    	$this->recursiveExpr(0);
					    	$this->setState(944);
					    	$this->match(self::THEN_);
					    	$this->setState(945);
					    	$this->recursiveExpr(0);
					    	$this->setState(949); 
					    	$this->errorHandler->sync($this);
					    	$_la = $this->input->LA(1);
					    } while ($_la === self::WHEN_);
					    $this->setState(953);
					    $this->errorHandler->sync($this);
					    $_la = $this->input->LA(1);

					    if ($_la === self::ELSE_) {
					    	$this->setState(951);
					    	$this->match(self::ELSE_);
					    	$this->setState(952);
					    	$this->recursiveExpr(0);
					    }
					    $this->setState(955);
					    $this->match(self::END_);
					break;

					case 10:
					    $this->setState(957);
					    $this->raise_function();
					break;
				}
				$this->ctx->stop = $this->input->LT(-1);
				$this->setState(1079);
				$this->errorHandler->sync($this);

				$alt = $this->getInterpreter()->adaptivePredict($this->input, 136, $this->ctx);

				while ($alt !== 2 && $alt !== ATN::INVALID_ALT_NUMBER) {
					if ($alt === 1) {
						if ($this->getParseListeners() !== null) {
						    $this->triggerExitRuleEvent();
						}

						$previousContext = $localContext;
						$this->setState(1077);
						$this->errorHandler->sync($this);

						switch ($this->getInterpreter()->adaptivePredict($this->input, 135, $this->ctx)) {
							case 1:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(960);

							    if (!($this->precpred($this->ctx, 20))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 20)");
							    }
							    $this->setState(961);
							    $this->match(self::PIPE2);
							    $this->setState(962);
							    $this->recursiveExpr(21);
							break;

							case 2:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(963);

							    if (!($this->precpred($this->ctx, 19))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 19)");
							    }
							    $this->setState(964);

							    $_la = $this->input->LA(1);

							    if (!((($_la) & ~0x3f) === 0 && ((1 << $_la) & 12416) !== 0)) {
							    $this->errorHandler->recoverInline($this);
							    } else {
							    	if ($this->input->LA(1) === Token::EOF) {
							    	    $this->matchedEOF = true;
							        }

							    	$this->errorHandler->reportMatch($this);
							    	$this->consume();
							    }
							    $this->setState(965);
							    $this->recursiveExpr(20);
							break;

							case 3:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(966);

							    if (!($this->precpred($this->ctx, 18))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 18)");
							    }
							    $this->setState(967);

							    $_la = $this->input->LA(1);

							    if (!($_la === self::PLUS || $_la === self::MINUS)) {
							    $this->errorHandler->recoverInline($this);
							    } else {
							    	if ($this->input->LA(1) === Token::EOF) {
							    	    $this->matchedEOF = true;
							        }

							    	$this->errorHandler->reportMatch($this);
							    	$this->consume();
							    }
							    $this->setState(968);
							    $this->recursiveExpr(19);
							break;

							case 4:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(969);

							    if (!($this->precpred($this->ctx, 17))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 17)");
							    }
							    $this->setState(970);

							    $_la = $this->input->LA(1);

							    if (!((($_la) & ~0x3f) === 0 && ((1 << $_la) & 245760) !== 0)) {
							    $this->errorHandler->recoverInline($this);
							    } else {
							    	if ($this->input->LA(1) === Token::EOF) {
							    	    $this->matchedEOF = true;
							        }

							    	$this->errorHandler->reportMatch($this);
							    	$this->consume();
							    }
							    $this->setState(971);
							    $this->recursiveExpr(18);
							break;

							case 5:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(972);

							    if (!($this->precpred($this->ctx, 16))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 16)");
							    }
							    $this->setState(973);

							    $_la = $this->input->LA(1);

							    if (!((($_la) & ~0x3f) === 0 && ((1 << $_la) & 3932160) !== 0)) {
							    $this->errorHandler->recoverInline($this);
							    } else {
							    	if ($this->input->LA(1) === Token::EOF) {
							    	    $this->matchedEOF = true;
							        }

							    	$this->errorHandler->reportMatch($this);
							    	$this->consume();
							    }
							    $this->setState(974);
							    $this->recursiveExpr(17);
							break;

							case 6:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(975);

							    if (!($this->precpred($this->ctx, 15))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 15)");
							    }
							    $this->setState(988);
							    $this->errorHandler->sync($this);

							    switch ($this->getInterpreter()->adaptivePredict($this->input, 121, $this->ctx)) {
							    	case 1:
							    	    $this->setState(976);
							    	    $this->match(self::ASSIGN);
							    	break;

							    	case 2:
							    	    $this->setState(977);
							    	    $this->match(self::EQ);
							    	break;

							    	case 3:
							    	    $this->setState(978);
							    	    $this->match(self::NOT_EQ1);
							    	break;

							    	case 4:
							    	    $this->setState(979);
							    	    $this->match(self::NOT_EQ2);
							    	break;

							    	case 5:
							    	    $this->setState(980);
							    	    $this->match(self::IS_);
							    	break;

							    	case 6:
							    	    $this->setState(981);
							    	    $this->match(self::IS_);
							    	    $this->setState(982);
							    	    $this->match(self::NOT_);
							    	break;

							    	case 7:
							    	    $this->setState(983);
							    	    $this->match(self::IN_);
							    	break;

							    	case 8:
							    	    $this->setState(984);
							    	    $this->match(self::LIKE_);
							    	break;

							    	case 9:
							    	    $this->setState(985);
							    	    $this->match(self::GLOB_);
							    	break;

							    	case 10:
							    	    $this->setState(986);
							    	    $this->match(self::MATCH_);
							    	break;

							    	case 11:
							    	    $this->setState(987);
							    	    $this->match(self::REGEXP_);
							    	break;
							    }
							    $this->setState(990);
							    $this->recursiveExpr(16);
							break;

							case 7:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(991);

							    if (!($this->precpred($this->ctx, 14))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 14)");
							    }
							    $this->setState(992);
							    $this->match(self::AND_);
							    $this->setState(993);
							    $this->recursiveExpr(15);
							break;

							case 8:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(994);

							    if (!($this->precpred($this->ctx, 13))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 13)");
							    }
							    $this->setState(995);
							    $this->match(self::OR_);
							    $this->setState(996);
							    $this->recursiveExpr(14);
							break;

							case 9:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(997);

							    if (!($this->precpred($this->ctx, 6))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 6)");
							    }
							    $this->setState(998);
							    $this->match(self::IS_);
							    $this->setState(1000);
							    $this->errorHandler->sync($this);

							    switch ($this->getInterpreter()->adaptivePredict($this->input, 122, $this->ctx)) {
							        case 1:
							    	    $this->setState(999);
							    	    $this->match(self::NOT_);
							    	break;
							    }
							    $this->setState(1002);
							    $this->recursiveExpr(7);
							break;

							case 10:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(1003);

							    if (!($this->precpred($this->ctx, 5))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 5)");
							    }
							    $this->setState(1005);
							    $this->errorHandler->sync($this);
							    $_la = $this->input->LA(1);

							    if ($_la === self::NOT_) {
							    	$this->setState(1004);
							    	$this->match(self::NOT_);
							    }
							    $this->setState(1007);
							    $this->match(self::BETWEEN_);
							    $this->setState(1008);
							    $this->recursiveExpr(0);
							    $this->setState(1009);
							    $this->match(self::AND_);
							    $this->setState(1010);
							    $this->recursiveExpr(6);
							break;

							case 11:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(1012);

							    if (!($this->precpred($this->ctx, 9))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 9)");
							    }
							    $this->setState(1013);
							    $this->match(self::COLLATE_);
							    $this->setState(1014);
							    $this->collation_name();
							break;

							case 12:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(1015);

							    if (!($this->precpred($this->ctx, 8))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 8)");
							    }
							    $this->setState(1017);
							    $this->errorHandler->sync($this);
							    $_la = $this->input->LA(1);

							    if ($_la === self::NOT_) {
							    	$this->setState(1016);
							    	$this->match(self::NOT_);
							    }
							    $this->setState(1019);

							    $_la = $this->input->LA(1);

							    if (!(((($_la - 77)) & ~0x3f) === 0 && ((1 << ($_la - 77)) & 2199028498433) !== 0)) {
							    $this->errorHandler->recoverInline($this);
							    } else {
							    	if ($this->input->LA(1) === Token::EOF) {
							    	    $this->matchedEOF = true;
							        }

							    	$this->errorHandler->reportMatch($this);
							    	$this->consume();
							    }
							    $this->setState(1020);
							    $this->recursiveExpr(0);
							    $this->setState(1023);
							    $this->errorHandler->sync($this);

							    switch ($this->getInterpreter()->adaptivePredict($this->input, 125, $this->ctx)) {
							        case 1:
							    	    $this->setState(1021);
							    	    $this->match(self::ESCAPE_);
							    	    $this->setState(1022);
							    	    $this->recursiveExpr(0);
							    	break;
							    }
							break;

							case 13:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(1025);

							    if (!($this->precpred($this->ctx, 7))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 7)");
							    }
							    $this->setState(1030);
							    $this->errorHandler->sync($this);

							    switch ($this->input->LA(1)) {
							        case self::ISNULL_:
							        	$this->setState(1026);
							        	$this->match(self::ISNULL_);
							        	break;

							        case self::NOTNULL_:
							        	$this->setState(1027);
							        	$this->match(self::NOTNULL_);
							        	break;

							        case self::NOT_:
							        	$this->setState(1028);
							        	$this->match(self::NOT_);
							        	$this->setState(1029);
							        	$this->match(self::NULL_);
							        	break;

							    default:
							    	throw new NoViableAltException($this);
							    }
							break;

							case 14:
							    $localContext = new Context\ExprContext($parentContext, $parentState);
							    $this->pushNewRecursionContext($localContext, $startState, self::RULE_expr);
							    $this->setState(1032);

							    if (!($this->precpred($this->ctx, 4))) {
							        throw new FailedPredicateException($this, "\\\$this->precpred(\\\$this->ctx, 4)");
							    }
							    $this->setState(1034);
							    $this->errorHandler->sync($this);
							    $_la = $this->input->LA(1);

							    if ($_la === self::NOT_) {
							    	$this->setState(1033);
							    	$this->match(self::NOT_);
							    }
							    $this->setState(1036);
							    $this->match(self::IN_);
							    $this->setState(1075);
							    $this->errorHandler->sync($this);

							    switch ($this->getInterpreter()->adaptivePredict($this->input, 134, $this->ctx)) {
							    	case 1:
							    	    $this->setState(1037);
							    	    $this->match(self::OPEN_PAR);
							    	    $this->setState(1047);
							    	    $this->errorHandler->sync($this);

							    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 129, $this->ctx)) {
							    	        case 1:
							    	    	    $this->setState(1038);
							    	    	    $this->select_stmt();
							    	    	break;

							    	        case 2:
							    	    	    $this->setState(1039);
							    	    	    $this->recursiveExpr(0);
							    	    	    $this->setState(1044);
							    	    	    $this->errorHandler->sync($this);

							    	    	    $_la = $this->input->LA(1);
							    	    	    while ($_la === self::COMMA) {
							    	    	    	$this->setState(1040);
							    	    	    	$this->match(self::COMMA);
							    	    	    	$this->setState(1041);
							    	    	    	$this->recursiveExpr(0);
							    	    	    	$this->setState(1046);
							    	    	    	$this->errorHandler->sync($this);
							    	    	    	$_la = $this->input->LA(1);
							    	    	    }
							    	    	break;
							    	    }
							    	    $this->setState(1049);
							    	    $this->match(self::CLOSE_PAR);
							    	break;

							    	case 2:
							    	    $this->setState(1053);
							    	    $this->errorHandler->sync($this);

							    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 130, $this->ctx)) {
							    	        case 1:
							    	    	    $this->setState(1050);
							    	    	    $this->schema_name();
							    	    	    $this->setState(1051);
							    	    	    $this->match(self::DOT);
							    	    	break;
							    	    }
							    	    $this->setState(1055);
							    	    $this->table_name();
							    	break;

							    	case 3:
							    	    $this->setState(1059);
							    	    $this->errorHandler->sync($this);

							    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 131, $this->ctx)) {
							    	        case 1:
							    	    	    $this->setState(1056);
							    	    	    $this->schema_name();
							    	    	    $this->setState(1057);
							    	    	    $this->match(self::DOT);
							    	    	break;
							    	    }
							    	    $this->setState(1061);
							    	    $this->table_function_name();
							    	    $this->setState(1062);
							    	    $this->match(self::OPEN_PAR);
							    	    $this->setState(1071);
							    	    $this->errorHandler->sync($this);
							    	    $_la = $this->input->LA(1);

							    	    if ((($_la) & ~0x3f) === 0 && ((1 << $_la) & -33552632) !== 0 || ((($_la - 64)) & ~0x3f) === 0 && ((1 << ($_la - 64)) & -1152921504606846977) !== 0 || ((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 4476578029606273023) !== 0) {
							    	    	$this->setState(1063);
							    	    	$this->recursiveExpr(0);
							    	    	$this->setState(1068);
							    	    	$this->errorHandler->sync($this);

							    	    	$_la = $this->input->LA(1);
							    	    	while ($_la === self::COMMA) {
							    	    		$this->setState(1064);
							    	    		$this->match(self::COMMA);
							    	    		$this->setState(1065);
							    	    		$this->recursiveExpr(0);
							    	    		$this->setState(1070);
							    	    		$this->errorHandler->sync($this);
							    	    		$_la = $this->input->LA(1);
							    	    	}
							    	    }
							    	    $this->setState(1073);
							    	    $this->match(self::CLOSE_PAR);
							    	break;
							    }
							break;
						} 
					}

					$this->setState(1081);
					$this->errorHandler->sync($this);

					$alt = $this->getInterpreter()->adaptivePredict($this->input, 136, $this->ctx);
				}
			} catch (RecognitionException $exception) {
				$localContext->exception = $exception;
				$this->errorHandler->reportError($this, $exception);
				$this->errorHandler->recover($this, $exception);
			} finally {
				$this->unrollRecursionContexts($parentContext);
			}

			return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function raise_function(): Context\Raise_functionContext
		{
		    $localContext = new Context\Raise_functionContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 66, self::RULE_raise_function);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1082);
		        $this->match(self::RAISE_);
		        $this->setState(1083);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1088);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::IGNORE_:
		            	$this->setState(1084);
		            	$this->match(self::IGNORE_);
		            	break;

		            case self::ABORT_:
		            case self::FAIL_:
		            case self::ROLLBACK_:
		            	$this->setState(1085);

		            	$_la = $this->input->LA(1);

		            	if (!($_la === self::ABORT_ || $_la === self::FAIL_ || $_la === self::ROLLBACK_)) {
		            	$this->errorHandler->recoverInline($this);
		            	} else {
		            		if ($this->input->LA(1) === Token::EOF) {
		            		    $this->matchedEOF = true;
		            	    }

		            		$this->errorHandler->reportMatch($this);
		            		$this->consume();
		            	}
		            	$this->setState(1086);
		            	$this->match(self::COMMA);
		            	$this->setState(1087);
		            	$this->error_message();
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		        $this->setState(1090);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function literal_value(): Context\Literal_valueContext
		{
		    $localContext = new Context\Literal_valueContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 68, self::RULE_literal_value);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1092);

		        $_la = $this->input->LA(1);

		        if (!(((($_la - 52)) & ~0x3f) === 0 && ((1 << ($_la - 52)) & 4503599627370503) !== 0 || ((($_la - 172)) & ~0x3f) === 0 && ((1 << ($_la - 172)) & 212995) !== 0)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function insert_stmt(): Context\Insert_stmtContext
		{
		    $localContext = new Context\Insert_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 70, self::RULE_insert_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1095);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(1094);
		        	$this->with_clause();
		        }
		        $this->setState(1102);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 139, $this->ctx)) {
		        	case 1:
		        	    $this->setState(1097);
		        	    $this->match(self::INSERT_);
		        	break;

		        	case 2:
		        	    $this->setState(1098);
		        	    $this->match(self::REPLACE_);
		        	break;

		        	case 3:
		        	    $this->setState(1099);
		        	    $this->match(self::INSERT_);
		        	    $this->setState(1100);
		        	    $this->match(self::OR_);
		        	    $this->setState(1101);

		        	    $_la = $this->input->LA(1);

		        	    if (!($_la === self::ABORT_ || ((($_la - 72)) & ~0x3f) === 0 && ((1 << ($_la - 72)) & 19140298416325121) !== 0)) {
		        	    $this->errorHandler->recoverInline($this);
		        	    } else {
		        	    	if ($this->input->LA(1) === Token::EOF) {
		        	    	    $this->matchedEOF = true;
		        	        }

		        	    	$this->errorHandler->reportMatch($this);
		        	    	$this->consume();
		        	    }
		        	break;
		        }
		        $this->setState(1104);
		        $this->match(self::INTO_);
		        $this->setState(1108);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 140, $this->ctx)) {
		            case 1:
		        	    $this->setState(1105);
		        	    $this->schema_name();
		        	    $this->setState(1106);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(1110);
		        $this->table_name();
		        $this->setState(1113);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::AS_) {
		        	$this->setState(1111);
		        	$this->match(self::AS_);
		        	$this->setState(1112);
		        	$this->table_alias();
		        }
		        $this->setState(1126);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(1115);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(1116);
		        	$this->column_name();
		        	$this->setState(1121);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(1117);
		        		$this->match(self::COMMA);
		        		$this->setState(1118);
		        		$this->column_name();
		        		$this->setState(1123);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(1124);
		        	$this->match(self::CLOSE_PAR);
		        }
		        $this->setState(1164);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::SELECT_:
		            case self::VALUES_:
		            case self::WITH_:
		            	$this->setState(1157);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 147, $this->ctx)) {
		            		case 1:
		            		    $this->setState(1128);
		            		    $this->match(self::VALUES_);
		            		    $this->setState(1129);
		            		    $this->match(self::OPEN_PAR);
		            		    $this->setState(1130);
		            		    $this->recursiveExpr(0);
		            		    $this->setState(1135);
		            		    $this->errorHandler->sync($this);

		            		    $_la = $this->input->LA(1);
		            		    while ($_la === self::COMMA) {
		            		    	$this->setState(1131);
		            		    	$this->match(self::COMMA);
		            		    	$this->setState(1132);
		            		    	$this->recursiveExpr(0);
		            		    	$this->setState(1137);
		            		    	$this->errorHandler->sync($this);
		            		    	$_la = $this->input->LA(1);
		            		    }
		            		    $this->setState(1138);
		            		    $this->match(self::CLOSE_PAR);
		            		    $this->setState(1153);
		            		    $this->errorHandler->sync($this);

		            		    $_la = $this->input->LA(1);
		            		    while ($_la === self::COMMA) {
		            		    	$this->setState(1139);
		            		    	$this->match(self::COMMA);
		            		    	$this->setState(1140);
		            		    	$this->match(self::OPEN_PAR);
		            		    	$this->setState(1141);
		            		    	$this->recursiveExpr(0);
		            		    	$this->setState(1146);
		            		    	$this->errorHandler->sync($this);

		            		    	$_la = $this->input->LA(1);
		            		    	while ($_la === self::COMMA) {
		            		    		$this->setState(1142);
		            		    		$this->match(self::COMMA);
		            		    		$this->setState(1143);
		            		    		$this->recursiveExpr(0);
		            		    		$this->setState(1148);
		            		    		$this->errorHandler->sync($this);
		            		    		$_la = $this->input->LA(1);
		            		    	}
		            		    	$this->setState(1149);
		            		    	$this->match(self::CLOSE_PAR);
		            		    	$this->setState(1155);
		            		    	$this->errorHandler->sync($this);
		            		    	$_la = $this->input->LA(1);
		            		    }
		            		break;

		            		case 2:
		            		    $this->setState(1156);
		            		    $this->select_stmt();
		            		break;
		            	}
		            	$this->setState(1160);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ON_) {
		            		$this->setState(1159);
		            		$this->upsert_clause();
		            	}
		            	break;

		            case self::DEFAULT_:
		            	$this->setState(1162);
		            	$this->match(self::DEFAULT_);
		            	$this->setState(1163);
		            	$this->match(self::VALUES_);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		        $this->setState(1167);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::RETURNING_) {
		        	$this->setState(1166);
		        	$this->returning_clause();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function returning_clause(): Context\Returning_clauseContext
		{
		    $localContext = new Context\Returning_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 72, self::RULE_returning_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1169);
		        $this->match(self::RETURNING_);
		        $this->setState(1170);
		        $this->result_column();
		        $this->setState(1175);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1171);
		        	$this->match(self::COMMA);
		        	$this->setState(1172);
		        	$this->result_column();
		        	$this->setState(1177);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function upsert_clause(): Context\Upsert_clauseContext
		{
		    $localContext = new Context\Upsert_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 74, self::RULE_upsert_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1178);
		        $this->match(self::ON_);
		        $this->setState(1179);
		        $this->match(self::CONFLICT_);
		        $this->setState(1194);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::OPEN_PAR) {
		        	$this->setState(1180);
		        	$this->match(self::OPEN_PAR);
		        	$this->setState(1181);
		        	$this->indexed_column();
		        	$this->setState(1186);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(1182);
		        		$this->match(self::COMMA);
		        		$this->setState(1183);
		        		$this->indexed_column();
		        		$this->setState(1188);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        	$this->setState(1189);
		        	$this->match(self::CLOSE_PAR);
		        	$this->setState(1192);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);

		        	if ($_la === self::WHERE_) {
		        		$this->setState(1190);
		        		$this->match(self::WHERE_);
		        		$this->setState(1191);
		        		$this->recursiveExpr(0);
		        	}
		        }
		        $this->setState(1196);
		        $this->match(self::DO_);
		        $this->setState(1223);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::NOTHING_:
		            	$this->setState(1197);
		            	$this->match(self::NOTHING_);
		            	break;

		            case self::UPDATE_:
		            	$this->setState(1198);
		            	$this->match(self::UPDATE_);
		            	$this->setState(1199);
		            	$this->match(self::SET_);

		            	$this->setState(1202);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 155, $this->ctx)) {
		            		case 1:
		            		    $this->setState(1200);
		            		    $this->column_name();
		            		break;

		            		case 2:
		            		    $this->setState(1201);
		            		    $this->column_name_list();
		            		break;
		            	}
		            	$this->setState(1204);
		            	$this->match(self::ASSIGN);
		            	$this->setState(1205);
		            	$this->recursiveExpr(0);
		            	$this->setState(1216);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1206);
		            		$this->match(self::COMMA);
		            		$this->setState(1209);
		            		$this->errorHandler->sync($this);

		            		switch ($this->getInterpreter()->adaptivePredict($this->input, 156, $this->ctx)) {
		            			case 1:
		            			    $this->setState(1207);
		            			    $this->column_name();
		            			break;

		            			case 2:
		            			    $this->setState(1208);
		            			    $this->column_name_list();
		            			break;
		            		}
		            		$this->setState(1211);
		            		$this->match(self::ASSIGN);
		            		$this->setState(1212);
		            		$this->recursiveExpr(0);
		            		$this->setState(1218);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(1221);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::WHERE_) {
		            		$this->setState(1219);
		            		$this->match(self::WHERE_);
		            		$this->setState(1220);
		            		$this->recursiveExpr(0);
		            	}
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function pragma_stmt(): Context\Pragma_stmtContext
		{
		    $localContext = new Context\Pragma_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 76, self::RULE_pragma_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1225);
		        $this->match(self::PRAGMA_);
		        $this->setState(1229);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 160, $this->ctx)) {
		            case 1:
		        	    $this->setState(1226);
		        	    $this->schema_name();
		        	    $this->setState(1227);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(1231);
		        $this->pragma_name();
		        $this->setState(1238);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::ASSIGN:
		            	$this->setState(1232);
		            	$this->match(self::ASSIGN);
		            	$this->setState(1233);
		            	$this->pragma_value();
		            	break;

		            case self::OPEN_PAR:
		            	$this->setState(1234);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1235);
		            	$this->pragma_value();
		            	$this->setState(1236);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::EOF:
		            case self::SCOL:
		            case self::ALTER_:
		            case self::ANALYZE_:
		            case self::ATTACH_:
		            case self::BEGIN_:
		            case self::COMMIT_:
		            case self::CREATE_:
		            case self::DELETE_:
		            case self::DETACH_:
		            case self::DROP_:
		            case self::END_:
		            case self::EXPLAIN_:
		            case self::INSERT_:
		            case self::PRAGMA_:
		            case self::REINDEX_:
		            case self::RELEASE_:
		            case self::REPLACE_:
		            case self::ROLLBACK_:
		            case self::SAVEPOINT_:
		            case self::SELECT_:
		            case self::UPDATE_:
		            case self::VACUUM_:
		            case self::VALUES_:
		            case self::WITH_:
		            	break;

		        default:
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function pragma_value(): Context\Pragma_valueContext
		{
		    $localContext = new Context\Pragma_valueContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 78, self::RULE_pragma_value);

		    try {
		        $this->setState(1243);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 162, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(1240);
		        	    $this->signed_number();
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(1241);
		        	    $this->name();
		        	break;

		        	case 3:
		        	    $this->enterOuterAlt($localContext, 3);
		        	    $this->setState(1242);
		        	    $this->match(self::STRING_LITERAL);
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function reindex_stmt(): Context\Reindex_stmtContext
		{
		    $localContext = new Context\Reindex_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 80, self::RULE_reindex_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1245);
		        $this->match(self::REINDEX_);
		        $this->setState(1256);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 165, $this->ctx)) {
		            case 1:
		        	    $this->setState(1246);
		        	    $this->collation_name();
		        	break;

		            case 2:
		        	    $this->setState(1250);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 163, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1247);
		        	    	    $this->schema_name();
		        	    	    $this->setState(1248);
		        	    	    $this->match(self::DOT);
		        	    	break;
		        	    }
		        	    $this->setState(1254);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 164, $this->ctx)) {
		        	    	case 1:
		        	    	    $this->setState(1252);
		        	    	    $this->table_name();
		        	    	break;

		        	    	case 2:
		        	    	    $this->setState(1253);
		        	    	    $this->index_name();
		        	    	break;
		        	    }
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function select_stmt(): Context\Select_stmtContext
		{
		    $localContext = new Context\Select_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 82, self::RULE_select_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1259);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(1258);
		        	$this->common_table_stmt();
		        }
		        $this->setState(1261);
		        $this->select_core();
		        $this->setState(1267);
		        $this->errorHandler->sync($this);

		        $alt = $this->getInterpreter()->adaptivePredict($this->input, 167, $this->ctx);

		        while ($alt !== 2 && $alt !== ATN::INVALID_ALT_NUMBER) {
		        	if ($alt === 1) {
		        		$this->setState(1262);
		        		$this->compound_operator();
		        		$this->setState(1263);
		        		$this->select_core(); 
		        	}

		        	$this->setState(1269);
		        	$this->errorHandler->sync($this);

		        	$alt = $this->getInterpreter()->adaptivePredict($this->input, 167, $this->ctx);
		        }
		        $this->setState(1271);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ORDER_) {
		        	$this->setState(1270);
		        	$this->order_by_stmt();
		        }
		        $this->setState(1274);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::LIMIT_) {
		        	$this->setState(1273);
		        	$this->limit_stmt();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function join_clause(): Context\Join_clauseContext
		{
		    $localContext = new Context\Join_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 84, self::RULE_join_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1276);
		        $this->table_or_subquery();
		        $this->setState(1284);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA || $_la === self::CROSS_ || ((($_la - 87)) & ~0x3f) === 0 && ((1 << ($_la - 87)) & 8833) !== 0) {
		        	$this->setState(1277);
		        	$this->join_operator();
		        	$this->setState(1278);
		        	$this->table_or_subquery();
		        	$this->setState(1280);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 170, $this->ctx)) {
		        	    case 1:
		        		    $this->setState(1279);
		        		    $this->join_constraint();
		        		break;
		        	}
		        	$this->setState(1286);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function select_core(): Context\Select_coreContext
		{
		    $localContext = new Context\Select_coreContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 86, self::RULE_select_core);

		    try {
		        $this->setState(1377);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::SELECT_:
		            	$this->enterOuterAlt($localContext, 1);
		            	$this->setState(1287);
		            	$this->match(self::SELECT_);
		            	$this->setState(1289);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 172, $this->ctx)) {
		            	    case 1:
		            		    $this->setState(1288);

		            		    $_la = $this->input->LA(1);

		            		    if (!($_la === self::ALL_ || $_la === self::DISTINCT_)) {
		            		    $this->errorHandler->recoverInline($this);
		            		    } else {
		            		    	if ($this->input->LA(1) === Token::EOF) {
		            		    	    $this->matchedEOF = true;
		            		        }

		            		    	$this->errorHandler->reportMatch($this);
		            		    	$this->consume();
		            		    }
		            		break;
		            	}
		            	$this->setState(1291);
		            	$this->result_column();
		            	$this->setState(1296);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1292);
		            		$this->match(self::COMMA);
		            		$this->setState(1293);
		            		$this->result_column();
		            		$this->setState(1298);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(1311);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::FROM_) {
		            		$this->setState(1299);
		            		$this->match(self::FROM_);
		            		$this->setState(1309);
		            		$this->errorHandler->sync($this);

		            		switch ($this->getInterpreter()->adaptivePredict($this->input, 175, $this->ctx)) {
		            			case 1:
		            			    $this->setState(1300);
		            			    $this->table_or_subquery();
		            			    $this->setState(1305);
		            			    $this->errorHandler->sync($this);

		            			    $_la = $this->input->LA(1);
		            			    while ($_la === self::COMMA) {
		            			    	$this->setState(1301);
		            			    	$this->match(self::COMMA);
		            			    	$this->setState(1302);
		            			    	$this->table_or_subquery();
		            			    	$this->setState(1307);
		            			    	$this->errorHandler->sync($this);
		            			    	$_la = $this->input->LA(1);
		            			    }
		            			break;

		            			case 2:
		            			    $this->setState(1308);
		            			    $this->join_clause();
		            			break;
		            		}
		            	}
		            	$this->setState(1315);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::WHERE_) {
		            		$this->setState(1313);
		            		$this->match(self::WHERE_);
		            		$this->setState(1314);
		            		$this->recursiveExpr(0);
		            	}
		            	$this->setState(1331);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::GROUP_) {
		            		$this->setState(1317);
		            		$this->match(self::GROUP_);
		            		$this->setState(1318);
		            		$this->match(self::BY_);
		            		$this->setState(1319);
		            		$this->recursiveExpr(0);
		            		$this->setState(1324);
		            		$this->errorHandler->sync($this);

		            		$_la = $this->input->LA(1);
		            		while ($_la === self::COMMA) {
		            			$this->setState(1320);
		            			$this->match(self::COMMA);
		            			$this->setState(1321);
		            			$this->recursiveExpr(0);
		            			$this->setState(1326);
		            			$this->errorHandler->sync($this);
		            			$_la = $this->input->LA(1);
		            		}
		            		$this->setState(1329);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);

		            		if ($_la === self::HAVING_) {
		            			$this->setState(1327);
		            			$this->match(self::HAVING_);
		            			$this->setState(1328);
		            			$this->recursiveExpr(0);
		            		}
		            	}
		            	$this->setState(1347);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::WINDOW_) {
		            		$this->setState(1333);
		            		$this->match(self::WINDOW_);
		            		$this->setState(1334);
		            		$this->window_name();
		            		$this->setState(1335);
		            		$this->match(self::AS_);
		            		$this->setState(1336);
		            		$this->window_defn();
		            		$this->setState(1344);
		            		$this->errorHandler->sync($this);

		            		$_la = $this->input->LA(1);
		            		while ($_la === self::COMMA) {
		            			$this->setState(1337);
		            			$this->match(self::COMMA);
		            			$this->setState(1338);
		            			$this->window_name();
		            			$this->setState(1339);
		            			$this->match(self::AS_);
		            			$this->setState(1340);
		            			$this->window_defn();
		            			$this->setState(1346);
		            			$this->errorHandler->sync($this);
		            			$_la = $this->input->LA(1);
		            		}
		            	}
		            	break;

		            case self::VALUES_:
		            	$this->enterOuterAlt($localContext, 2);
		            	$this->setState(1349);
		            	$this->match(self::VALUES_);
		            	$this->setState(1350);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1351);
		            	$this->recursiveExpr(0);
		            	$this->setState(1356);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1352);
		            		$this->match(self::COMMA);
		            		$this->setState(1353);
		            		$this->recursiveExpr(0);
		            		$this->setState(1358);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(1359);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1374);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1360);
		            		$this->match(self::COMMA);
		            		$this->setState(1361);
		            		$this->match(self::OPEN_PAR);
		            		$this->setState(1362);
		            		$this->recursiveExpr(0);
		            		$this->setState(1367);
		            		$this->errorHandler->sync($this);

		            		$_la = $this->input->LA(1);
		            		while ($_la === self::COMMA) {
		            			$this->setState(1363);
		            			$this->match(self::COMMA);
		            			$this->setState(1364);
		            			$this->recursiveExpr(0);
		            			$this->setState(1369);
		            			$this->errorHandler->sync($this);
		            			$_la = $this->input->LA(1);
		            		}
		            		$this->setState(1370);
		            		$this->match(self::CLOSE_PAR);
		            		$this->setState(1376);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function factored_select_stmt(): Context\Factored_select_stmtContext
		{
		    $localContext = new Context\Factored_select_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 88, self::RULE_factored_select_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1379);
		        $this->select_stmt();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function simple_select_stmt(): Context\Simple_select_stmtContext
		{
		    $localContext = new Context\Simple_select_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 90, self::RULE_simple_select_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1382);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(1381);
		        	$this->common_table_stmt();
		        }
		        $this->setState(1384);
		        $this->select_core();
		        $this->setState(1386);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ORDER_) {
		        	$this->setState(1385);
		        	$this->order_by_stmt();
		        }
		        $this->setState(1389);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::LIMIT_) {
		        	$this->setState(1388);
		        	$this->limit_stmt();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function compound_select_stmt(): Context\Compound_select_stmtContext
		{
		    $localContext = new Context\Compound_select_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 92, self::RULE_compound_select_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1392);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(1391);
		        	$this->common_table_stmt();
		        }
		        $this->setState(1394);
		        $this->select_core();
		        $this->setState(1404); 
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        do {
		        	$this->setState(1401);
		        	$this->errorHandler->sync($this);

		        	switch ($this->input->LA(1)) {
		        	    case self::UNION_:
		        	    	$this->setState(1395);
		        	    	$this->match(self::UNION_);
		        	    	$this->setState(1397);
		        	    	$this->errorHandler->sync($this);
		        	    	$_la = $this->input->LA(1);

		        	    	if ($_la === self::ALL_) {
		        	    		$this->setState(1396);
		        	    		$this->match(self::ALL_);
		        	    	}
		        	    	break;

		        	    case self::INTERSECT_:
		        	    	$this->setState(1399);
		        	    	$this->match(self::INTERSECT_);
		        	    	break;

		        	    case self::EXCEPT_:
		        	    	$this->setState(1400);
		        	    	$this->match(self::EXCEPT_);
		        	    	break;

		        	default:
		        		throw new NoViableAltException($this);
		        	}
		        	$this->setState(1403);
		        	$this->select_core();
		        	$this->setState(1406); 
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        } while ($_la === self::EXCEPT_ || $_la === self::INTERSECT_ || $_la === self::UNION_);
		        $this->setState(1409);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ORDER_) {
		        	$this->setState(1408);
		        	$this->order_by_stmt();
		        }
		        $this->setState(1412);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::LIMIT_) {
		        	$this->setState(1411);
		        	$this->limit_stmt();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function table_or_subquery(): Context\Table_or_subqueryContext
		{
		    $localContext = new Context\Table_or_subqueryContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 94, self::RULE_table_or_subquery);

		    try {
		        $this->setState(1478);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 208, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(1417);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 196, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1414);
		        	    	    $this->schema_name();
		        	    	    $this->setState(1415);
		        	    	    $this->match(self::DOT);
		        	    	break;
		        	    }
		        	    $this->setState(1419);
		        	    $this->table_name();
		        	    $this->setState(1424);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 198, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1421);
		        	    	    $this->errorHandler->sync($this);

		        	    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 197, $this->ctx)) {
		        	    	        case 1:
		        	    	    	    $this->setState(1420);
		        	    	    	    $this->match(self::AS_);
		        	    	    	break;
		        	    	    }
		        	    	    $this->setState(1423);
		        	    	    $this->table_alias();
		        	    	break;
		        	    }
		        	    $this->setState(1431);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->input->LA(1)) {
		        	        case self::INDEXED_:
		        	        	$this->setState(1426);
		        	        	$this->match(self::INDEXED_);
		        	        	$this->setState(1427);
		        	        	$this->match(self::BY_);
		        	        	$this->setState(1428);
		        	        	$this->index_name();
		        	        	break;

		        	        case self::NOT_:
		        	        	$this->setState(1429);
		        	        	$this->match(self::NOT_);
		        	        	$this->setState(1430);
		        	        	$this->match(self::INDEXED_);
		        	        	break;

		        	        case self::EOF:
		        	        case self::SCOL:
		        	        case self::CLOSE_PAR:
		        	        case self::COMMA:
		        	        case self::ALTER_:
		        	        case self::ANALYZE_:
		        	        case self::ATTACH_:
		        	        case self::BEGIN_:
		        	        case self::COMMIT_:
		        	        case self::CREATE_:
		        	        case self::CROSS_:
		        	        case self::DELETE_:
		        	        case self::DETACH_:
		        	        case self::DROP_:
		        	        case self::END_:
		        	        case self::EXCEPT_:
		        	        case self::EXPLAIN_:
		        	        case self::GROUP_:
		        	        case self::INNER_:
		        	        case self::INSERT_:
		        	        case self::INTERSECT_:
		        	        case self::JOIN_:
		        	        case self::LEFT_:
		        	        case self::LIMIT_:
		        	        case self::NATURAL_:
		        	        case self::ON_:
		        	        case self::ORDER_:
		        	        case self::PRAGMA_:
		        	        case self::REINDEX_:
		        	        case self::RELEASE_:
		        	        case self::REPLACE_:
		        	        case self::RETURNING_:
		        	        case self::ROLLBACK_:
		        	        case self::SAVEPOINT_:
		        	        case self::SELECT_:
		        	        case self::UNION_:
		        	        case self::UPDATE_:
		        	        case self::USING_:
		        	        case self::VACUUM_:
		        	        case self::VALUES_:
		        	        case self::WHERE_:
		        	        case self::WITH_:
		        	        case self::WINDOW_:
		        	        	break;

		        	    default:
		        	    	break;
		        	    }
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(1436);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 200, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1433);
		        	    	    $this->schema_name();
		        	    	    $this->setState(1434);
		        	    	    $this->match(self::DOT);
		        	    	break;
		        	    }
		        	    $this->setState(1438);
		        	    $this->table_function_name();
		        	    $this->setState(1439);
		        	    $this->match(self::OPEN_PAR);
		        	    $this->setState(1440);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1445);
		        	    $this->errorHandler->sync($this);

		        	    $_la = $this->input->LA(1);
		        	    while ($_la === self::COMMA) {
		        	    	$this->setState(1441);
		        	    	$this->match(self::COMMA);
		        	    	$this->setState(1442);
		        	    	$this->recursiveExpr(0);
		        	    	$this->setState(1447);
		        	    	$this->errorHandler->sync($this);
		        	    	$_la = $this->input->LA(1);
		        	    }
		        	    $this->setState(1448);
		        	    $this->match(self::CLOSE_PAR);
		        	    $this->setState(1453);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 203, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1450);
		        	    	    $this->errorHandler->sync($this);

		        	    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 202, $this->ctx)) {
		        	    	        case 1:
		        	    	    	    $this->setState(1449);
		        	    	    	    $this->match(self::AS_);
		        	    	    	break;
		        	    	    }
		        	    	    $this->setState(1452);
		        	    	    $this->table_alias();
		        	    	break;
		        	    }
		        	break;

		        	case 3:
		        	    $this->enterOuterAlt($localContext, 3);
		        	    $this->setState(1455);
		        	    $this->match(self::OPEN_PAR);
		        	    $this->setState(1465);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 205, $this->ctx)) {
		        	    	case 1:
		        	    	    $this->setState(1456);
		        	    	    $this->table_or_subquery();
		        	    	    $this->setState(1461);
		        	    	    $this->errorHandler->sync($this);

		        	    	    $_la = $this->input->LA(1);
		        	    	    while ($_la === self::COMMA) {
		        	    	    	$this->setState(1457);
		        	    	    	$this->match(self::COMMA);
		        	    	    	$this->setState(1458);
		        	    	    	$this->table_or_subquery();
		        	    	    	$this->setState(1463);
		        	    	    	$this->errorHandler->sync($this);
		        	    	    	$_la = $this->input->LA(1);
		        	    	    }
		        	    	break;

		        	    	case 2:
		        	    	    $this->setState(1464);
		        	    	    $this->join_clause();
		        	    	break;
		        	    }
		        	    $this->setState(1467);
		        	    $this->match(self::CLOSE_PAR);
		        	break;

		        	case 4:
		        	    $this->enterOuterAlt($localContext, 4);
		        	    $this->setState(1469);
		        	    $this->match(self::OPEN_PAR);
		        	    $this->setState(1470);
		        	    $this->select_stmt();
		        	    $this->setState(1471);
		        	    $this->match(self::CLOSE_PAR);
		        	    $this->setState(1476);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 207, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1473);
		        	    	    $this->errorHandler->sync($this);

		        	    	    switch ($this->getInterpreter()->adaptivePredict($this->input, 206, $this->ctx)) {
		        	    	        case 1:
		        	    	    	    $this->setState(1472);
		        	    	    	    $this->match(self::AS_);
		        	    	    	break;
		        	    	    }
		        	    	    $this->setState(1475);
		        	    	    $this->table_alias();
		        	    	break;
		        	    }
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function result_column(): Context\Result_columnContext
		{
		    $localContext = new Context\Result_columnContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 96, self::RULE_result_column);

		    try {
		        $this->setState(1492);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 211, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(1480);
		        	    $this->match(self::STAR);
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(1481);
		        	    $this->table_name();
		        	    $this->setState(1482);
		        	    $this->match(self::DOT);
		        	    $this->setState(1483);
		        	    $this->match(self::STAR);
		        	break;

		        	case 3:
		        	    $this->enterOuterAlt($localContext, 3);
		        	    $this->setState(1485);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1490);
		        	    $this->errorHandler->sync($this);
		        	    $_la = $this->input->LA(1);

		        	    if ($_la === self::AS_ || $_la === self::IDENTIFIER || $_la === self::STRING_LITERAL) {
		        	    	$this->setState(1487);
		        	    	$this->errorHandler->sync($this);
		        	    	$_la = $this->input->LA(1);

		        	    	if ($_la === self::AS_) {
		        	    		$this->setState(1486);
		        	    		$this->match(self::AS_);
		        	    	}
		        	    	$this->setState(1489);
		        	    	$this->column_alias();
		        	    }
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function join_operator(): Context\Join_operatorContext
		{
		    $localContext = new Context\Join_operatorContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 98, self::RULE_join_operator);

		    try {
		        $this->setState(1507);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::COMMA:
		            	$this->enterOuterAlt($localContext, 1);
		            	$this->setState(1494);
		            	$this->match(self::COMMA);
		            	break;

		            case self::CROSS_:
		            case self::INNER_:
		            case self::JOIN_:
		            case self::LEFT_:
		            case self::NATURAL_:
		            	$this->enterOuterAlt($localContext, 2);
		            	$this->setState(1496);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::NATURAL_) {
		            		$this->setState(1495);
		            		$this->match(self::NATURAL_);
		            	}
		            	$this->setState(1504);
		            	$this->errorHandler->sync($this);

		            	switch ($this->input->LA(1)) {
		            	    case self::LEFT_:
		            	    	$this->setState(1498);
		            	    	$this->match(self::LEFT_);
		            	    	$this->setState(1500);
		            	    	$this->errorHandler->sync($this);
		            	    	$_la = $this->input->LA(1);

		            	    	if ($_la === self::OUTER_) {
		            	    		$this->setState(1499);
		            	    		$this->match(self::OUTER_);
		            	    	}
		            	    	break;

		            	    case self::INNER_:
		            	    	$this->setState(1502);
		            	    	$this->match(self::INNER_);
		            	    	break;

		            	    case self::CROSS_:
		            	    	$this->setState(1503);
		            	    	$this->match(self::CROSS_);
		            	    	break;

		            	    case self::JOIN_:
		            	    	break;

		            	default:
		            		break;
		            	}
		            	$this->setState(1506);
		            	$this->match(self::JOIN_);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function join_constraint(): Context\Join_constraintContext
		{
		    $localContext = new Context\Join_constraintContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 100, self::RULE_join_constraint);

		    try {
		        $this->setState(1523);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::ON_:
		            	$this->enterOuterAlt($localContext, 1);
		            	$this->setState(1509);
		            	$this->match(self::ON_);
		            	$this->setState(1510);
		            	$this->recursiveExpr(0);
		            	break;

		            case self::USING_:
		            	$this->enterOuterAlt($localContext, 2);
		            	$this->setState(1511);
		            	$this->match(self::USING_);
		            	$this->setState(1512);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1513);
		            	$this->column_name();
		            	$this->setState(1518);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1514);
		            		$this->match(self::COMMA);
		            		$this->setState(1515);
		            		$this->column_name();
		            		$this->setState(1520);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	$this->setState(1521);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function compound_operator(): Context\Compound_operatorContext
		{
		    $localContext = new Context\Compound_operatorContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 102, self::RULE_compound_operator);

		    try {
		        $this->setState(1531);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::UNION_:
		            	$this->enterOuterAlt($localContext, 1);
		            	$this->setState(1525);
		            	$this->match(self::UNION_);
		            	$this->setState(1527);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ALL_) {
		            		$this->setState(1526);
		            		$this->match(self::ALL_);
		            	}
		            	break;

		            case self::INTERSECT_:
		            	$this->enterOuterAlt($localContext, 2);
		            	$this->setState(1529);
		            	$this->match(self::INTERSECT_);
		            	break;

		            case self::EXCEPT_:
		            	$this->enterOuterAlt($localContext, 3);
		            	$this->setState(1530);
		            	$this->match(self::EXCEPT_);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function update_stmt(): Context\Update_stmtContext
		{
		    $localContext = new Context\Update_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 104, self::RULE_update_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1534);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(1533);
		        	$this->with_clause();
		        }
		        $this->setState(1536);
		        $this->match(self::UPDATE_);
		        $this->setState(1539);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 221, $this->ctx)) {
		            case 1:
		        	    $this->setState(1537);
		        	    $this->match(self::OR_);
		        	    $this->setState(1538);

		        	    $_la = $this->input->LA(1);

		        	    if (!($_la === self::ABORT_ || ((($_la - 72)) & ~0x3f) === 0 && ((1 << ($_la - 72)) & 19140298416325121) !== 0)) {
		        	    $this->errorHandler->recoverInline($this);
		        	    } else {
		        	    	if ($this->input->LA(1) === Token::EOF) {
		        	    	    $this->matchedEOF = true;
		        	        }

		        	    	$this->errorHandler->reportMatch($this);
		        	    	$this->consume();
		        	    }
		        	break;
		        }
		        $this->setState(1541);
		        $this->qualified_table_name();
		        $this->setState(1542);
		        $this->match(self::SET_);
		        $this->setState(1545);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 222, $this->ctx)) {
		        	case 1:
		        	    $this->setState(1543);
		        	    $this->column_name();
		        	break;

		        	case 2:
		        	    $this->setState(1544);
		        	    $this->column_name_list();
		        	break;
		        }
		        $this->setState(1547);
		        $this->match(self::ASSIGN);
		        $this->setState(1548);
		        $this->recursiveExpr(0);
		        $this->setState(1559);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1549);
		        	$this->match(self::COMMA);
		        	$this->setState(1552);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 223, $this->ctx)) {
		        		case 1:
		        		    $this->setState(1550);
		        		    $this->column_name();
		        		break;

		        		case 2:
		        		    $this->setState(1551);
		        		    $this->column_name_list();
		        		break;
		        	}
		        	$this->setState(1554);
		        	$this->match(self::ASSIGN);
		        	$this->setState(1555);
		        	$this->recursiveExpr(0);
		        	$this->setState(1561);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(1574);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::FROM_) {
		        	$this->setState(1562);
		        	$this->match(self::FROM_);
		        	$this->setState(1572);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 226, $this->ctx)) {
		        		case 1:
		        		    $this->setState(1563);
		        		    $this->table_or_subquery();
		        		    $this->setState(1568);
		        		    $this->errorHandler->sync($this);

		        		    $_la = $this->input->LA(1);
		        		    while ($_la === self::COMMA) {
		        		    	$this->setState(1564);
		        		    	$this->match(self::COMMA);
		        		    	$this->setState(1565);
		        		    	$this->table_or_subquery();
		        		    	$this->setState(1570);
		        		    	$this->errorHandler->sync($this);
		        		    	$_la = $this->input->LA(1);
		        		    }
		        		break;

		        		case 2:
		        		    $this->setState(1571);
		        		    $this->join_clause();
		        		break;
		        	}
		        }
		        $this->setState(1578);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WHERE_) {
		        	$this->setState(1576);
		        	$this->match(self::WHERE_);
		        	$this->setState(1577);
		        	$this->recursiveExpr(0);
		        }
		        $this->setState(1581);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::RETURNING_) {
		        	$this->setState(1580);
		        	$this->returning_clause();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function column_name_list(): Context\Column_name_listContext
		{
		    $localContext = new Context\Column_name_listContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 106, self::RULE_column_name_list);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1583);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1584);
		        $this->column_name();
		        $this->setState(1589);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1585);
		        	$this->match(self::COMMA);
		        	$this->setState(1586);
		        	$this->column_name();
		        	$this->setState(1591);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(1592);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function update_stmt_limited(): Context\Update_stmt_limitedContext
		{
		    $localContext = new Context\Update_stmt_limitedContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 108, self::RULE_update_stmt_limited);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1595);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WITH_) {
		        	$this->setState(1594);
		        	$this->with_clause();
		        }
		        $this->setState(1597);
		        $this->match(self::UPDATE_);
		        $this->setState(1600);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 232, $this->ctx)) {
		            case 1:
		        	    $this->setState(1598);
		        	    $this->match(self::OR_);
		        	    $this->setState(1599);

		        	    $_la = $this->input->LA(1);

		        	    if (!($_la === self::ABORT_ || ((($_la - 72)) & ~0x3f) === 0 && ((1 << ($_la - 72)) & 19140298416325121) !== 0)) {
		        	    $this->errorHandler->recoverInline($this);
		        	    } else {
		        	    	if ($this->input->LA(1) === Token::EOF) {
		        	    	    $this->matchedEOF = true;
		        	        }

		        	    	$this->errorHandler->reportMatch($this);
		        	    	$this->consume();
		        	    }
		        	break;
		        }
		        $this->setState(1602);
		        $this->qualified_table_name();
		        $this->setState(1603);
		        $this->match(self::SET_);
		        $this->setState(1606);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 233, $this->ctx)) {
		        	case 1:
		        	    $this->setState(1604);
		        	    $this->column_name();
		        	break;

		        	case 2:
		        	    $this->setState(1605);
		        	    $this->column_name_list();
		        	break;
		        }
		        $this->setState(1608);
		        $this->match(self::ASSIGN);
		        $this->setState(1609);
		        $this->recursiveExpr(0);
		        $this->setState(1620);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1610);
		        	$this->match(self::COMMA);
		        	$this->setState(1613);
		        	$this->errorHandler->sync($this);

		        	switch ($this->getInterpreter()->adaptivePredict($this->input, 234, $this->ctx)) {
		        		case 1:
		        		    $this->setState(1611);
		        		    $this->column_name();
		        		break;

		        		case 2:
		        		    $this->setState(1612);
		        		    $this->column_name_list();
		        		break;
		        	}
		        	$this->setState(1615);
		        	$this->match(self::ASSIGN);
		        	$this->setState(1616);
		        	$this->recursiveExpr(0);
		        	$this->setState(1622);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(1625);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::WHERE_) {
		        	$this->setState(1623);
		        	$this->match(self::WHERE_);
		        	$this->setState(1624);
		        	$this->recursiveExpr(0);
		        }
		        $this->setState(1628);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::RETURNING_) {
		        	$this->setState(1627);
		        	$this->returning_clause();
		        }
		        $this->setState(1634);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::LIMIT_ || $_la === self::ORDER_) {
		        	$this->setState(1631);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);

		        	if ($_la === self::ORDER_) {
		        		$this->setState(1630);
		        		$this->order_by_stmt();
		        	}
		        	$this->setState(1633);
		        	$this->limit_stmt();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function qualified_table_name(): Context\Qualified_table_nameContext
		{
		    $localContext = new Context\Qualified_table_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 110, self::RULE_qualified_table_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1639);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 240, $this->ctx)) {
		            case 1:
		        	    $this->setState(1636);
		        	    $this->schema_name();
		        	    $this->setState(1637);
		        	    $this->match(self::DOT);
		        	break;
		        }
		        $this->setState(1641);
		        $this->table_name();
		        $this->setState(1644);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::AS_) {
		        	$this->setState(1642);
		        	$this->match(self::AS_);
		        	$this->setState(1643);
		        	$this->alias();
		        }
		        $this->setState(1651);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::INDEXED_:
		            	$this->setState(1646);
		            	$this->match(self::INDEXED_);
		            	$this->setState(1647);
		            	$this->match(self::BY_);
		            	$this->setState(1648);
		            	$this->index_name();
		            	break;

		            case self::NOT_:
		            	$this->setState(1649);
		            	$this->match(self::NOT_);
		            	$this->setState(1650);
		            	$this->match(self::INDEXED_);
		            	break;

		            case self::EOF:
		            case self::SCOL:
		            case self::ALTER_:
		            case self::ANALYZE_:
		            case self::ATTACH_:
		            case self::BEGIN_:
		            case self::COMMIT_:
		            case self::CREATE_:
		            case self::DELETE_:
		            case self::DETACH_:
		            case self::DROP_:
		            case self::END_:
		            case self::EXPLAIN_:
		            case self::INSERT_:
		            case self::LIMIT_:
		            case self::ORDER_:
		            case self::PRAGMA_:
		            case self::REINDEX_:
		            case self::RELEASE_:
		            case self::REPLACE_:
		            case self::RETURNING_:
		            case self::ROLLBACK_:
		            case self::SAVEPOINT_:
		            case self::SELECT_:
		            case self::SET_:
		            case self::UPDATE_:
		            case self::VACUUM_:
		            case self::VALUES_:
		            case self::WHERE_:
		            case self::WITH_:
		            	break;

		        default:
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function vacuum_stmt(): Context\Vacuum_stmtContext
		{
		    $localContext = new Context\Vacuum_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 112, self::RULE_vacuum_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1653);
		        $this->match(self::VACUUM_);
		        $this->setState(1655);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 243, $this->ctx)) {
		            case 1:
		        	    $this->setState(1654);
		        	    $this->schema_name();
		        	break;
		        }
		        $this->setState(1659);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::INTO_) {
		        	$this->setState(1657);
		        	$this->match(self::INTO_);
		        	$this->setState(1658);
		        	$this->filename();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function filter_clause(): Context\Filter_clauseContext
		{
		    $localContext = new Context\Filter_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 114, self::RULE_filter_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1661);
		        $this->match(self::FILTER_);
		        $this->setState(1662);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1663);
		        $this->match(self::WHERE_);
		        $this->setState(1664);
		        $this->recursiveExpr(0);
		        $this->setState(1665);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function window_defn(): Context\Window_defnContext
		{
		    $localContext = new Context\Window_defnContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 116, self::RULE_window_defn);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1667);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1669);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 245, $this->ctx)) {
		            case 1:
		        	    $this->setState(1668);
		        	    $this->base_window_name();
		        	break;
		        }
		        $this->setState(1681);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::PARTITION_) {
		        	$this->setState(1671);
		        	$this->match(self::PARTITION_);
		        	$this->setState(1672);
		        	$this->match(self::BY_);
		        	$this->setState(1673);
		        	$this->recursiveExpr(0);
		        	$this->setState(1678);
		        	$this->errorHandler->sync($this);

		        	$_la = $this->input->LA(1);
		        	while ($_la === self::COMMA) {
		        		$this->setState(1674);
		        		$this->match(self::COMMA);
		        		$this->setState(1675);
		        		$this->recursiveExpr(0);
		        		$this->setState(1680);
		        		$this->errorHandler->sync($this);
		        		$_la = $this->input->LA(1);
		        	}
		        }

		        $this->setState(1683);
		        $this->match(self::ORDER_);
		        $this->setState(1684);
		        $this->match(self::BY_);
		        $this->setState(1685);
		        $this->ordering_term();
		        $this->setState(1690);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1686);
		        	$this->match(self::COMMA);
		        	$this->setState(1687);
		        	$this->ordering_term();
		        	$this->setState(1692);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		        $this->setState(1694);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if (((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 2251799880794113) !== 0) {
		        	$this->setState(1693);
		        	$this->frame_spec();
		        }
		        $this->setState(1696);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function over_clause(): Context\Over_clauseContext
		{
		    $localContext = new Context\Over_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 118, self::RULE_over_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1698);
		        $this->match(self::OVER_);
		        $this->setState(1732);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 256, $this->ctx)) {
		        	case 1:
		        	    $this->setState(1699);
		        	    $this->window_name();
		        	break;

		        	case 2:
		        	    $this->setState(1700);
		        	    $this->match(self::OPEN_PAR);
		        	    $this->setState(1702);
		        	    $this->errorHandler->sync($this);

		        	    switch ($this->getInterpreter()->adaptivePredict($this->input, 250, $this->ctx)) {
		        	        case 1:
		        	    	    $this->setState(1701);
		        	    	    $this->base_window_name();
		        	    	break;
		        	    }
		        	    $this->setState(1714);
		        	    $this->errorHandler->sync($this);
		        	    $_la = $this->input->LA(1);

		        	    if ($_la === self::PARTITION_) {
		        	    	$this->setState(1704);
		        	    	$this->match(self::PARTITION_);
		        	    	$this->setState(1705);
		        	    	$this->match(self::BY_);
		        	    	$this->setState(1706);
		        	    	$this->recursiveExpr(0);
		        	    	$this->setState(1711);
		        	    	$this->errorHandler->sync($this);

		        	    	$_la = $this->input->LA(1);
		        	    	while ($_la === self::COMMA) {
		        	    		$this->setState(1707);
		        	    		$this->match(self::COMMA);
		        	    		$this->setState(1708);
		        	    		$this->recursiveExpr(0);
		        	    		$this->setState(1713);
		        	    		$this->errorHandler->sync($this);
		        	    		$_la = $this->input->LA(1);
		        	    	}
		        	    }
		        	    $this->setState(1726);
		        	    $this->errorHandler->sync($this);
		        	    $_la = $this->input->LA(1);

		        	    if ($_la === self::ORDER_) {
		        	    	$this->setState(1716);
		        	    	$this->match(self::ORDER_);
		        	    	$this->setState(1717);
		        	    	$this->match(self::BY_);
		        	    	$this->setState(1718);
		        	    	$this->ordering_term();
		        	    	$this->setState(1723);
		        	    	$this->errorHandler->sync($this);

		        	    	$_la = $this->input->LA(1);
		        	    	while ($_la === self::COMMA) {
		        	    		$this->setState(1719);
		        	    		$this->match(self::COMMA);
		        	    		$this->setState(1720);
		        	    		$this->ordering_term();
		        	    		$this->setState(1725);
		        	    		$this->errorHandler->sync($this);
		        	    		$_la = $this->input->LA(1);
		        	    	}
		        	    }
		        	    $this->setState(1729);
		        	    $this->errorHandler->sync($this);
		        	    $_la = $this->input->LA(1);

		        	    if (((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 2251799880794113) !== 0) {
		        	    	$this->setState(1728);
		        	    	$this->frame_spec();
		        	    }
		        	    $this->setState(1731);
		        	    $this->match(self::CLOSE_PAR);
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function frame_spec(): Context\Frame_specContext
		{
		    $localContext = new Context\Frame_specContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 120, self::RULE_frame_spec);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1734);
		        $this->frame_clause();
		        $this->setState(1742);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::EXCLUDE_:
		            	$this->setState(1735);
		            	$this->match(self::EXCLUDE_);

		            	$this->setState(1736);
		            	$this->match(self::NO_);
		            	$this->setState(1737);
		            	$this->match(self::OTHERS_);
		            	break;

		            case self::CURRENT_:
		            	$this->setState(1738);
		            	$this->match(self::CURRENT_);
		            	$this->setState(1739);
		            	$this->match(self::ROW_);
		            	break;

		            case self::GROUP_:
		            	$this->setState(1740);
		            	$this->match(self::GROUP_);
		            	break;

		            case self::TIES_:
		            	$this->setState(1741);
		            	$this->match(self::TIES_);
		            	break;

		            case self::CLOSE_PAR:
		            	break;

		        default:
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function frame_clause(): Context\Frame_clauseContext
		{
		    $localContext = new Context\Frame_clauseContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 122, self::RULE_frame_clause);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1744);

		        $_la = $this->input->LA(1);

		        if (!(((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 2251799880794113) !== 0)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		        $this->setState(1751);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 258, $this->ctx)) {
		        	case 1:
		        	    $this->setState(1745);
		        	    $this->frame_single();
		        	break;

		        	case 2:
		        	    $this->setState(1746);
		        	    $this->match(self::BETWEEN_);
		        	    $this->setState(1747);
		        	    $this->frame_left();
		        	    $this->setState(1748);
		        	    $this->match(self::AND_);
		        	    $this->setState(1749);
		        	    $this->frame_right();
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function simple_function_invocation(): Context\Simple_function_invocationContext
		{
		    $localContext = new Context\Simple_function_invocationContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 124, self::RULE_simple_function_invocation);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1753);
		        $this->simple_func();
		        $this->setState(1754);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1764);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::OPEN_PAR:
		            case self::PLUS:
		            case self::MINUS:
		            case self::TILDE:
		            case self::ABORT_:
		            case self::ACTION_:
		            case self::ADD_:
		            case self::AFTER_:
		            case self::ALL_:
		            case self::ALTER_:
		            case self::ANALYZE_:
		            case self::AND_:
		            case self::AS_:
		            case self::ASC_:
		            case self::ATTACH_:
		            case self::AUTOINCREMENT_:
		            case self::BEFORE_:
		            case self::BEGIN_:
		            case self::BETWEEN_:
		            case self::BY_:
		            case self::CASCADE_:
		            case self::CASE_:
		            case self::CAST_:
		            case self::CHECK_:
		            case self::COLLATE_:
		            case self::COLUMN_:
		            case self::COMMIT_:
		            case self::CONFLICT_:
		            case self::CONSTRAINT_:
		            case self::CREATE_:
		            case self::CROSS_:
		            case self::CURRENT_DATE_:
		            case self::CURRENT_TIME_:
		            case self::CURRENT_TIMESTAMP_:
		            case self::DATABASE_:
		            case self::DEFAULT_:
		            case self::DEFERRABLE_:
		            case self::DEFERRED_:
		            case self::DELETE_:
		            case self::DESC_:
		            case self::DETACH_:
		            case self::DISTINCT_:
		            case self::DROP_:
		            case self::EACH_:
		            case self::ELSE_:
		            case self::END_:
		            case self::ESCAPE_:
		            case self::EXCEPT_:
		            case self::EXCLUSIVE_:
		            case self::EXISTS_:
		            case self::EXPLAIN_:
		            case self::FAIL_:
		            case self::FOR_:
		            case self::FOREIGN_:
		            case self::FROM_:
		            case self::FULL_:
		            case self::GLOB_:
		            case self::GROUP_:
		            case self::HAVING_:
		            case self::IF_:
		            case self::IGNORE_:
		            case self::IMMEDIATE_:
		            case self::IN_:
		            case self::INDEX_:
		            case self::INDEXED_:
		            case self::INITIALLY_:
		            case self::INNER_:
		            case self::INSERT_:
		            case self::INSTEAD_:
		            case self::INTERSECT_:
		            case self::INTO_:
		            case self::IS_:
		            case self::ISNULL_:
		            case self::JOIN_:
		            case self::KEY_:
		            case self::LEFT_:
		            case self::LIKE_:
		            case self::LIMIT_:
		            case self::MATCH_:
		            case self::NATURAL_:
		            case self::NO_:
		            case self::NOT_:
		            case self::NOTNULL_:
		            case self::NULL_:
		            case self::OF_:
		            case self::OFFSET_:
		            case self::ON_:
		            case self::OR_:
		            case self::ORDER_:
		            case self::OUTER_:
		            case self::PLAN_:
		            case self::PRAGMA_:
		            case self::PRIMARY_:
		            case self::QUERY_:
		            case self::RAISE_:
		            case self::RECURSIVE_:
		            case self::REFERENCES_:
		            case self::REGEXP_:
		            case self::REINDEX_:
		            case self::RELEASE_:
		            case self::RENAME_:
		            case self::REPLACE_:
		            case self::RESTRICT_:
		            case self::RIGHT_:
		            case self::ROLLBACK_:
		            case self::ROW_:
		            case self::ROWS_:
		            case self::SAVEPOINT_:
		            case self::SELECT_:
		            case self::SET_:
		            case self::TABLE_:
		            case self::TEMP_:
		            case self::TEMPORARY_:
		            case self::THEN_:
		            case self::TO_:
		            case self::TRANSACTION_:
		            case self::TRIGGER_:
		            case self::UNION_:
		            case self::UNIQUE_:
		            case self::UPDATE_:
		            case self::USING_:
		            case self::VACUUM_:
		            case self::VALUES_:
		            case self::VIEW_:
		            case self::VIRTUAL_:
		            case self::WHEN_:
		            case self::WHERE_:
		            case self::WITH_:
		            case self::WITHOUT_:
		            case self::FIRST_VALUE_:
		            case self::OVER_:
		            case self::PARTITION_:
		            case self::RANGE_:
		            case self::PRECEDING_:
		            case self::UNBOUNDED_:
		            case self::CURRENT_:
		            case self::FOLLOWING_:
		            case self::CUME_DIST_:
		            case self::DENSE_RANK_:
		            case self::LAG_:
		            case self::LAST_VALUE_:
		            case self::LEAD_:
		            case self::NTH_VALUE_:
		            case self::NTILE_:
		            case self::PERCENT_RANK_:
		            case self::RANK_:
		            case self::ROW_NUMBER_:
		            case self::GENERATED_:
		            case self::ALWAYS_:
		            case self::STORED_:
		            case self::TRUE_:
		            case self::FALSE_:
		            case self::WINDOW_:
		            case self::NULLS_:
		            case self::FIRST_:
		            case self::LAST_:
		            case self::FILTER_:
		            case self::GROUPS_:
		            case self::EXCLUDE_:
		            case self::IDENTIFIER:
		            case self::NUMERIC_LITERAL:
		            case self::BIND_PARAMETER:
		            case self::STRING_LITERAL:
		            case self::BLOB_LITERAL:
		            	$this->setState(1755);
		            	$this->recursiveExpr(0);
		            	$this->setState(1760);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1756);
		            		$this->match(self::COMMA);
		            		$this->setState(1757);
		            		$this->recursiveExpr(0);
		            		$this->setState(1762);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	break;

		            case self::STAR:
		            	$this->setState(1763);
		            	$this->match(self::STAR);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		        $this->setState(1766);
		        $this->match(self::CLOSE_PAR);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function aggregate_function_invocation(): Context\Aggregate_function_invocationContext
		{
		    $localContext = new Context\Aggregate_function_invocationContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 126, self::RULE_aggregate_function_invocation);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1768);
		        $this->aggregate_func();
		        $this->setState(1769);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1782);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::OPEN_PAR:
		            case self::PLUS:
		            case self::MINUS:
		            case self::TILDE:
		            case self::ABORT_:
		            case self::ACTION_:
		            case self::ADD_:
		            case self::AFTER_:
		            case self::ALL_:
		            case self::ALTER_:
		            case self::ANALYZE_:
		            case self::AND_:
		            case self::AS_:
		            case self::ASC_:
		            case self::ATTACH_:
		            case self::AUTOINCREMENT_:
		            case self::BEFORE_:
		            case self::BEGIN_:
		            case self::BETWEEN_:
		            case self::BY_:
		            case self::CASCADE_:
		            case self::CASE_:
		            case self::CAST_:
		            case self::CHECK_:
		            case self::COLLATE_:
		            case self::COLUMN_:
		            case self::COMMIT_:
		            case self::CONFLICT_:
		            case self::CONSTRAINT_:
		            case self::CREATE_:
		            case self::CROSS_:
		            case self::CURRENT_DATE_:
		            case self::CURRENT_TIME_:
		            case self::CURRENT_TIMESTAMP_:
		            case self::DATABASE_:
		            case self::DEFAULT_:
		            case self::DEFERRABLE_:
		            case self::DEFERRED_:
		            case self::DELETE_:
		            case self::DESC_:
		            case self::DETACH_:
		            case self::DISTINCT_:
		            case self::DROP_:
		            case self::EACH_:
		            case self::ELSE_:
		            case self::END_:
		            case self::ESCAPE_:
		            case self::EXCEPT_:
		            case self::EXCLUSIVE_:
		            case self::EXISTS_:
		            case self::EXPLAIN_:
		            case self::FAIL_:
		            case self::FOR_:
		            case self::FOREIGN_:
		            case self::FROM_:
		            case self::FULL_:
		            case self::GLOB_:
		            case self::GROUP_:
		            case self::HAVING_:
		            case self::IF_:
		            case self::IGNORE_:
		            case self::IMMEDIATE_:
		            case self::IN_:
		            case self::INDEX_:
		            case self::INDEXED_:
		            case self::INITIALLY_:
		            case self::INNER_:
		            case self::INSERT_:
		            case self::INSTEAD_:
		            case self::INTERSECT_:
		            case self::INTO_:
		            case self::IS_:
		            case self::ISNULL_:
		            case self::JOIN_:
		            case self::KEY_:
		            case self::LEFT_:
		            case self::LIKE_:
		            case self::LIMIT_:
		            case self::MATCH_:
		            case self::NATURAL_:
		            case self::NO_:
		            case self::NOT_:
		            case self::NOTNULL_:
		            case self::NULL_:
		            case self::OF_:
		            case self::OFFSET_:
		            case self::ON_:
		            case self::OR_:
		            case self::ORDER_:
		            case self::OUTER_:
		            case self::PLAN_:
		            case self::PRAGMA_:
		            case self::PRIMARY_:
		            case self::QUERY_:
		            case self::RAISE_:
		            case self::RECURSIVE_:
		            case self::REFERENCES_:
		            case self::REGEXP_:
		            case self::REINDEX_:
		            case self::RELEASE_:
		            case self::RENAME_:
		            case self::REPLACE_:
		            case self::RESTRICT_:
		            case self::RIGHT_:
		            case self::ROLLBACK_:
		            case self::ROW_:
		            case self::ROWS_:
		            case self::SAVEPOINT_:
		            case self::SELECT_:
		            case self::SET_:
		            case self::TABLE_:
		            case self::TEMP_:
		            case self::TEMPORARY_:
		            case self::THEN_:
		            case self::TO_:
		            case self::TRANSACTION_:
		            case self::TRIGGER_:
		            case self::UNION_:
		            case self::UNIQUE_:
		            case self::UPDATE_:
		            case self::USING_:
		            case self::VACUUM_:
		            case self::VALUES_:
		            case self::VIEW_:
		            case self::VIRTUAL_:
		            case self::WHEN_:
		            case self::WHERE_:
		            case self::WITH_:
		            case self::WITHOUT_:
		            case self::FIRST_VALUE_:
		            case self::OVER_:
		            case self::PARTITION_:
		            case self::RANGE_:
		            case self::PRECEDING_:
		            case self::UNBOUNDED_:
		            case self::CURRENT_:
		            case self::FOLLOWING_:
		            case self::CUME_DIST_:
		            case self::DENSE_RANK_:
		            case self::LAG_:
		            case self::LAST_VALUE_:
		            case self::LEAD_:
		            case self::NTH_VALUE_:
		            case self::NTILE_:
		            case self::PERCENT_RANK_:
		            case self::RANK_:
		            case self::ROW_NUMBER_:
		            case self::GENERATED_:
		            case self::ALWAYS_:
		            case self::STORED_:
		            case self::TRUE_:
		            case self::FALSE_:
		            case self::WINDOW_:
		            case self::NULLS_:
		            case self::FIRST_:
		            case self::LAST_:
		            case self::FILTER_:
		            case self::GROUPS_:
		            case self::EXCLUDE_:
		            case self::IDENTIFIER:
		            case self::NUMERIC_LITERAL:
		            case self::BIND_PARAMETER:
		            case self::STRING_LITERAL:
		            case self::BLOB_LITERAL:
		            	$this->setState(1771);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 261, $this->ctx)) {
		            	    case 1:
		            		    $this->setState(1770);
		            		    $this->match(self::DISTINCT_);
		            		break;
		            	}
		            	$this->setState(1773);
		            	$this->recursiveExpr(0);
		            	$this->setState(1778);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1774);
		            		$this->match(self::COMMA);
		            		$this->setState(1775);
		            		$this->recursiveExpr(0);
		            		$this->setState(1780);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	break;

		            case self::STAR:
		            	$this->setState(1781);
		            	$this->match(self::STAR);
		            	break;

		            case self::CLOSE_PAR:
		            	break;

		        default:
		        	break;
		        }
		        $this->setState(1784);
		        $this->match(self::CLOSE_PAR);
		        $this->setState(1786);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::FILTER_) {
		        	$this->setState(1785);
		        	$this->filter_clause();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function window_function_invocation(): Context\Window_function_invocationContext
		{
		    $localContext = new Context\Window_function_invocationContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 128, self::RULE_window_function_invocation);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1788);
		        $this->window_function();
		        $this->setState(1789);
		        $this->match(self::OPEN_PAR);
		        $this->setState(1799);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::OPEN_PAR:
		            case self::PLUS:
		            case self::MINUS:
		            case self::TILDE:
		            case self::ABORT_:
		            case self::ACTION_:
		            case self::ADD_:
		            case self::AFTER_:
		            case self::ALL_:
		            case self::ALTER_:
		            case self::ANALYZE_:
		            case self::AND_:
		            case self::AS_:
		            case self::ASC_:
		            case self::ATTACH_:
		            case self::AUTOINCREMENT_:
		            case self::BEFORE_:
		            case self::BEGIN_:
		            case self::BETWEEN_:
		            case self::BY_:
		            case self::CASCADE_:
		            case self::CASE_:
		            case self::CAST_:
		            case self::CHECK_:
		            case self::COLLATE_:
		            case self::COLUMN_:
		            case self::COMMIT_:
		            case self::CONFLICT_:
		            case self::CONSTRAINT_:
		            case self::CREATE_:
		            case self::CROSS_:
		            case self::CURRENT_DATE_:
		            case self::CURRENT_TIME_:
		            case self::CURRENT_TIMESTAMP_:
		            case self::DATABASE_:
		            case self::DEFAULT_:
		            case self::DEFERRABLE_:
		            case self::DEFERRED_:
		            case self::DELETE_:
		            case self::DESC_:
		            case self::DETACH_:
		            case self::DISTINCT_:
		            case self::DROP_:
		            case self::EACH_:
		            case self::ELSE_:
		            case self::END_:
		            case self::ESCAPE_:
		            case self::EXCEPT_:
		            case self::EXCLUSIVE_:
		            case self::EXISTS_:
		            case self::EXPLAIN_:
		            case self::FAIL_:
		            case self::FOR_:
		            case self::FOREIGN_:
		            case self::FROM_:
		            case self::FULL_:
		            case self::GLOB_:
		            case self::GROUP_:
		            case self::HAVING_:
		            case self::IF_:
		            case self::IGNORE_:
		            case self::IMMEDIATE_:
		            case self::IN_:
		            case self::INDEX_:
		            case self::INDEXED_:
		            case self::INITIALLY_:
		            case self::INNER_:
		            case self::INSERT_:
		            case self::INSTEAD_:
		            case self::INTERSECT_:
		            case self::INTO_:
		            case self::IS_:
		            case self::ISNULL_:
		            case self::JOIN_:
		            case self::KEY_:
		            case self::LEFT_:
		            case self::LIKE_:
		            case self::LIMIT_:
		            case self::MATCH_:
		            case self::NATURAL_:
		            case self::NO_:
		            case self::NOT_:
		            case self::NOTNULL_:
		            case self::NULL_:
		            case self::OF_:
		            case self::OFFSET_:
		            case self::ON_:
		            case self::OR_:
		            case self::ORDER_:
		            case self::OUTER_:
		            case self::PLAN_:
		            case self::PRAGMA_:
		            case self::PRIMARY_:
		            case self::QUERY_:
		            case self::RAISE_:
		            case self::RECURSIVE_:
		            case self::REFERENCES_:
		            case self::REGEXP_:
		            case self::REINDEX_:
		            case self::RELEASE_:
		            case self::RENAME_:
		            case self::REPLACE_:
		            case self::RESTRICT_:
		            case self::RIGHT_:
		            case self::ROLLBACK_:
		            case self::ROW_:
		            case self::ROWS_:
		            case self::SAVEPOINT_:
		            case self::SELECT_:
		            case self::SET_:
		            case self::TABLE_:
		            case self::TEMP_:
		            case self::TEMPORARY_:
		            case self::THEN_:
		            case self::TO_:
		            case self::TRANSACTION_:
		            case self::TRIGGER_:
		            case self::UNION_:
		            case self::UNIQUE_:
		            case self::UPDATE_:
		            case self::USING_:
		            case self::VACUUM_:
		            case self::VALUES_:
		            case self::VIEW_:
		            case self::VIRTUAL_:
		            case self::WHEN_:
		            case self::WHERE_:
		            case self::WITH_:
		            case self::WITHOUT_:
		            case self::FIRST_VALUE_:
		            case self::OVER_:
		            case self::PARTITION_:
		            case self::RANGE_:
		            case self::PRECEDING_:
		            case self::UNBOUNDED_:
		            case self::CURRENT_:
		            case self::FOLLOWING_:
		            case self::CUME_DIST_:
		            case self::DENSE_RANK_:
		            case self::LAG_:
		            case self::LAST_VALUE_:
		            case self::LEAD_:
		            case self::NTH_VALUE_:
		            case self::NTILE_:
		            case self::PERCENT_RANK_:
		            case self::RANK_:
		            case self::ROW_NUMBER_:
		            case self::GENERATED_:
		            case self::ALWAYS_:
		            case self::STORED_:
		            case self::TRUE_:
		            case self::FALSE_:
		            case self::WINDOW_:
		            case self::NULLS_:
		            case self::FIRST_:
		            case self::LAST_:
		            case self::FILTER_:
		            case self::GROUPS_:
		            case self::EXCLUDE_:
		            case self::IDENTIFIER:
		            case self::NUMERIC_LITERAL:
		            case self::BIND_PARAMETER:
		            case self::STRING_LITERAL:
		            case self::BLOB_LITERAL:
		            	$this->setState(1790);
		            	$this->recursiveExpr(0);
		            	$this->setState(1795);
		            	$this->errorHandler->sync($this);

		            	$_la = $this->input->LA(1);
		            	while ($_la === self::COMMA) {
		            		$this->setState(1791);
		            		$this->match(self::COMMA);
		            		$this->setState(1792);
		            		$this->recursiveExpr(0);
		            		$this->setState(1797);
		            		$this->errorHandler->sync($this);
		            		$_la = $this->input->LA(1);
		            	}
		            	break;

		            case self::STAR:
		            	$this->setState(1798);
		            	$this->match(self::STAR);
		            	break;

		            case self::CLOSE_PAR:
		            	break;

		        default:
		        	break;
		        }
		        $this->setState(1801);
		        $this->match(self::CLOSE_PAR);
		        $this->setState(1803);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::FILTER_) {
		        	$this->setState(1802);
		        	$this->filter_clause();
		        }
		        $this->setState(1805);
		        $this->match(self::OVER_);
		        $this->setState(1808);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 268, $this->ctx)) {
		        	case 1:
		        	    $this->setState(1806);
		        	    $this->window_defn();
		        	break;

		        	case 2:
		        	    $this->setState(1807);
		        	    $this->window_name();
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function common_table_stmt(): Context\Common_table_stmtContext
		{
		    $localContext = new Context\Common_table_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 130, self::RULE_common_table_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1810);
		        $this->match(self::WITH_);
		        $this->setState(1812);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 269, $this->ctx)) {
		            case 1:
		        	    $this->setState(1811);
		        	    $this->match(self::RECURSIVE_);
		        	break;
		        }
		        $this->setState(1814);
		        $this->common_table_expression();
		        $this->setState(1819);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1815);
		        	$this->match(self::COMMA);
		        	$this->setState(1816);
		        	$this->common_table_expression();
		        	$this->setState(1821);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function order_by_stmt(): Context\Order_by_stmtContext
		{
		    $localContext = new Context\Order_by_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 132, self::RULE_order_by_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1822);
		        $this->match(self::ORDER_);
		        $this->setState(1823);
		        $this->match(self::BY_);
		        $this->setState(1824);
		        $this->ordering_term();
		        $this->setState(1829);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(1825);
		        	$this->match(self::COMMA);
		        	$this->setState(1826);
		        	$this->ordering_term();
		        	$this->setState(1831);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function limit_stmt(): Context\Limit_stmtContext
		{
		    $localContext = new Context\Limit_stmtContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 134, self::RULE_limit_stmt);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1832);
		        $this->match(self::LIMIT_);
		        $this->setState(1833);
		        $this->recursiveExpr(0);
		        $this->setState(1836);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::COMMA || $_la === self::OFFSET_) {
		        	$this->setState(1834);

		        	$_la = $this->input->LA(1);

		        	if (!($_la === self::COMMA || $_la === self::OFFSET_)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        	$this->setState(1835);
		        	$this->recursiveExpr(0);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function ordering_term(): Context\Ordering_termContext
		{
		    $localContext = new Context\Ordering_termContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 136, self::RULE_ordering_term);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1838);
		        $this->recursiveExpr(0);
		        $this->setState(1841);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::COLLATE_) {
		        	$this->setState(1839);
		        	$this->match(self::COLLATE_);
		        	$this->setState(1840);
		        	$this->collation_name();
		        }
		        $this->setState(1844);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ASC_ || $_la === self::DESC_) {
		        	$this->setState(1843);
		        	$this->asc_desc();
		        }
		        $this->setState(1848);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::NULLS_) {
		        	$this->setState(1846);
		        	$this->match(self::NULLS_);
		        	$this->setState(1847);

		        	$_la = $this->input->LA(1);

		        	if (!($_la === self::FIRST_ || $_la === self::LAST_)) {
		        	$this->errorHandler->recoverInline($this);
		        	} else {
		        		if ($this->input->LA(1) === Token::EOF) {
		        		    $this->matchedEOF = true;
		        	    }

		        		$this->errorHandler->reportMatch($this);
		        		$this->consume();
		        	}
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function asc_desc(): Context\Asc_descContext
		{
		    $localContext = new Context\Asc_descContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 138, self::RULE_asc_desc);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1850);

		        $_la = $this->input->LA(1);

		        if (!($_la === self::ASC_ || $_la === self::DESC_)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function frame_left(): Context\Frame_leftContext
		{
		    $localContext = new Context\Frame_leftContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 140, self::RULE_frame_left);

		    try {
		        $this->setState(1862);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 276, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(1852);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1853);
		        	    $this->match(self::PRECEDING_);
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(1855);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1856);
		        	    $this->match(self::FOLLOWING_);
		        	break;

		        	case 3:
		        	    $this->enterOuterAlt($localContext, 3);
		        	    $this->setState(1858);
		        	    $this->match(self::CURRENT_);
		        	    $this->setState(1859);
		        	    $this->match(self::ROW_);
		        	break;

		        	case 4:
		        	    $this->enterOuterAlt($localContext, 4);
		        	    $this->setState(1860);
		        	    $this->match(self::UNBOUNDED_);
		        	    $this->setState(1861);
		        	    $this->match(self::PRECEDING_);
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function frame_right(): Context\Frame_rightContext
		{
		    $localContext = new Context\Frame_rightContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 142, self::RULE_frame_right);

		    try {
		        $this->setState(1874);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 277, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(1864);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1865);
		        	    $this->match(self::PRECEDING_);
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(1867);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1868);
		        	    $this->match(self::FOLLOWING_);
		        	break;

		        	case 3:
		        	    $this->enterOuterAlt($localContext, 3);
		        	    $this->setState(1870);
		        	    $this->match(self::CURRENT_);
		        	    $this->setState(1871);
		        	    $this->match(self::ROW_);
		        	break;

		        	case 4:
		        	    $this->enterOuterAlt($localContext, 4);
		        	    $this->setState(1872);
		        	    $this->match(self::UNBOUNDED_);
		        	    $this->setState(1873);
		        	    $this->match(self::FOLLOWING_);
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function frame_single(): Context\Frame_singleContext
		{
		    $localContext = new Context\Frame_singleContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 144, self::RULE_frame_single);

		    try {
		        $this->setState(1883);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 278, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(1876);
		        	    $this->recursiveExpr(0);
		        	    $this->setState(1877);
		        	    $this->match(self::PRECEDING_);
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(1879);
		        	    $this->match(self::UNBOUNDED_);
		        	    $this->setState(1880);
		        	    $this->match(self::PRECEDING_);
		        	break;

		        	case 3:
		        	    $this->enterOuterAlt($localContext, 3);
		        	    $this->setState(1881);
		        	    $this->match(self::CURRENT_);
		        	    $this->setState(1882);
		        	    $this->match(self::ROW_);
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function window_function(): Context\Window_functionContext
		{
		    $localContext = new Context\Window_functionContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 146, self::RULE_window_function);

		    try {
		        $this->setState(1970);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::FIRST_VALUE_:
		            case self::LAST_VALUE_:
		            	$this->enterOuterAlt($localContext, 1);
		            	$this->setState(1885);

		            	$_la = $this->input->LA(1);

		            	if (!($_la === self::FIRST_VALUE_ || $_la === self::LAST_VALUE_)) {
		            	$this->errorHandler->recoverInline($this);
		            	} else {
		            		if ($this->input->LA(1) === Token::EOF) {
		            		    $this->matchedEOF = true;
		            	    }

		            		$this->errorHandler->reportMatch($this);
		            		$this->consume();
		            	}
		            	$this->setState(1886);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1887);
		            	$this->recursiveExpr(0);
		            	$this->setState(1888);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1889);
		            	$this->match(self::OVER_);
		            	$this->setState(1890);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1892);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::PARTITION_) {
		            		$this->setState(1891);
		            		$this->partition_by();
		            	}
		            	$this->setState(1894);
		            	$this->order_by_expr_asc_desc();
		            	$this->setState(1896);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if (((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 2251799880794113) !== 0) {
		            		$this->setState(1895);
		            		$this->frame_clause();
		            	}
		            	$this->setState(1898);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::CUME_DIST_:
		            case self::PERCENT_RANK_:
		            	$this->enterOuterAlt($localContext, 2);
		            	$this->setState(1900);

		            	$_la = $this->input->LA(1);

		            	if (!($_la === self::CUME_DIST_ || $_la === self::PERCENT_RANK_)) {
		            	$this->errorHandler->recoverInline($this);
		            	} else {
		            		if ($this->input->LA(1) === Token::EOF) {
		            		    $this->matchedEOF = true;
		            	    }

		            		$this->errorHandler->reportMatch($this);
		            		$this->consume();
		            	}
		            	$this->setState(1901);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1902);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1903);
		            	$this->match(self::OVER_);
		            	$this->setState(1904);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1906);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::PARTITION_) {
		            		$this->setState(1905);
		            		$this->partition_by();
		            	}
		            	$this->setState(1909);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::ORDER_) {
		            		$this->setState(1908);
		            		$this->order_by_expr();
		            	}
		            	$this->setState(1911);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::DENSE_RANK_:
		            case self::RANK_:
		            case self::ROW_NUMBER_:
		            	$this->enterOuterAlt($localContext, 3);
		            	$this->setState(1912);

		            	$_la = $this->input->LA(1);

		            	if (!(((($_la - 160)) & ~0x3f) === 0 && ((1 << ($_la - 160)) & 385) !== 0)) {
		            	$this->errorHandler->recoverInline($this);
		            	} else {
		            		if ($this->input->LA(1) === Token::EOF) {
		            		    $this->matchedEOF = true;
		            	    }

		            		$this->errorHandler->reportMatch($this);
		            		$this->consume();
		            	}
		            	$this->setState(1913);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1914);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1915);
		            	$this->match(self::OVER_);
		            	$this->setState(1916);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1918);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::PARTITION_) {
		            		$this->setState(1917);
		            		$this->partition_by();
		            	}
		            	$this->setState(1920);
		            	$this->order_by_expr_asc_desc();
		            	$this->setState(1921);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::LAG_:
		            case self::LEAD_:
		            	$this->enterOuterAlt($localContext, 4);
		            	$this->setState(1923);

		            	$_la = $this->input->LA(1);

		            	if (!($_la === self::LAG_ || $_la === self::LEAD_)) {
		            	$this->errorHandler->recoverInline($this);
		            	} else {
		            		if ($this->input->LA(1) === Token::EOF) {
		            		    $this->matchedEOF = true;
		            	    }

		            		$this->errorHandler->reportMatch($this);
		            		$this->consume();
		            	}
		            	$this->setState(1924);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1925);
		            	$this->recursiveExpr(0);
		            	$this->setState(1927);
		            	$this->errorHandler->sync($this);

		            	switch ($this->getInterpreter()->adaptivePredict($this->input, 284, $this->ctx)) {
		            	    case 1:
		            		    $this->setState(1926);
		            		    $this->offset();
		            		break;
		            	}
		            	$this->setState(1930);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::COMMA) {
		            		$this->setState(1929);
		            		$this->default_value();
		            	}
		            	$this->setState(1932);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1933);
		            	$this->match(self::OVER_);
		            	$this->setState(1934);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1936);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::PARTITION_) {
		            		$this->setState(1935);
		            		$this->partition_by();
		            	}
		            	$this->setState(1938);
		            	$this->order_by_expr_asc_desc();
		            	$this->setState(1939);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::NTH_VALUE_:
		            	$this->enterOuterAlt($localContext, 5);
		            	$this->setState(1941);
		            	$this->match(self::NTH_VALUE_);
		            	$this->setState(1942);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1943);
		            	$this->recursiveExpr(0);
		            	$this->setState(1944);
		            	$this->match(self::COMMA);
		            	$this->setState(1945);
		            	$this->signed_number();
		            	$this->setState(1946);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1947);
		            	$this->match(self::OVER_);
		            	$this->setState(1948);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1950);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::PARTITION_) {
		            		$this->setState(1949);
		            		$this->partition_by();
		            	}
		            	$this->setState(1952);
		            	$this->order_by_expr_asc_desc();
		            	$this->setState(1954);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if (((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 2251799880794113) !== 0) {
		            		$this->setState(1953);
		            		$this->frame_clause();
		            	}
		            	$this->setState(1956);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		            case self::NTILE_:
		            	$this->enterOuterAlt($localContext, 6);
		            	$this->setState(1958);
		            	$this->match(self::NTILE_);
		            	$this->setState(1959);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1960);
		            	$this->recursiveExpr(0);
		            	$this->setState(1961);
		            	$this->match(self::CLOSE_PAR);
		            	$this->setState(1962);
		            	$this->match(self::OVER_);
		            	$this->setState(1963);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(1965);
		            	$this->errorHandler->sync($this);
		            	$_la = $this->input->LA(1);

		            	if ($_la === self::PARTITION_) {
		            		$this->setState(1964);
		            		$this->partition_by();
		            	}
		            	$this->setState(1967);
		            	$this->order_by_expr_asc_desc();
		            	$this->setState(1968);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function offset(): Context\OffsetContext
		{
		    $localContext = new Context\OffsetContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 148, self::RULE_offset);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1972);
		        $this->match(self::COMMA);
		        $this->setState(1973);
		        $this->signed_number();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function default_value(): Context\Default_valueContext
		{
		    $localContext = new Context\Default_valueContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 150, self::RULE_default_value);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1975);
		        $this->match(self::COMMA);
		        $this->setState(1976);
		        $this->signed_number();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function partition_by(): Context\Partition_byContext
		{
		    $localContext = new Context\Partition_byContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 152, self::RULE_partition_by);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1978);
		        $this->match(self::PARTITION_);
		        $this->setState(1979);
		        $this->match(self::BY_);
		        $this->setState(1981); 
		        $this->errorHandler->sync($this);

		        $alt = 1;

		        do {
		        	switch ($alt) {
		        	case 1:
		        		$this->setState(1980);
		        		$this->recursiveExpr(0);
		        		break;
		        	default:
		        		throw new NoViableAltException($this);
		        	}

		        	$this->setState(1983); 
		        	$this->errorHandler->sync($this);

		        	$alt = $this->getInterpreter()->adaptivePredict($this->input, 291, $this->ctx);
		        } while ($alt !== 2 && $alt !== ATN::INVALID_ALT_NUMBER);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function order_by_expr(): Context\Order_by_exprContext
		{
		    $localContext = new Context\Order_by_exprContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 154, self::RULE_order_by_expr);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1985);
		        $this->match(self::ORDER_);
		        $this->setState(1986);
		        $this->match(self::BY_);
		        $this->setState(1988); 
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        do {
		        	$this->setState(1987);
		        	$this->recursiveExpr(0);
		        	$this->setState(1990); 
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        } while ((($_la) & ~0x3f) === 0 && ((1 << $_la) & -33552632) !== 0 || ((($_la - 64)) & ~0x3f) === 0 && ((1 << ($_la - 64)) & -1152921504606846977) !== 0 || ((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 4476578029606273023) !== 0);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function order_by_expr_asc_desc(): Context\Order_by_expr_asc_descContext
		{
		    $localContext = new Context\Order_by_expr_asc_descContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 156, self::RULE_order_by_expr_asc_desc);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1992);
		        $this->match(self::ORDER_);
		        $this->setState(1993);
		        $this->match(self::BY_);
		        $this->setState(1994);
		        $this->expr_asc_desc();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function expr_asc_desc(): Context\Expr_asc_descContext
		{
		    $localContext = new Context\Expr_asc_descContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 158, self::RULE_expr_asc_desc);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(1996);
		        $this->recursiveExpr(0);
		        $this->setState(1998);
		        $this->errorHandler->sync($this);
		        $_la = $this->input->LA(1);

		        if ($_la === self::ASC_ || $_la === self::DESC_) {
		        	$this->setState(1997);
		        	$this->asc_desc();
		        }
		        $this->setState(2007);
		        $this->errorHandler->sync($this);

		        $_la = $this->input->LA(1);
		        while ($_la === self::COMMA) {
		        	$this->setState(2000);
		        	$this->match(self::COMMA);
		        	$this->setState(2001);
		        	$this->recursiveExpr(0);
		        	$this->setState(2003);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);

		        	if ($_la === self::ASC_ || $_la === self::DESC_) {
		        		$this->setState(2002);
		        		$this->asc_desc();
		        	}
		        	$this->setState(2009);
		        	$this->errorHandler->sync($this);
		        	$_la = $this->input->LA(1);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function initial_select(): Context\Initial_selectContext
		{
		    $localContext = new Context\Initial_selectContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 160, self::RULE_initial_select);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2010);
		        $this->select_stmt();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function recursive_select(): Context\Recursive_selectContext
		{
		    $localContext = new Context\Recursive_selectContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 162, self::RULE_recursive_select);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2012);
		        $this->select_stmt();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function unary_operator(): Context\Unary_operatorContext
		{
		    $localContext = new Context\Unary_operatorContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 164, self::RULE_unary_operator);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2014);

		        $_la = $this->input->LA(1);

		        if (!((($_la) & ~0x3f) === 0 && ((1 << $_la) & 1792) !== 0 || $_la === self::NOT_)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function error_message(): Context\Error_messageContext
		{
		    $localContext = new Context\Error_messageContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 166, self::RULE_error_message);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2016);
		        $this->match(self::STRING_LITERAL);
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function module_argument(): Context\Module_argumentContext
		{
		    $localContext = new Context\Module_argumentContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 168, self::RULE_module_argument);

		    try {
		        $this->setState(2020);
		        $this->errorHandler->sync($this);

		        switch ($this->getInterpreter()->adaptivePredict($this->input, 296, $this->ctx)) {
		        	case 1:
		        	    $this->enterOuterAlt($localContext, 1);
		        	    $this->setState(2018);
		        	    $this->recursiveExpr(0);
		        	break;

		        	case 2:
		        	    $this->enterOuterAlt($localContext, 2);
		        	    $this->setState(2019);
		        	    $this->column_def();
		        	break;
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function column_alias(): Context\Column_aliasContext
		{
		    $localContext = new Context\Column_aliasContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 170, self::RULE_column_alias);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2022);

		        $_la = $this->input->LA(1);

		        if (!($_la === self::IDENTIFIER || $_la === self::STRING_LITERAL)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function keyword(): Context\KeywordContext
		{
		    $localContext = new Context\KeywordContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 172, self::RULE_keyword);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2024);

		        $_la = $this->input->LA(1);

		        if (!((($_la) & ~0x3f) === 0 && ((1 << $_la) & -33554432) !== 0 || ((($_la - 64)) & ~0x3f) === 0 && ((1 << ($_la - 64)) & -1152921504606846977) !== 0 || ((($_la - 128)) & ~0x3f) === 0 && ((1 << ($_la - 128)) & 9007199254740991) !== 0)) {
		        $this->errorHandler->recoverInline($this);
		        } else {
		        	if ($this->input->LA(1) === Token::EOF) {
		        	    $this->matchedEOF = true;
		            }

		        	$this->errorHandler->reportMatch($this);
		        	$this->consume();
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function name(): Context\NameContext
		{
		    $localContext = new Context\NameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 174, self::RULE_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2026);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function function_name(): Context\Function_nameContext
		{
		    $localContext = new Context\Function_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 176, self::RULE_function_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2028);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function schema_name(): Context\Schema_nameContext
		{
		    $localContext = new Context\Schema_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 178, self::RULE_schema_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2030);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function table_name(): Context\Table_nameContext
		{
		    $localContext = new Context\Table_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 180, self::RULE_table_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2032);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function table_or_index_name(): Context\Table_or_index_nameContext
		{
		    $localContext = new Context\Table_or_index_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 182, self::RULE_table_or_index_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2034);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function column_name(): Context\Column_nameContext
		{
		    $localContext = new Context\Column_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 184, self::RULE_column_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2036);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function collation_name(): Context\Collation_nameContext
		{
		    $localContext = new Context\Collation_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 186, self::RULE_collation_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2038);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function foreign_table(): Context\Foreign_tableContext
		{
		    $localContext = new Context\Foreign_tableContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 188, self::RULE_foreign_table);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2040);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function index_name(): Context\Index_nameContext
		{
		    $localContext = new Context\Index_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 190, self::RULE_index_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2042);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function trigger_name(): Context\Trigger_nameContext
		{
		    $localContext = new Context\Trigger_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 192, self::RULE_trigger_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2044);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function view_name(): Context\View_nameContext
		{
		    $localContext = new Context\View_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 194, self::RULE_view_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2046);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function module_name(): Context\Module_nameContext
		{
		    $localContext = new Context\Module_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 196, self::RULE_module_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2048);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function pragma_name(): Context\Pragma_nameContext
		{
		    $localContext = new Context\Pragma_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 198, self::RULE_pragma_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2050);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function savepoint_name(): Context\Savepoint_nameContext
		{
		    $localContext = new Context\Savepoint_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 200, self::RULE_savepoint_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2052);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function table_alias(): Context\Table_aliasContext
		{
		    $localContext = new Context\Table_aliasContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 202, self::RULE_table_alias);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2054);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function transaction_name(): Context\Transaction_nameContext
		{
		    $localContext = new Context\Transaction_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 204, self::RULE_transaction_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2056);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function window_name(): Context\Window_nameContext
		{
		    $localContext = new Context\Window_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 206, self::RULE_window_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2058);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function alias(): Context\AliasContext
		{
		    $localContext = new Context\AliasContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 208, self::RULE_alias);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2060);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function filename(): Context\FilenameContext
		{
		    $localContext = new Context\FilenameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 210, self::RULE_filename);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2062);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function base_window_name(): Context\Base_window_nameContext
		{
		    $localContext = new Context\Base_window_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 212, self::RULE_base_window_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2064);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function simple_func(): Context\Simple_funcContext
		{
		    $localContext = new Context\Simple_funcContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 214, self::RULE_simple_func);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2066);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function aggregate_func(): Context\Aggregate_funcContext
		{
		    $localContext = new Context\Aggregate_funcContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 216, self::RULE_aggregate_func);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2068);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function table_function_name(): Context\Table_function_nameContext
		{
		    $localContext = new Context\Table_function_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 218, self::RULE_table_function_name);

		    try {
		        $this->enterOuterAlt($localContext, 1);
		        $this->setState(2070);
		        $this->any_name();
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		/**
		 * @throws RecognitionException
		 */
		public function any_name(): Context\Any_nameContext
		{
		    $localContext = new Context\Any_nameContext($this->ctx, $this->getState());

		    $this->enterRule($localContext, 220, self::RULE_any_name);

		    try {
		        $this->setState(2079);
		        $this->errorHandler->sync($this);

		        switch ($this->input->LA(1)) {
		            case self::IDENTIFIER:
		            	$this->enterOuterAlt($localContext, 1);
		            	$this->setState(2072);
		            	$this->match(self::IDENTIFIER);
		            	break;

		            case self::ABORT_:
		            case self::ACTION_:
		            case self::ADD_:
		            case self::AFTER_:
		            case self::ALL_:
		            case self::ALTER_:
		            case self::ANALYZE_:
		            case self::AND_:
		            case self::AS_:
		            case self::ASC_:
		            case self::ATTACH_:
		            case self::AUTOINCREMENT_:
		            case self::BEFORE_:
		            case self::BEGIN_:
		            case self::BETWEEN_:
		            case self::BY_:
		            case self::CASCADE_:
		            case self::CASE_:
		            case self::CAST_:
		            case self::CHECK_:
		            case self::COLLATE_:
		            case self::COLUMN_:
		            case self::COMMIT_:
		            case self::CONFLICT_:
		            case self::CONSTRAINT_:
		            case self::CREATE_:
		            case self::CROSS_:
		            case self::CURRENT_DATE_:
		            case self::CURRENT_TIME_:
		            case self::CURRENT_TIMESTAMP_:
		            case self::DATABASE_:
		            case self::DEFAULT_:
		            case self::DEFERRABLE_:
		            case self::DEFERRED_:
		            case self::DELETE_:
		            case self::DESC_:
		            case self::DETACH_:
		            case self::DISTINCT_:
		            case self::DROP_:
		            case self::EACH_:
		            case self::ELSE_:
		            case self::END_:
		            case self::ESCAPE_:
		            case self::EXCEPT_:
		            case self::EXCLUSIVE_:
		            case self::EXISTS_:
		            case self::EXPLAIN_:
		            case self::FAIL_:
		            case self::FOR_:
		            case self::FOREIGN_:
		            case self::FROM_:
		            case self::FULL_:
		            case self::GLOB_:
		            case self::GROUP_:
		            case self::HAVING_:
		            case self::IF_:
		            case self::IGNORE_:
		            case self::IMMEDIATE_:
		            case self::IN_:
		            case self::INDEX_:
		            case self::INDEXED_:
		            case self::INITIALLY_:
		            case self::INNER_:
		            case self::INSERT_:
		            case self::INSTEAD_:
		            case self::INTERSECT_:
		            case self::INTO_:
		            case self::IS_:
		            case self::ISNULL_:
		            case self::JOIN_:
		            case self::KEY_:
		            case self::LEFT_:
		            case self::LIKE_:
		            case self::LIMIT_:
		            case self::MATCH_:
		            case self::NATURAL_:
		            case self::NO_:
		            case self::NOT_:
		            case self::NOTNULL_:
		            case self::NULL_:
		            case self::OF_:
		            case self::OFFSET_:
		            case self::ON_:
		            case self::OR_:
		            case self::ORDER_:
		            case self::OUTER_:
		            case self::PLAN_:
		            case self::PRAGMA_:
		            case self::PRIMARY_:
		            case self::QUERY_:
		            case self::RAISE_:
		            case self::RECURSIVE_:
		            case self::REFERENCES_:
		            case self::REGEXP_:
		            case self::REINDEX_:
		            case self::RELEASE_:
		            case self::RENAME_:
		            case self::REPLACE_:
		            case self::RESTRICT_:
		            case self::RIGHT_:
		            case self::ROLLBACK_:
		            case self::ROW_:
		            case self::ROWS_:
		            case self::SAVEPOINT_:
		            case self::SELECT_:
		            case self::SET_:
		            case self::TABLE_:
		            case self::TEMP_:
		            case self::TEMPORARY_:
		            case self::THEN_:
		            case self::TO_:
		            case self::TRANSACTION_:
		            case self::TRIGGER_:
		            case self::UNION_:
		            case self::UNIQUE_:
		            case self::UPDATE_:
		            case self::USING_:
		            case self::VACUUM_:
		            case self::VALUES_:
		            case self::VIEW_:
		            case self::VIRTUAL_:
		            case self::WHEN_:
		            case self::WHERE_:
		            case self::WITH_:
		            case self::WITHOUT_:
		            case self::FIRST_VALUE_:
		            case self::OVER_:
		            case self::PARTITION_:
		            case self::RANGE_:
		            case self::PRECEDING_:
		            case self::UNBOUNDED_:
		            case self::CURRENT_:
		            case self::FOLLOWING_:
		            case self::CUME_DIST_:
		            case self::DENSE_RANK_:
		            case self::LAG_:
		            case self::LAST_VALUE_:
		            case self::LEAD_:
		            case self::NTH_VALUE_:
		            case self::NTILE_:
		            case self::PERCENT_RANK_:
		            case self::RANK_:
		            case self::ROW_NUMBER_:
		            case self::GENERATED_:
		            case self::ALWAYS_:
		            case self::STORED_:
		            case self::TRUE_:
		            case self::FALSE_:
		            case self::WINDOW_:
		            case self::NULLS_:
		            case self::FIRST_:
		            case self::LAST_:
		            case self::FILTER_:
		            case self::GROUPS_:
		            case self::EXCLUDE_:
		            	$this->enterOuterAlt($localContext, 2);
		            	$this->setState(2073);
		            	$this->keyword();
		            	break;

		            case self::STRING_LITERAL:
		            	$this->enterOuterAlt($localContext, 3);
		            	$this->setState(2074);
		            	$this->match(self::STRING_LITERAL);
		            	break;

		            case self::OPEN_PAR:
		            	$this->enterOuterAlt($localContext, 4);
		            	$this->setState(2075);
		            	$this->match(self::OPEN_PAR);
		            	$this->setState(2076);
		            	$this->any_name();
		            	$this->setState(2077);
		            	$this->match(self::CLOSE_PAR);
		            	break;

		        default:
		        	throw new NoViableAltException($this);
		        }
		    } catch (RecognitionException $exception) {
		        $localContext->exception = $exception;
		        $this->errorHandler->reportError($this, $exception);
		        $this->errorHandler->recover($this, $exception);
		    } finally {
		        $this->exitRule();
		    }

		    return $localContext;
		}

		public function sempred(?RuleContext $localContext, int $ruleIndex, int $predicateIndex): bool
		{
			switch ($ruleIndex) {
					case 32:
						return $this->sempredExpr($localContext, $predicateIndex);

				default:
					return true;
				}
		}

		private function sempredExpr(?Context\ExprContext $localContext, int $predicateIndex): bool
		{
			switch ($predicateIndex) {
			    case 0:
			        return $this->precpred($this->ctx, 20);

			    case 1:
			        return $this->precpred($this->ctx, 19);

			    case 2:
			        return $this->precpred($this->ctx, 18);

			    case 3:
			        return $this->precpred($this->ctx, 17);

			    case 4:
			        return $this->precpred($this->ctx, 16);

			    case 5:
			        return $this->precpred($this->ctx, 15);

			    case 6:
			        return $this->precpred($this->ctx, 14);

			    case 7:
			        return $this->precpred($this->ctx, 13);

			    case 8:
			        return $this->precpred($this->ctx, 6);

			    case 9:
			        return $this->precpred($this->ctx, 5);

			    case 10:
			        return $this->precpred($this->ctx, 9);

			    case 11:
			        return $this->precpred($this->ctx, 8);

			    case 12:
			        return $this->precpred($this->ctx, 7);

			    case 13:
			        return $this->precpred($this->ctx, 4);
			}

			return true;
		}
	}
}

namespace Doctrine\DBAL\Generated\Context {
	use Antlr\Antlr4\Runtime\ParserRuleContext;
	use Antlr\Antlr4\Runtime\Token;
	use Antlr\Antlr4\Runtime\Tree\ParseTreeVisitor;
	use Antlr\Antlr4\Runtime\Tree\TerminalNode;
	use Antlr\Antlr4\Runtime\Tree\ParseTreeListener;
	use Doctrine\DBAL\Generated\SQLiteParser;
	use Doctrine\DBAL\Generated\SQLiteParserListener;

	class ParseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_parse;
	    }

	    public function EOF(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EOF, 0);
	    }

	    /**
	     * @return array<Sql_stmt_listContext>|Sql_stmt_listContext|null
	     */
	    public function sql_stmt_list(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Sql_stmt_listContext::class);
	    	}

	        return $this->getTypedRuleContext(Sql_stmt_listContext::class, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterParse($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitParse($this);
		    }
		}
	} 

	class Sql_stmt_listContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_sql_stmt_list;
	    }

	    /**
	     * @return array<Sql_stmtContext>|Sql_stmtContext|null
	     */
	    public function sql_stmt(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Sql_stmtContext::class);
	    	}

	        return $this->getTypedRuleContext(Sql_stmtContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function SCOL(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::SCOL);
	    	}

	        return $this->getToken(SQLiteParser::SCOL, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSql_stmt_list($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSql_stmt_list($this);
		    }
		}
	} 

	class Sql_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_sql_stmt;
	    }

	    public function alter_table_stmt(): ?Alter_table_stmtContext
	    {
	    	return $this->getTypedRuleContext(Alter_table_stmtContext::class, 0);
	    }

	    public function analyze_stmt(): ?Analyze_stmtContext
	    {
	    	return $this->getTypedRuleContext(Analyze_stmtContext::class, 0);
	    }

	    public function attach_stmt(): ?Attach_stmtContext
	    {
	    	return $this->getTypedRuleContext(Attach_stmtContext::class, 0);
	    }

	    public function begin_stmt(): ?Begin_stmtContext
	    {
	    	return $this->getTypedRuleContext(Begin_stmtContext::class, 0);
	    }

	    public function commit_stmt(): ?Commit_stmtContext
	    {
	    	return $this->getTypedRuleContext(Commit_stmtContext::class, 0);
	    }

	    public function create_index_stmt(): ?Create_index_stmtContext
	    {
	    	return $this->getTypedRuleContext(Create_index_stmtContext::class, 0);
	    }

	    public function create_table_stmt(): ?Create_table_stmtContext
	    {
	    	return $this->getTypedRuleContext(Create_table_stmtContext::class, 0);
	    }

	    public function create_trigger_stmt(): ?Create_trigger_stmtContext
	    {
	    	return $this->getTypedRuleContext(Create_trigger_stmtContext::class, 0);
	    }

	    public function create_view_stmt(): ?Create_view_stmtContext
	    {
	    	return $this->getTypedRuleContext(Create_view_stmtContext::class, 0);
	    }

	    public function create_virtual_table_stmt(): ?Create_virtual_table_stmtContext
	    {
	    	return $this->getTypedRuleContext(Create_virtual_table_stmtContext::class, 0);
	    }

	    public function delete_stmt(): ?Delete_stmtContext
	    {
	    	return $this->getTypedRuleContext(Delete_stmtContext::class, 0);
	    }

	    public function delete_stmt_limited(): ?Delete_stmt_limitedContext
	    {
	    	return $this->getTypedRuleContext(Delete_stmt_limitedContext::class, 0);
	    }

	    public function detach_stmt(): ?Detach_stmtContext
	    {
	    	return $this->getTypedRuleContext(Detach_stmtContext::class, 0);
	    }

	    public function drop_stmt(): ?Drop_stmtContext
	    {
	    	return $this->getTypedRuleContext(Drop_stmtContext::class, 0);
	    }

	    public function insert_stmt(): ?Insert_stmtContext
	    {
	    	return $this->getTypedRuleContext(Insert_stmtContext::class, 0);
	    }

	    public function pragma_stmt(): ?Pragma_stmtContext
	    {
	    	return $this->getTypedRuleContext(Pragma_stmtContext::class, 0);
	    }

	    public function reindex_stmt(): ?Reindex_stmtContext
	    {
	    	return $this->getTypedRuleContext(Reindex_stmtContext::class, 0);
	    }

	    public function release_stmt(): ?Release_stmtContext
	    {
	    	return $this->getTypedRuleContext(Release_stmtContext::class, 0);
	    }

	    public function rollback_stmt(): ?Rollback_stmtContext
	    {
	    	return $this->getTypedRuleContext(Rollback_stmtContext::class, 0);
	    }

	    public function savepoint_stmt(): ?Savepoint_stmtContext
	    {
	    	return $this->getTypedRuleContext(Savepoint_stmtContext::class, 0);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

	    public function update_stmt(): ?Update_stmtContext
	    {
	    	return $this->getTypedRuleContext(Update_stmtContext::class, 0);
	    }

	    public function update_stmt_limited(): ?Update_stmt_limitedContext
	    {
	    	return $this->getTypedRuleContext(Update_stmt_limitedContext::class, 0);
	    }

	    public function vacuum_stmt(): ?Vacuum_stmtContext
	    {
	    	return $this->getTypedRuleContext(Vacuum_stmtContext::class, 0);
	    }

	    public function EXPLAIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXPLAIN_, 0);
	    }

	    public function QUERY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::QUERY_, 0);
	    }

	    public function PLAN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PLAN_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSql_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSql_stmt($this);
		    }
		}
	} 

	class Alter_table_stmtContext extends ParserRuleContext
	{
		/**
		 * @var Table_nameContext|null $new_table_name
		 */
		public $new_table_name;

		/**
		 * @var Column_nameContext|null $old_column_name
		 */
		public $old_column_name;

		/**
		 * @var Column_nameContext|null $new_column_name
		 */
		public $new_column_name;

		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_alter_table_stmt;
	    }

	    public function ALTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALTER_, 0);
	    }

	    public function TABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TABLE_, 0);
	    }

	    /**
	     * @return array<Table_nameContext>|Table_nameContext|null
	     */
	    public function table_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Table_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Table_nameContext::class, $index);
	    }

	    public function RENAME_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RENAME_, 0);
	    }

	    public function ADD_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ADD_, 0);
	    }

	    public function column_def(): ?Column_defContext
	    {
	    	return $this->getTypedRuleContext(Column_defContext::class, 0);
	    }

	    public function DROP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DROP_, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function TO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TO_, 0);
	    }

	    public function COLUMN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLUMN_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAlter_table_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAlter_table_stmt($this);
		    }
		}
	} 

	class Analyze_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_analyze_stmt;
	    }

	    public function ANALYZE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ANALYZE_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function table_or_index_name(): ?Table_or_index_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_or_index_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAnalyze_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAnalyze_stmt($this);
		    }
		}
	} 

	class Attach_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_attach_stmt;
	    }

	    public function ATTACH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ATTACH_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DATABASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DATABASE_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAttach_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAttach_stmt($this);
		    }
		}
	} 

	class Begin_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_begin_stmt;
	    }

	    public function BEGIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BEGIN_, 0);
	    }

	    public function TRANSACTION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRANSACTION_, 0);
	    }

	    public function DEFERRED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFERRED_, 0);
	    }

	    public function IMMEDIATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IMMEDIATE_, 0);
	    }

	    public function EXCLUSIVE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXCLUSIVE_, 0);
	    }

	    public function transaction_name(): ?Transaction_nameContext
	    {
	    	return $this->getTypedRuleContext(Transaction_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterBegin_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitBegin_stmt($this);
		    }
		}
	} 

	class Commit_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_commit_stmt;
	    }

	    public function COMMIT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMIT_, 0);
	    }

	    public function END_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::END_, 0);
	    }

	    public function TRANSACTION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRANSACTION_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCommit_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCommit_stmt($this);
		    }
		}
	} 

	class Rollback_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_rollback_stmt;
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function TRANSACTION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRANSACTION_, 0);
	    }

	    public function TO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TO_, 0);
	    }

	    public function savepoint_name(): ?Savepoint_nameContext
	    {
	    	return $this->getTypedRuleContext(Savepoint_nameContext::class, 0);
	    }

	    public function SAVEPOINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SAVEPOINT_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterRollback_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitRollback_stmt($this);
		    }
		}
	} 

	class Savepoint_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_savepoint_stmt;
	    }

	    public function SAVEPOINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SAVEPOINT_, 0);
	    }

	    public function savepoint_name(): ?Savepoint_nameContext
	    {
	    	return $this->getTypedRuleContext(Savepoint_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSavepoint_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSavepoint_stmt($this);
		    }
		}
	} 

	class Release_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_release_stmt;
	    }

	    public function RELEASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RELEASE_, 0);
	    }

	    public function savepoint_name(): ?Savepoint_nameContext
	    {
	    	return $this->getTypedRuleContext(Savepoint_nameContext::class, 0);
	    }

	    public function SAVEPOINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SAVEPOINT_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterRelease_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitRelease_stmt($this);
		    }
		}
	} 

	class Create_index_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_create_index_stmt;
	    }

	    public function CREATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CREATE_, 0);
	    }

	    public function INDEX_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INDEX_, 0);
	    }

	    public function index_name(): ?Index_nameContext
	    {
	    	return $this->getTypedRuleContext(Index_nameContext::class, 0);
	    }

	    public function ON_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ON_, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Indexed_columnContext>|Indexed_columnContext|null
	     */
	    public function indexed_column(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Indexed_columnContext::class);
	    	}

	        return $this->getTypedRuleContext(Indexed_columnContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function UNIQUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNIQUE_, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCreate_index_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCreate_index_stmt($this);
		    }
		}
	} 

	class Indexed_columnContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_indexed_column;
	    }

	    public function column_name(): ?Column_nameContext
	    {
	    	return $this->getTypedRuleContext(Column_nameContext::class, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function COLLATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLLATE_, 0);
	    }

	    public function collation_name(): ?Collation_nameContext
	    {
	    	return $this->getTypedRuleContext(Collation_nameContext::class, 0);
	    }

	    public function asc_desc(): ?Asc_descContext
	    {
	    	return $this->getTypedRuleContext(Asc_descContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterIndexed_column($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitIndexed_column($this);
		    }
		}
	} 

	class Create_table_stmtContext extends ParserRuleContext
	{
		/**
		 * @var Token|null $row_ROW_ID
		 */
		public $row_ROW_ID;

		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_create_table_stmt;
	    }

	    public function CREATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CREATE_, 0);
	    }

	    public function TABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TABLE_, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Column_defContext>|Column_defContext|null
	     */
	    public function column_def(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_defContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_defContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function TEMP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMP_, 0);
	    }

	    public function TEMPORARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMPORARY_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    /**
	     * @return array<Table_constraintContext>|Table_constraintContext|null
	     */
	    public function table_constraint(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Table_constraintContext::class);
	    	}

	        return $this->getTypedRuleContext(Table_constraintContext::class, $index);
	    }

	    public function WITHOUT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WITHOUT_, 0);
	    }

	    public function IDENTIFIER(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IDENTIFIER, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCreate_table_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCreate_table_stmt($this);
		    }
		}
	} 

	class Column_defContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_column_def;
	    }

	    public function column_name(): ?Column_nameContext
	    {
	    	return $this->getTypedRuleContext(Column_nameContext::class, 0);
	    }

	    public function type_name(): ?Type_nameContext
	    {
	    	return $this->getTypedRuleContext(Type_nameContext::class, 0);
	    }

	    /**
	     * @return array<Column_constraintContext>|Column_constraintContext|null
	     */
	    public function column_constraint(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_constraintContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_constraintContext::class, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterColumn_def($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitColumn_def($this);
		    }
		}
	} 

	class Type_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_type_name;
	    }

	    /**
	     * @return array<NameContext>|NameContext|null
	     */
	    public function name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(NameContext::class);
	    	}

	        return $this->getTypedRuleContext(NameContext::class, $index);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Signed_numberContext>|Signed_numberContext|null
	     */
	    public function signed_number(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Signed_numberContext::class);
	    	}

	        return $this->getTypedRuleContext(Signed_numberContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterType_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitType_name($this);
		    }
		}
	} 

	class Column_constraintContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_column_constraint;
	    }

	    public function CHECK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CHECK_, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function DEFAULT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFAULT_, 0);
	    }

	    public function COLLATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLLATE_, 0);
	    }

	    public function collation_name(): ?Collation_nameContext
	    {
	    	return $this->getTypedRuleContext(Collation_nameContext::class, 0);
	    }

	    public function foreign_key_clause(): ?Foreign_key_clauseContext
	    {
	    	return $this->getTypedRuleContext(Foreign_key_clauseContext::class, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function CONSTRAINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CONSTRAINT_, 0);
	    }

	    public function name(): ?NameContext
	    {
	    	return $this->getTypedRuleContext(NameContext::class, 0);
	    }

	    public function PRIMARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRIMARY_, 0);
	    }

	    public function KEY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::KEY_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function NULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NULL_, 0);
	    }

	    public function UNIQUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNIQUE_, 0);
	    }

	    public function signed_number(): ?Signed_numberContext
	    {
	    	return $this->getTypedRuleContext(Signed_numberContext::class, 0);
	    }

	    public function literal_value(): ?Literal_valueContext
	    {
	    	return $this->getTypedRuleContext(Literal_valueContext::class, 0);
	    }

	    public function conflict_clause(): ?Conflict_clauseContext
	    {
	    	return $this->getTypedRuleContext(Conflict_clauseContext::class, 0);
	    }

	    public function GENERATED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GENERATED_, 0);
	    }

	    public function ALWAYS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALWAYS_, 0);
	    }

	    public function STORED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STORED_, 0);
	    }

	    public function VIRTUAL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VIRTUAL_, 0);
	    }

	    public function asc_desc(): ?Asc_descContext
	    {
	    	return $this->getTypedRuleContext(Asc_descContext::class, 0);
	    }

	    public function AUTOINCREMENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AUTOINCREMENT_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterColumn_constraint($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitColumn_constraint($this);
		    }
		}
	} 

	class Signed_numberContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_signed_number;
	    }

	    public function NUMERIC_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NUMERIC_LITERAL, 0);
	    }

	    public function PLUS(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PLUS, 0);
	    }

	    public function MINUS(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::MINUS, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSigned_number($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSigned_number($this);
		    }
		}
	} 

	class Table_constraintContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_table_constraint;
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Indexed_columnContext>|Indexed_columnContext|null
	     */
	    public function indexed_column(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Indexed_columnContext::class);
	    	}

	        return $this->getTypedRuleContext(Indexed_columnContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function CHECK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CHECK_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function FOREIGN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOREIGN_, 0);
	    }

	    public function KEY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::KEY_, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function foreign_key_clause(): ?Foreign_key_clauseContext
	    {
	    	return $this->getTypedRuleContext(Foreign_key_clauseContext::class, 0);
	    }

	    public function CONSTRAINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CONSTRAINT_, 0);
	    }

	    public function name(): ?NameContext
	    {
	    	return $this->getTypedRuleContext(NameContext::class, 0);
	    }

	    public function PRIMARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRIMARY_, 0);
	    }

	    public function UNIQUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNIQUE_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    public function conflict_clause(): ?Conflict_clauseContext
	    {
	    	return $this->getTypedRuleContext(Conflict_clauseContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTable_constraint($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTable_constraint($this);
		    }
		}
	} 

	class Foreign_key_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_foreign_key_clause;
	    }

	    public function REFERENCES_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REFERENCES_, 0);
	    }

	    public function foreign_table(): ?Foreign_tableContext
	    {
	    	return $this->getTypedRuleContext(Foreign_tableContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function ON_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::ON_);
	    	}

	        return $this->getToken(SQLiteParser::ON_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function MATCH_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::MATCH_);
	    	}

	        return $this->getToken(SQLiteParser::MATCH_, $index);
	    }

	    /**
	     * @return array<NameContext>|NameContext|null
	     */
	    public function name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(NameContext::class);
	    	}

	        return $this->getTypedRuleContext(NameContext::class, $index);
	    }

	    public function DEFERRABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFERRABLE_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function DELETE_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::DELETE_);
	    	}

	        return $this->getToken(SQLiteParser::DELETE_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function UPDATE_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::UPDATE_);
	    	}

	        return $this->getToken(SQLiteParser::UPDATE_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function SET_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::SET_);
	    	}

	        return $this->getToken(SQLiteParser::SET_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function CASCADE_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::CASCADE_);
	    	}

	        return $this->getToken(SQLiteParser::CASCADE_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function RESTRICT_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::RESTRICT_);
	    	}

	        return $this->getToken(SQLiteParser::RESTRICT_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function NO_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::NO_);
	    	}

	        return $this->getToken(SQLiteParser::NO_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function ACTION_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::ACTION_);
	    	}

	        return $this->getToken(SQLiteParser::ACTION_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function NULL_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::NULL_);
	    	}

	        return $this->getToken(SQLiteParser::NULL_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function DEFAULT_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::DEFAULT_);
	    	}

	        return $this->getToken(SQLiteParser::DEFAULT_, $index);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function INITIALLY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INITIALLY_, 0);
	    }

	    public function DEFERRED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFERRED_, 0);
	    }

	    public function IMMEDIATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IMMEDIATE_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterForeign_key_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitForeign_key_clause($this);
		    }
		}
	} 

	class Conflict_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_conflict_clause;
	    }

	    public function ON_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ON_, 0);
	    }

	    public function CONFLICT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CONFLICT_, 0);
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function ABORT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ABORT_, 0);
	    }

	    public function FAIL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FAIL_, 0);
	    }

	    public function IGNORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IGNORE_, 0);
	    }

	    public function REPLACE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REPLACE_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterConflict_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitConflict_clause($this);
		    }
		}
	} 

	class Create_trigger_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_create_trigger_stmt;
	    }

	    public function CREATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CREATE_, 0);
	    }

	    public function TRIGGER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRIGGER_, 0);
	    }

	    public function trigger_name(): ?Trigger_nameContext
	    {
	    	return $this->getTypedRuleContext(Trigger_nameContext::class, 0);
	    }

	    public function ON_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ON_, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function BEGIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BEGIN_, 0);
	    }

	    public function END_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::END_, 0);
	    }

	    public function DELETE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DELETE_, 0);
	    }

	    public function INSERT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INSERT_, 0);
	    }

	    public function UPDATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UPDATE_, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function BEFORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BEFORE_, 0);
	    }

	    public function AFTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AFTER_, 0);
	    }

	    public function INSTEAD_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INSTEAD_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function OF_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::OF_);
	    	}

	        return $this->getToken(SQLiteParser::OF_, $index);
	    }

	    public function FOR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOR_, 0);
	    }

	    public function EACH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EACH_, 0);
	    }

	    public function ROW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_, 0);
	    }

	    public function WHEN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHEN_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function SCOL(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::SCOL);
	    	}

	        return $this->getToken(SQLiteParser::SCOL, $index);
	    }

	    public function TEMP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMP_, 0);
	    }

	    public function TEMPORARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMPORARY_, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    /**
	     * @return array<Update_stmtContext>|Update_stmtContext|null
	     */
	    public function update_stmt(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Update_stmtContext::class);
	    	}

	        return $this->getTypedRuleContext(Update_stmtContext::class, $index);
	    }

	    /**
	     * @return array<Insert_stmtContext>|Insert_stmtContext|null
	     */
	    public function insert_stmt(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Insert_stmtContext::class);
	    	}

	        return $this->getTypedRuleContext(Insert_stmtContext::class, $index);
	    }

	    /**
	     * @return array<Delete_stmtContext>|Delete_stmtContext|null
	     */
	    public function delete_stmt(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Delete_stmtContext::class);
	    	}

	        return $this->getTypedRuleContext(Delete_stmtContext::class, $index);
	    }

	    /**
	     * @return array<Select_stmtContext>|Select_stmtContext|null
	     */
	    public function select_stmt(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Select_stmtContext::class);
	    	}

	        return $this->getTypedRuleContext(Select_stmtContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCreate_trigger_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCreate_trigger_stmt($this);
		    }
		}
	} 

	class Create_view_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_create_view_stmt;
	    }

	    public function CREATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CREATE_, 0);
	    }

	    public function VIEW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VIEW_, 0);
	    }

	    public function view_name(): ?View_nameContext
	    {
	    	return $this->getTypedRuleContext(View_nameContext::class, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function TEMP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMP_, 0);
	    }

	    public function TEMPORARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMPORARY_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCreate_view_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCreate_view_stmt($this);
		    }
		}
	} 

	class Create_virtual_table_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_create_virtual_table_stmt;
	    }

	    public function CREATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CREATE_, 0);
	    }

	    public function VIRTUAL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VIRTUAL_, 0);
	    }

	    public function TABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TABLE_, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function USING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::USING_, 0);
	    }

	    public function module_name(): ?Module_nameContext
	    {
	    	return $this->getTypedRuleContext(Module_nameContext::class, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Module_argumentContext>|Module_argumentContext|null
	     */
	    public function module_argument(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Module_argumentContext::class);
	    	}

	        return $this->getTypedRuleContext(Module_argumentContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCreate_virtual_table_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCreate_virtual_table_stmt($this);
		    }
		}
	} 

	class With_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_with_clause;
	    }

	    public function WITH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WITH_, 0);
	    }

	    /**
	     * @return array<Cte_table_nameContext>|Cte_table_nameContext|null
	     */
	    public function cte_table_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Cte_table_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Cte_table_nameContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function AS_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::AS_);
	    	}

	        return $this->getToken(SQLiteParser::AS_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function OPEN_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::OPEN_PAR);
	    	}

	        return $this->getToken(SQLiteParser::OPEN_PAR, $index);
	    }

	    /**
	     * @return array<Select_stmtContext>|Select_stmtContext|null
	     */
	    public function select_stmt(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Select_stmtContext::class);
	    	}

	        return $this->getTypedRuleContext(Select_stmtContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function CLOSE_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::CLOSE_PAR);
	    	}

	        return $this->getToken(SQLiteParser::CLOSE_PAR, $index);
	    }

	    public function RECURSIVE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RECURSIVE_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterWith_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitWith_clause($this);
		    }
		}
	} 

	class Cte_table_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_cte_table_name;
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCte_table_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCte_table_name($this);
		    }
		}
	} 

	class Recursive_cteContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_recursive_cte;
	    }

	    public function cte_table_name(): ?Cte_table_nameContext
	    {
	    	return $this->getTypedRuleContext(Cte_table_nameContext::class, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function initial_select(): ?Initial_selectContext
	    {
	    	return $this->getTypedRuleContext(Initial_selectContext::class, 0);
	    }

	    public function UNION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNION_, 0);
	    }

	    public function recursive_select(): ?Recursive_selectContext
	    {
	    	return $this->getTypedRuleContext(Recursive_selectContext::class, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function ALL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALL_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterRecursive_cte($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitRecursive_cte($this);
		    }
		}
	} 

	class Common_table_expressionContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_common_table_expression;
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function OPEN_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::OPEN_PAR);
	    	}

	        return $this->getToken(SQLiteParser::OPEN_PAR, $index);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function CLOSE_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::CLOSE_PAR);
	    	}

	        return $this->getToken(SQLiteParser::CLOSE_PAR, $index);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCommon_table_expression($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCommon_table_expression($this);
		    }
		}
	} 

	class Delete_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_delete_stmt;
	    }

	    public function DELETE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DELETE_, 0);
	    }

	    public function FROM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FROM_, 0);
	    }

	    public function qualified_table_name(): ?Qualified_table_nameContext
	    {
	    	return $this->getTypedRuleContext(Qualified_table_nameContext::class, 0);
	    }

	    public function with_clause(): ?With_clauseContext
	    {
	    	return $this->getTypedRuleContext(With_clauseContext::class, 0);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function returning_clause(): ?Returning_clauseContext
	    {
	    	return $this->getTypedRuleContext(Returning_clauseContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterDelete_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitDelete_stmt($this);
		    }
		}
	} 

	class Delete_stmt_limitedContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_delete_stmt_limited;
	    }

	    public function DELETE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DELETE_, 0);
	    }

	    public function FROM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FROM_, 0);
	    }

	    public function qualified_table_name(): ?Qualified_table_nameContext
	    {
	    	return $this->getTypedRuleContext(Qualified_table_nameContext::class, 0);
	    }

	    public function with_clause(): ?With_clauseContext
	    {
	    	return $this->getTypedRuleContext(With_clauseContext::class, 0);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function returning_clause(): ?Returning_clauseContext
	    {
	    	return $this->getTypedRuleContext(Returning_clauseContext::class, 0);
	    }

	    public function limit_stmt(): ?Limit_stmtContext
	    {
	    	return $this->getTypedRuleContext(Limit_stmtContext::class, 0);
	    }

	    public function order_by_stmt(): ?Order_by_stmtContext
	    {
	    	return $this->getTypedRuleContext(Order_by_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterDelete_stmt_limited($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitDelete_stmt_limited($this);
		    }
		}
	} 

	class Detach_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_detach_stmt;
	    }

	    public function DETACH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DETACH_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DATABASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DATABASE_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterDetach_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitDetach_stmt($this);
		    }
		}
	} 

	class Drop_stmtContext extends ParserRuleContext
	{
		/**
		 * @var Token|null $object
		 */
		public $object;

		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_drop_stmt;
	    }

	    public function DROP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DROP_, 0);
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

	    public function INDEX_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INDEX_, 0);
	    }

	    public function TABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TABLE_, 0);
	    }

	    public function TRIGGER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRIGGER_, 0);
	    }

	    public function VIEW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VIEW_, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterDrop_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitDrop_stmt($this);
		    }
		}
	} 

	class ExprContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_expr;
	    }

	    public function literal_value(): ?Literal_valueContext
	    {
	    	return $this->getTypedRuleContext(Literal_valueContext::class, 0);
	    }

	    public function BIND_PARAMETER(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BIND_PARAMETER, 0);
	    }

	    public function column_name(): ?Column_nameContext
	    {
	    	return $this->getTypedRuleContext(Column_nameContext::class, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function DOT(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::DOT);
	    	}

	        return $this->getToken(SQLiteParser::DOT, $index);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function unary_operator(): ?Unary_operatorContext
	    {
	    	return $this->getTypedRuleContext(Unary_operatorContext::class, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function function_name(): ?Function_nameContext
	    {
	    	return $this->getTypedRuleContext(Function_nameContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function STAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STAR, 0);
	    }

	    public function filter_clause(): ?Filter_clauseContext
	    {
	    	return $this->getTypedRuleContext(Filter_clauseContext::class, 0);
	    }

	    public function over_clause(): ?Over_clauseContext
	    {
	    	return $this->getTypedRuleContext(Over_clauseContext::class, 0);
	    }

	    public function DISTINCT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DISTINCT_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    public function CAST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CAST_, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function type_name(): ?Type_nameContext
	    {
	    	return $this->getTypedRuleContext(Type_nameContext::class, 0);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function CASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CASE_, 0);
	    }

	    public function END_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::END_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function WHEN_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::WHEN_);
	    	}

	        return $this->getToken(SQLiteParser::WHEN_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function THEN_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::THEN_);
	    	}

	        return $this->getToken(SQLiteParser::THEN_, $index);
	    }

	    public function ELSE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ELSE_, 0);
	    }

	    public function raise_function(): ?Raise_functionContext
	    {
	    	return $this->getTypedRuleContext(Raise_functionContext::class, 0);
	    }

	    public function PIPE2(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PIPE2, 0);
	    }

	    public function DIV(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DIV, 0);
	    }

	    public function MOD(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::MOD, 0);
	    }

	    public function PLUS(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PLUS, 0);
	    }

	    public function MINUS(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::MINUS, 0);
	    }

	    public function LT2(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LT2, 0);
	    }

	    public function GT2(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GT2, 0);
	    }

	    public function AMP(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AMP, 0);
	    }

	    public function PIPE(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PIPE, 0);
	    }

	    public function LT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LT, 0);
	    }

	    public function LT_EQ(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LT_EQ, 0);
	    }

	    public function GT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GT, 0);
	    }

	    public function GT_EQ(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GT_EQ, 0);
	    }

	    public function ASSIGN(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ASSIGN, 0);
	    }

	    public function EQ(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EQ, 0);
	    }

	    public function NOT_EQ1(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_EQ1, 0);
	    }

	    public function NOT_EQ2(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_EQ2, 0);
	    }

	    public function IS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IS_, 0);
	    }

	    public function IN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IN_, 0);
	    }

	    public function LIKE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LIKE_, 0);
	    }

	    public function GLOB_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GLOB_, 0);
	    }

	    public function MATCH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::MATCH_, 0);
	    }

	    public function REGEXP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REGEXP_, 0);
	    }

	    public function AND_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AND_, 0);
	    }

	    public function OR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OR_, 0);
	    }

	    public function BETWEEN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BETWEEN_, 0);
	    }

	    public function COLLATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLLATE_, 0);
	    }

	    public function collation_name(): ?Collation_nameContext
	    {
	    	return $this->getTypedRuleContext(Collation_nameContext::class, 0);
	    }

	    public function ESCAPE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ESCAPE_, 0);
	    }

	    public function ISNULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ISNULL_, 0);
	    }

	    public function NOTNULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOTNULL_, 0);
	    }

	    public function NULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NULL_, 0);
	    }

	    public function table_function_name(): ?Table_function_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_function_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterExpr($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitExpr($this);
		    }
		}
	} 

	class Raise_functionContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_raise_function;
	    }

	    public function RAISE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RAISE_, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function IGNORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IGNORE_, 0);
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

	    public function error_message(): ?Error_messageContext
	    {
	    	return $this->getTypedRuleContext(Error_messageContext::class, 0);
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function ABORT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ABORT_, 0);
	    }

	    public function FAIL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FAIL_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterRaise_function($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitRaise_function($this);
		    }
		}
	} 

	class Literal_valueContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_literal_value;
	    }

	    public function NUMERIC_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NUMERIC_LITERAL, 0);
	    }

	    public function STRING_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STRING_LITERAL, 0);
	    }

	    public function BLOB_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BLOB_LITERAL, 0);
	    }

	    public function NULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NULL_, 0);
	    }

	    public function TRUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRUE_, 0);
	    }

	    public function FALSE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FALSE_, 0);
	    }

	    public function CURRENT_TIME_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_TIME_, 0);
	    }

	    public function CURRENT_DATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_DATE_, 0);
	    }

	    public function CURRENT_TIMESTAMP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterLiteral_value($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitLiteral_value($this);
		    }
		}
	} 

	class Insert_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_insert_stmt;
	    }

	    public function INTO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INTO_, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function INSERT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INSERT_, 0);
	    }

	    public function REPLACE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REPLACE_, 0);
	    }

	    public function OR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OR_, 0);
	    }

	    public function DEFAULT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFAULT_, 0);
	    }

	    public function VALUES_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VALUES_, 0);
	    }

	    public function with_clause(): ?With_clauseContext
	    {
	    	return $this->getTypedRuleContext(With_clauseContext::class, 0);
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function ABORT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ABORT_, 0);
	    }

	    public function FAIL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FAIL_, 0);
	    }

	    public function IGNORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IGNORE_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function table_alias(): ?Table_aliasContext
	    {
	    	return $this->getTypedRuleContext(Table_aliasContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function OPEN_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::OPEN_PAR);
	    	}

	        return $this->getToken(SQLiteParser::OPEN_PAR, $index);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function CLOSE_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::CLOSE_PAR);
	    	}

	        return $this->getToken(SQLiteParser::CLOSE_PAR, $index);
	    }

	    public function returning_clause(): ?Returning_clauseContext
	    {
	    	return $this->getTypedRuleContext(Returning_clauseContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

	    public function upsert_clause(): ?Upsert_clauseContext
	    {
	    	return $this->getTypedRuleContext(Upsert_clauseContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterInsert_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitInsert_stmt($this);
		    }
		}
	} 

	class Returning_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_returning_clause;
	    }

	    public function RETURNING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RETURNING_, 0);
	    }

	    /**
	     * @return array<Result_columnContext>|Result_columnContext|null
	     */
	    public function result_column(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Result_columnContext::class);
	    	}

	        return $this->getTypedRuleContext(Result_columnContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterReturning_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitReturning_clause($this);
		    }
		}
	} 

	class Upsert_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_upsert_clause;
	    }

	    public function ON_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ON_, 0);
	    }

	    public function CONFLICT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CONFLICT_, 0);
	    }

	    public function DO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DO_, 0);
	    }

	    public function NOTHING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOTHING_, 0);
	    }

	    public function UPDATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UPDATE_, 0);
	    }

	    public function SET_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SET_, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Indexed_columnContext>|Indexed_columnContext|null
	     */
	    public function indexed_column(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Indexed_columnContext::class);
	    	}

	        return $this->getTypedRuleContext(Indexed_columnContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function ASSIGN(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::ASSIGN);
	    	}

	        return $this->getToken(SQLiteParser::ASSIGN, $index);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function WHERE_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::WHERE_);
	    	}

	        return $this->getToken(SQLiteParser::WHERE_, $index);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    /**
	     * @return array<Column_name_listContext>|Column_name_listContext|null
	     */
	    public function column_name_list(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_name_listContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_name_listContext::class, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterUpsert_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitUpsert_clause($this);
		    }
		}
	} 

	class Pragma_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_pragma_stmt;
	    }

	    public function PRAGMA_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRAGMA_, 0);
	    }

	    public function pragma_name(): ?Pragma_nameContext
	    {
	    	return $this->getTypedRuleContext(Pragma_nameContext::class, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function ASSIGN(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ASSIGN, 0);
	    }

	    public function pragma_value(): ?Pragma_valueContext
	    {
	    	return $this->getTypedRuleContext(Pragma_valueContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterPragma_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitPragma_stmt($this);
		    }
		}
	} 

	class Pragma_valueContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_pragma_value;
	    }

	    public function signed_number(): ?Signed_numberContext
	    {
	    	return $this->getTypedRuleContext(Signed_numberContext::class, 0);
	    }

	    public function name(): ?NameContext
	    {
	    	return $this->getTypedRuleContext(NameContext::class, 0);
	    }

	    public function STRING_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STRING_LITERAL, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterPragma_value($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitPragma_value($this);
		    }
		}
	} 

	class Reindex_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_reindex_stmt;
	    }

	    public function REINDEX_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REINDEX_, 0);
	    }

	    public function collation_name(): ?Collation_nameContext
	    {
	    	return $this->getTypedRuleContext(Collation_nameContext::class, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function index_name(): ?Index_nameContext
	    {
	    	return $this->getTypedRuleContext(Index_nameContext::class, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterReindex_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitReindex_stmt($this);
		    }
		}
	} 

	class Select_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_select_stmt;
	    }

	    /**
	     * @return array<Select_coreContext>|Select_coreContext|null
	     */
	    public function select_core(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Select_coreContext::class);
	    	}

	        return $this->getTypedRuleContext(Select_coreContext::class, $index);
	    }

	    public function common_table_stmt(): ?Common_table_stmtContext
	    {
	    	return $this->getTypedRuleContext(Common_table_stmtContext::class, 0);
	    }

	    /**
	     * @return array<Compound_operatorContext>|Compound_operatorContext|null
	     */
	    public function compound_operator(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Compound_operatorContext::class);
	    	}

	        return $this->getTypedRuleContext(Compound_operatorContext::class, $index);
	    }

	    public function order_by_stmt(): ?Order_by_stmtContext
	    {
	    	return $this->getTypedRuleContext(Order_by_stmtContext::class, 0);
	    }

	    public function limit_stmt(): ?Limit_stmtContext
	    {
	    	return $this->getTypedRuleContext(Limit_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSelect_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSelect_stmt($this);
		    }
		}
	} 

	class Join_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_join_clause;
	    }

	    /**
	     * @return array<Table_or_subqueryContext>|Table_or_subqueryContext|null
	     */
	    public function table_or_subquery(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Table_or_subqueryContext::class);
	    	}

	        return $this->getTypedRuleContext(Table_or_subqueryContext::class, $index);
	    }

	    /**
	     * @return array<Join_operatorContext>|Join_operatorContext|null
	     */
	    public function join_operator(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Join_operatorContext::class);
	    	}

	        return $this->getTypedRuleContext(Join_operatorContext::class, $index);
	    }

	    /**
	     * @return array<Join_constraintContext>|Join_constraintContext|null
	     */
	    public function join_constraint(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Join_constraintContext::class);
	    	}

	        return $this->getTypedRuleContext(Join_constraintContext::class, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterJoin_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitJoin_clause($this);
		    }
		}
	} 

	class Select_coreContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_select_core;
	    }

	    public function SELECT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SELECT_, 0);
	    }

	    /**
	     * @return array<Result_columnContext>|Result_columnContext|null
	     */
	    public function result_column(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Result_columnContext::class);
	    	}

	        return $this->getTypedRuleContext(Result_columnContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    public function FROM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FROM_, 0);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function GROUP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GROUP_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    public function WINDOW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WINDOW_, 0);
	    }

	    /**
	     * @return array<Window_nameContext>|Window_nameContext|null
	     */
	    public function window_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Window_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Window_nameContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function AS_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::AS_);
	    	}

	        return $this->getToken(SQLiteParser::AS_, $index);
	    }

	    /**
	     * @return array<Window_defnContext>|Window_defnContext|null
	     */
	    public function window_defn(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Window_defnContext::class);
	    	}

	        return $this->getTypedRuleContext(Window_defnContext::class, $index);
	    }

	    public function DISTINCT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DISTINCT_, 0);
	    }

	    public function ALL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALL_, 0);
	    }

	    /**
	     * @return array<Table_or_subqueryContext>|Table_or_subqueryContext|null
	     */
	    public function table_or_subquery(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Table_or_subqueryContext::class);
	    	}

	        return $this->getTypedRuleContext(Table_or_subqueryContext::class, $index);
	    }

	    public function join_clause(): ?Join_clauseContext
	    {
	    	return $this->getTypedRuleContext(Join_clauseContext::class, 0);
	    }

	    public function HAVING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::HAVING_, 0);
	    }

	    public function VALUES_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VALUES_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function OPEN_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::OPEN_PAR);
	    	}

	        return $this->getToken(SQLiteParser::OPEN_PAR, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function CLOSE_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::CLOSE_PAR);
	    	}

	        return $this->getToken(SQLiteParser::CLOSE_PAR, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSelect_core($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSelect_core($this);
		    }
		}
	} 

	class Factored_select_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_factored_select_stmt;
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFactored_select_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFactored_select_stmt($this);
		    }
		}
	} 

	class Simple_select_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_simple_select_stmt;
	    }

	    public function select_core(): ?Select_coreContext
	    {
	    	return $this->getTypedRuleContext(Select_coreContext::class, 0);
	    }

	    public function common_table_stmt(): ?Common_table_stmtContext
	    {
	    	return $this->getTypedRuleContext(Common_table_stmtContext::class, 0);
	    }

	    public function order_by_stmt(): ?Order_by_stmtContext
	    {
	    	return $this->getTypedRuleContext(Order_by_stmtContext::class, 0);
	    }

	    public function limit_stmt(): ?Limit_stmtContext
	    {
	    	return $this->getTypedRuleContext(Limit_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSimple_select_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSimple_select_stmt($this);
		    }
		}
	} 

	class Compound_select_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_compound_select_stmt;
	    }

	    /**
	     * @return array<Select_coreContext>|Select_coreContext|null
	     */
	    public function select_core(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Select_coreContext::class);
	    	}

	        return $this->getTypedRuleContext(Select_coreContext::class, $index);
	    }

	    public function common_table_stmt(): ?Common_table_stmtContext
	    {
	    	return $this->getTypedRuleContext(Common_table_stmtContext::class, 0);
	    }

	    public function order_by_stmt(): ?Order_by_stmtContext
	    {
	    	return $this->getTypedRuleContext(Order_by_stmtContext::class, 0);
	    }

	    public function limit_stmt(): ?Limit_stmtContext
	    {
	    	return $this->getTypedRuleContext(Limit_stmtContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function UNION_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::UNION_);
	    	}

	        return $this->getToken(SQLiteParser::UNION_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function INTERSECT_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::INTERSECT_);
	    	}

	        return $this->getToken(SQLiteParser::INTERSECT_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function EXCEPT_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::EXCEPT_);
	    	}

	        return $this->getToken(SQLiteParser::EXCEPT_, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function ALL_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::ALL_);
	    	}

	        return $this->getToken(SQLiteParser::ALL_, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCompound_select_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCompound_select_stmt($this);
		    }
		}
	} 

	class Table_or_subqueryContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_table_or_subquery;
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function table_alias(): ?Table_aliasContext
	    {
	    	return $this->getTypedRuleContext(Table_aliasContext::class, 0);
	    }

	    public function INDEXED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INDEXED_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    public function index_name(): ?Index_nameContext
	    {
	    	return $this->getTypedRuleContext(Index_nameContext::class, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function table_function_name(): ?Table_function_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_function_nameContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    /**
	     * @return array<Table_or_subqueryContext>|Table_or_subqueryContext|null
	     */
	    public function table_or_subquery(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Table_or_subqueryContext::class);
	    	}

	        return $this->getTypedRuleContext(Table_or_subqueryContext::class, $index);
	    }

	    public function join_clause(): ?Join_clauseContext
	    {
	    	return $this->getTypedRuleContext(Join_clauseContext::class, 0);
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTable_or_subquery($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTable_or_subquery($this);
		    }
		}
	} 

	class Result_columnContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_result_column;
	    }

	    public function STAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STAR, 0);
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function column_alias(): ?Column_aliasContext
	    {
	    	return $this->getTypedRuleContext(Column_aliasContext::class, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterResult_column($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitResult_column($this);
		    }
		}
	} 

	class Join_operatorContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_join_operator;
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

	    public function JOIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::JOIN_, 0);
	    }

	    public function NATURAL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NATURAL_, 0);
	    }

	    public function LEFT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LEFT_, 0);
	    }

	    public function INNER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INNER_, 0);
	    }

	    public function CROSS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CROSS_, 0);
	    }

	    public function OUTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OUTER_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterJoin_operator($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitJoin_operator($this);
		    }
		}
	} 

	class Join_constraintContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_join_constraint;
	    }

	    public function ON_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ON_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function USING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::USING_, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterJoin_constraint($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitJoin_constraint($this);
		    }
		}
	} 

	class Compound_operatorContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_compound_operator;
	    }

	    public function UNION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNION_, 0);
	    }

	    public function ALL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALL_, 0);
	    }

	    public function INTERSECT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INTERSECT_, 0);
	    }

	    public function EXCEPT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXCEPT_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCompound_operator($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCompound_operator($this);
		    }
		}
	} 

	class Update_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_update_stmt;
	    }

	    public function UPDATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UPDATE_, 0);
	    }

	    public function qualified_table_name(): ?Qualified_table_nameContext
	    {
	    	return $this->getTypedRuleContext(Qualified_table_nameContext::class, 0);
	    }

	    public function SET_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SET_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function ASSIGN(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::ASSIGN);
	    	}

	        return $this->getToken(SQLiteParser::ASSIGN, $index);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    /**
	     * @return array<Column_name_listContext>|Column_name_listContext|null
	     */
	    public function column_name_list(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_name_listContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_name_listContext::class, $index);
	    }

	    public function with_clause(): ?With_clauseContext
	    {
	    	return $this->getTypedRuleContext(With_clauseContext::class, 0);
	    }

	    public function OR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OR_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    public function FROM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FROM_, 0);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function returning_clause(): ?Returning_clauseContext
	    {
	    	return $this->getTypedRuleContext(Returning_clauseContext::class, 0);
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function ABORT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ABORT_, 0);
	    }

	    public function REPLACE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REPLACE_, 0);
	    }

	    public function FAIL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FAIL_, 0);
	    }

	    public function IGNORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IGNORE_, 0);
	    }

	    /**
	     * @return array<Table_or_subqueryContext>|Table_or_subqueryContext|null
	     */
	    public function table_or_subquery(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Table_or_subqueryContext::class);
	    	}

	        return $this->getTypedRuleContext(Table_or_subqueryContext::class, $index);
	    }

	    public function join_clause(): ?Join_clauseContext
	    {
	    	return $this->getTypedRuleContext(Join_clauseContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterUpdate_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitUpdate_stmt($this);
		    }
		}
	} 

	class Column_name_listContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_column_name_list;
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterColumn_name_list($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitColumn_name_list($this);
		    }
		}
	} 

	class Update_stmt_limitedContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_update_stmt_limited;
	    }

	    public function UPDATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UPDATE_, 0);
	    }

	    public function qualified_table_name(): ?Qualified_table_nameContext
	    {
	    	return $this->getTypedRuleContext(Qualified_table_nameContext::class, 0);
	    }

	    public function SET_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SET_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function ASSIGN(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::ASSIGN);
	    	}

	        return $this->getToken(SQLiteParser::ASSIGN, $index);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    /**
	     * @return array<Column_nameContext>|Column_nameContext|null
	     */
	    public function column_name(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_nameContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_nameContext::class, $index);
	    }

	    /**
	     * @return array<Column_name_listContext>|Column_name_listContext|null
	     */
	    public function column_name_list(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Column_name_listContext::class);
	    	}

	        return $this->getTypedRuleContext(Column_name_listContext::class, $index);
	    }

	    public function with_clause(): ?With_clauseContext
	    {
	    	return $this->getTypedRuleContext(With_clauseContext::class, 0);
	    }

	    public function OR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OR_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function returning_clause(): ?Returning_clauseContext
	    {
	    	return $this->getTypedRuleContext(Returning_clauseContext::class, 0);
	    }

	    public function limit_stmt(): ?Limit_stmtContext
	    {
	    	return $this->getTypedRuleContext(Limit_stmtContext::class, 0);
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function ABORT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ABORT_, 0);
	    }

	    public function REPLACE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REPLACE_, 0);
	    }

	    public function FAIL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FAIL_, 0);
	    }

	    public function IGNORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IGNORE_, 0);
	    }

	    public function order_by_stmt(): ?Order_by_stmtContext
	    {
	    	return $this->getTypedRuleContext(Order_by_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterUpdate_stmt_limited($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitUpdate_stmt_limited($this);
		    }
		}
	} 

	class Qualified_table_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_qualified_table_name;
	    }

	    public function table_name(): ?Table_nameContext
	    {
	    	return $this->getTypedRuleContext(Table_nameContext::class, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function DOT(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DOT, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function alias(): ?AliasContext
	    {
	    	return $this->getTypedRuleContext(AliasContext::class, 0);
	    }

	    public function INDEXED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INDEXED_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    public function index_name(): ?Index_nameContext
	    {
	    	return $this->getTypedRuleContext(Index_nameContext::class, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterQualified_table_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitQualified_table_name($this);
		    }
		}
	} 

	class Vacuum_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_vacuum_stmt;
	    }

	    public function VACUUM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VACUUM_, 0);
	    }

	    public function schema_name(): ?Schema_nameContext
	    {
	    	return $this->getTypedRuleContext(Schema_nameContext::class, 0);
	    }

	    public function INTO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INTO_, 0);
	    }

	    public function filename(): ?FilenameContext
	    {
	    	return $this->getTypedRuleContext(FilenameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterVacuum_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitVacuum_stmt($this);
		    }
		}
	} 

	class Filter_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_filter_clause;
	    }

	    public function FILTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FILTER_, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFilter_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFilter_clause($this);
		    }
		}
	} 

	class Window_defnContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_window_defn;
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function ORDER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ORDER_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function BY_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::BY_);
	    	}

	        return $this->getToken(SQLiteParser::BY_, $index);
	    }

	    /**
	     * @return array<Ordering_termContext>|Ordering_termContext|null
	     */
	    public function ordering_term(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Ordering_termContext::class);
	    	}

	        return $this->getTypedRuleContext(Ordering_termContext::class, $index);
	    }

	    public function base_window_name(): ?Base_window_nameContext
	    {
	    	return $this->getTypedRuleContext(Base_window_nameContext::class, 0);
	    }

	    public function PARTITION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PARTITION_, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function frame_spec(): ?Frame_specContext
	    {
	    	return $this->getTypedRuleContext(Frame_specContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterWindow_defn($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitWindow_defn($this);
		    }
		}
	} 

	class Over_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_over_clause;
	    }

	    public function OVER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OVER_, 0);
	    }

	    public function window_name(): ?Window_nameContext
	    {
	    	return $this->getTypedRuleContext(Window_nameContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function base_window_name(): ?Base_window_nameContext
	    {
	    	return $this->getTypedRuleContext(Base_window_nameContext::class, 0);
	    }

	    public function PARTITION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PARTITION_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function BY_(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::BY_);
	    	}

	        return $this->getToken(SQLiteParser::BY_, $index);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function ORDER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ORDER_, 0);
	    }

	    /**
	     * @return array<Ordering_termContext>|Ordering_termContext|null
	     */
	    public function ordering_term(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Ordering_termContext::class);
	    	}

	        return $this->getTypedRuleContext(Ordering_termContext::class, $index);
	    }

	    public function frame_spec(): ?Frame_specContext
	    {
	    	return $this->getTypedRuleContext(Frame_specContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterOver_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitOver_clause($this);
		    }
		}
	} 

	class Frame_specContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_frame_spec;
	    }

	    public function frame_clause(): ?Frame_clauseContext
	    {
	    	return $this->getTypedRuleContext(Frame_clauseContext::class, 0);
	    }

	    public function EXCLUDE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXCLUDE_, 0);
	    }

	    public function CURRENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_, 0);
	    }

	    public function ROW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_, 0);
	    }

	    public function GROUP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GROUP_, 0);
	    }

	    public function TIES_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TIES_, 0);
	    }

	    public function NO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NO_, 0);
	    }

	    public function OTHERS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OTHERS_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFrame_spec($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFrame_spec($this);
		    }
		}
	} 

	class Frame_clauseContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_frame_clause;
	    }

	    public function RANGE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RANGE_, 0);
	    }

	    public function ROWS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROWS_, 0);
	    }

	    public function GROUPS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GROUPS_, 0);
	    }

	    public function frame_single(): ?Frame_singleContext
	    {
	    	return $this->getTypedRuleContext(Frame_singleContext::class, 0);
	    }

	    public function BETWEEN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BETWEEN_, 0);
	    }

	    public function frame_left(): ?Frame_leftContext
	    {
	    	return $this->getTypedRuleContext(Frame_leftContext::class, 0);
	    }

	    public function AND_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AND_, 0);
	    }

	    public function frame_right(): ?Frame_rightContext
	    {
	    	return $this->getTypedRuleContext(Frame_rightContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFrame_clause($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFrame_clause($this);
		    }
		}
	} 

	class Simple_function_invocationContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_simple_function_invocation;
	    }

	    public function simple_func(): ?Simple_funcContext
	    {
	    	return $this->getTypedRuleContext(Simple_funcContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function STAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STAR, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSimple_function_invocation($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSimple_function_invocation($this);
		    }
		}
	} 

	class Aggregate_function_invocationContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_aggregate_function_invocation;
	    }

	    public function aggregate_func(): ?Aggregate_funcContext
	    {
	    	return $this->getTypedRuleContext(Aggregate_funcContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function STAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STAR, 0);
	    }

	    public function filter_clause(): ?Filter_clauseContext
	    {
	    	return $this->getTypedRuleContext(Filter_clauseContext::class, 0);
	    }

	    public function DISTINCT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DISTINCT_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAggregate_function_invocation($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAggregate_function_invocation($this);
		    }
		}
	} 

	class Window_function_invocationContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_window_function_invocation;
	    }

	    public function window_function(): ?Window_functionContext
	    {
	    	return $this->getTypedRuleContext(Window_functionContext::class, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

	    public function OVER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OVER_, 0);
	    }

	    public function window_defn(): ?Window_defnContext
	    {
	    	return $this->getTypedRuleContext(Window_defnContext::class, 0);
	    }

	    public function window_name(): ?Window_nameContext
	    {
	    	return $this->getTypedRuleContext(Window_nameContext::class, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function STAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STAR, 0);
	    }

	    public function filter_clause(): ?Filter_clauseContext
	    {
	    	return $this->getTypedRuleContext(Filter_clauseContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterWindow_function_invocation($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitWindow_function_invocation($this);
		    }
		}
	} 

	class Common_table_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_common_table_stmt;
	    }

	    public function WITH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WITH_, 0);
	    }

	    /**
	     * @return array<Common_table_expressionContext>|Common_table_expressionContext|null
	     */
	    public function common_table_expression(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Common_table_expressionContext::class);
	    	}

	        return $this->getTypedRuleContext(Common_table_expressionContext::class, $index);
	    }

	    public function RECURSIVE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RECURSIVE_, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCommon_table_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCommon_table_stmt($this);
		    }
		}
	} 

	class Order_by_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_order_by_stmt;
	    }

	    public function ORDER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ORDER_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    /**
	     * @return array<Ordering_termContext>|Ordering_termContext|null
	     */
	    public function ordering_term(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Ordering_termContext::class);
	    	}

	        return $this->getTypedRuleContext(Ordering_termContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterOrder_by_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitOrder_by_stmt($this);
		    }
		}
	} 

	class Limit_stmtContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_limit_stmt;
	    }

	    public function LIMIT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LIMIT_, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    public function OFFSET_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OFFSET_, 0);
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterLimit_stmt($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitLimit_stmt($this);
		    }
		}
	} 

	class Ordering_termContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_ordering_term;
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function COLLATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLLATE_, 0);
	    }

	    public function collation_name(): ?Collation_nameContext
	    {
	    	return $this->getTypedRuleContext(Collation_nameContext::class, 0);
	    }

	    public function asc_desc(): ?Asc_descContext
	    {
	    	return $this->getTypedRuleContext(Asc_descContext::class, 0);
	    }

	    public function NULLS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NULLS_, 0);
	    }

	    public function FIRST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FIRST_, 0);
	    }

	    public function LAST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LAST_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterOrdering_term($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitOrdering_term($this);
		    }
		}
	} 

	class Asc_descContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_asc_desc;
	    }

	    public function ASC_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ASC_, 0);
	    }

	    public function DESC_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DESC_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAsc_desc($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAsc_desc($this);
		    }
		}
	} 

	class Frame_leftContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_frame_left;
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function PRECEDING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRECEDING_, 0);
	    }

	    public function FOLLOWING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOLLOWING_, 0);
	    }

	    public function CURRENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_, 0);
	    }

	    public function ROW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_, 0);
	    }

	    public function UNBOUNDED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNBOUNDED_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFrame_left($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFrame_left($this);
		    }
		}
	} 

	class Frame_rightContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_frame_right;
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function PRECEDING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRECEDING_, 0);
	    }

	    public function FOLLOWING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOLLOWING_, 0);
	    }

	    public function CURRENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_, 0);
	    }

	    public function ROW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_, 0);
	    }

	    public function UNBOUNDED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNBOUNDED_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFrame_right($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFrame_right($this);
		    }
		}
	} 

	class Frame_singleContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_frame_single;
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function PRECEDING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRECEDING_, 0);
	    }

	    public function UNBOUNDED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNBOUNDED_, 0);
	    }

	    public function CURRENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_, 0);
	    }

	    public function ROW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFrame_single($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFrame_single($this);
		    }
		}
	} 

	class Window_functionContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_window_function;
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function OPEN_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::OPEN_PAR);
	    	}

	        return $this->getToken(SQLiteParser::OPEN_PAR, $index);
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function CLOSE_PAR(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::CLOSE_PAR);
	    	}

	        return $this->getToken(SQLiteParser::CLOSE_PAR, $index);
	    }

	    public function OVER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OVER_, 0);
	    }

	    public function order_by_expr_asc_desc(): ?Order_by_expr_asc_descContext
	    {
	    	return $this->getTypedRuleContext(Order_by_expr_asc_descContext::class, 0);
	    }

	    public function FIRST_VALUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FIRST_VALUE_, 0);
	    }

	    public function LAST_VALUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LAST_VALUE_, 0);
	    }

	    public function partition_by(): ?Partition_byContext
	    {
	    	return $this->getTypedRuleContext(Partition_byContext::class, 0);
	    }

	    public function frame_clause(): ?Frame_clauseContext
	    {
	    	return $this->getTypedRuleContext(Frame_clauseContext::class, 0);
	    }

	    public function CUME_DIST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CUME_DIST_, 0);
	    }

	    public function PERCENT_RANK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PERCENT_RANK_, 0);
	    }

	    public function order_by_expr(): ?Order_by_exprContext
	    {
	    	return $this->getTypedRuleContext(Order_by_exprContext::class, 0);
	    }

	    public function DENSE_RANK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DENSE_RANK_, 0);
	    }

	    public function RANK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RANK_, 0);
	    }

	    public function ROW_NUMBER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_NUMBER_, 0);
	    }

	    public function LAG_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LAG_, 0);
	    }

	    public function LEAD_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LEAD_, 0);
	    }

	    public function offset(): ?OffsetContext
	    {
	    	return $this->getTypedRuleContext(OffsetContext::class, 0);
	    }

	    public function default_value(): ?Default_valueContext
	    {
	    	return $this->getTypedRuleContext(Default_valueContext::class, 0);
	    }

	    public function NTH_VALUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NTH_VALUE_, 0);
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

	    public function signed_number(): ?Signed_numberContext
	    {
	    	return $this->getTypedRuleContext(Signed_numberContext::class, 0);
	    }

	    public function NTILE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NTILE_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterWindow_function($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitWindow_function($this);
		    }
		}
	} 

	class OffsetContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_offset;
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

	    public function signed_number(): ?Signed_numberContext
	    {
	    	return $this->getTypedRuleContext(Signed_numberContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterOffset($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitOffset($this);
		    }
		}
	} 

	class Default_valueContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_default_value;
	    }

	    public function COMMA(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMA, 0);
	    }

	    public function signed_number(): ?Signed_numberContext
	    {
	    	return $this->getTypedRuleContext(Signed_numberContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterDefault_value($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitDefault_value($this);
		    }
		}
	} 

	class Partition_byContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_partition_by;
	    }

	    public function PARTITION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PARTITION_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterPartition_by($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitPartition_by($this);
		    }
		}
	} 

	class Order_by_exprContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_order_by_expr;
	    }

	    public function ORDER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ORDER_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterOrder_by_expr($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitOrder_by_expr($this);
		    }
		}
	} 

	class Order_by_expr_asc_descContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_order_by_expr_asc_desc;
	    }

	    public function ORDER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ORDER_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    public function expr_asc_desc(): ?Expr_asc_descContext
	    {
	    	return $this->getTypedRuleContext(Expr_asc_descContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterOrder_by_expr_asc_desc($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitOrder_by_expr_asc_desc($this);
		    }
		}
	} 

	class Expr_asc_descContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_expr_asc_desc;
	    }

	    /**
	     * @return array<ExprContext>|ExprContext|null
	     */
	    public function expr(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(ExprContext::class);
	    	}

	        return $this->getTypedRuleContext(ExprContext::class, $index);
	    }

	    /**
	     * @return array<Asc_descContext>|Asc_descContext|null
	     */
	    public function asc_desc(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTypedRuleContexts(Asc_descContext::class);
	    	}

	        return $this->getTypedRuleContext(Asc_descContext::class, $index);
	    }

	    /**
	     * @return array<TerminalNode>|TerminalNode|null
	     */
	    public function COMMA(?int $index = null)
	    {
	    	if ($index === null) {
	    		return $this->getTokens(SQLiteParser::COMMA);
	    	}

	        return $this->getToken(SQLiteParser::COMMA, $index);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterExpr_asc_desc($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitExpr_asc_desc($this);
		    }
		}
	} 

	class Initial_selectContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_initial_select;
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterInitial_select($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitInitial_select($this);
		    }
		}
	} 

	class Recursive_selectContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_recursive_select;
	    }

	    public function select_stmt(): ?Select_stmtContext
	    {
	    	return $this->getTypedRuleContext(Select_stmtContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterRecursive_select($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitRecursive_select($this);
		    }
		}
	} 

	class Unary_operatorContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_unary_operator;
	    }

	    public function MINUS(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::MINUS, 0);
	    }

	    public function PLUS(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PLUS, 0);
	    }

	    public function TILDE(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TILDE, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterUnary_operator($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitUnary_operator($this);
		    }
		}
	} 

	class Error_messageContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_error_message;
	    }

	    public function STRING_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STRING_LITERAL, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterError_message($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitError_message($this);
		    }
		}
	} 

	class Module_argumentContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_module_argument;
	    }

	    public function expr(): ?ExprContext
	    {
	    	return $this->getTypedRuleContext(ExprContext::class, 0);
	    }

	    public function column_def(): ?Column_defContext
	    {
	    	return $this->getTypedRuleContext(Column_defContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterModule_argument($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitModule_argument($this);
		    }
		}
	} 

	class Column_aliasContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_column_alias;
	    }

	    public function IDENTIFIER(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IDENTIFIER, 0);
	    }

	    public function STRING_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STRING_LITERAL, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterColumn_alias($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitColumn_alias($this);
		    }
		}
	} 

	class KeywordContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_keyword;
	    }

	    public function ABORT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ABORT_, 0);
	    }

	    public function ACTION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ACTION_, 0);
	    }

	    public function ADD_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ADD_, 0);
	    }

	    public function AFTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AFTER_, 0);
	    }

	    public function ALL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALL_, 0);
	    }

	    public function ALTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALTER_, 0);
	    }

	    public function ANALYZE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ANALYZE_, 0);
	    }

	    public function AND_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AND_, 0);
	    }

	    public function AS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AS_, 0);
	    }

	    public function ASC_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ASC_, 0);
	    }

	    public function ATTACH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ATTACH_, 0);
	    }

	    public function AUTOINCREMENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::AUTOINCREMENT_, 0);
	    }

	    public function BEFORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BEFORE_, 0);
	    }

	    public function BEGIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BEGIN_, 0);
	    }

	    public function BETWEEN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BETWEEN_, 0);
	    }

	    public function BY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::BY_, 0);
	    }

	    public function CASCADE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CASCADE_, 0);
	    }

	    public function CASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CASE_, 0);
	    }

	    public function CAST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CAST_, 0);
	    }

	    public function CHECK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CHECK_, 0);
	    }

	    public function COLLATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLLATE_, 0);
	    }

	    public function COLUMN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COLUMN_, 0);
	    }

	    public function COMMIT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::COMMIT_, 0);
	    }

	    public function CONFLICT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CONFLICT_, 0);
	    }

	    public function CONSTRAINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CONSTRAINT_, 0);
	    }

	    public function CREATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CREATE_, 0);
	    }

	    public function CROSS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CROSS_, 0);
	    }

	    public function CURRENT_DATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_DATE_, 0);
	    }

	    public function CURRENT_TIME_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_TIME_, 0);
	    }

	    public function CURRENT_TIMESTAMP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
	    }

	    public function DATABASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DATABASE_, 0);
	    }

	    public function DEFAULT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFAULT_, 0);
	    }

	    public function DEFERRABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFERRABLE_, 0);
	    }

	    public function DEFERRED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DEFERRED_, 0);
	    }

	    public function DELETE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DELETE_, 0);
	    }

	    public function DESC_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DESC_, 0);
	    }

	    public function DETACH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DETACH_, 0);
	    }

	    public function DISTINCT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DISTINCT_, 0);
	    }

	    public function DROP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DROP_, 0);
	    }

	    public function EACH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EACH_, 0);
	    }

	    public function ELSE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ELSE_, 0);
	    }

	    public function END_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::END_, 0);
	    }

	    public function ESCAPE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ESCAPE_, 0);
	    }

	    public function EXCEPT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXCEPT_, 0);
	    }

	    public function EXCLUSIVE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXCLUSIVE_, 0);
	    }

	    public function EXISTS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXISTS_, 0);
	    }

	    public function EXPLAIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXPLAIN_, 0);
	    }

	    public function FAIL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FAIL_, 0);
	    }

	    public function FOR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOR_, 0);
	    }

	    public function FOREIGN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOREIGN_, 0);
	    }

	    public function FROM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FROM_, 0);
	    }

	    public function FULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FULL_, 0);
	    }

	    public function GLOB_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GLOB_, 0);
	    }

	    public function GROUP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GROUP_, 0);
	    }

	    public function HAVING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::HAVING_, 0);
	    }

	    public function IF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IF_, 0);
	    }

	    public function IGNORE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IGNORE_, 0);
	    }

	    public function IMMEDIATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IMMEDIATE_, 0);
	    }

	    public function IN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IN_, 0);
	    }

	    public function INDEX_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INDEX_, 0);
	    }

	    public function INDEXED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INDEXED_, 0);
	    }

	    public function INITIALLY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INITIALLY_, 0);
	    }

	    public function INNER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INNER_, 0);
	    }

	    public function INSERT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INSERT_, 0);
	    }

	    public function INSTEAD_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INSTEAD_, 0);
	    }

	    public function INTERSECT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INTERSECT_, 0);
	    }

	    public function INTO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::INTO_, 0);
	    }

	    public function IS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IS_, 0);
	    }

	    public function ISNULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ISNULL_, 0);
	    }

	    public function JOIN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::JOIN_, 0);
	    }

	    public function KEY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::KEY_, 0);
	    }

	    public function LEFT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LEFT_, 0);
	    }

	    public function LIKE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LIKE_, 0);
	    }

	    public function LIMIT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LIMIT_, 0);
	    }

	    public function MATCH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::MATCH_, 0);
	    }

	    public function NATURAL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NATURAL_, 0);
	    }

	    public function NO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NO_, 0);
	    }

	    public function NOT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOT_, 0);
	    }

	    public function NOTNULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NOTNULL_, 0);
	    }

	    public function NULL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NULL_, 0);
	    }

	    public function OF_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OF_, 0);
	    }

	    public function OFFSET_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OFFSET_, 0);
	    }

	    public function ON_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ON_, 0);
	    }

	    public function OR_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OR_, 0);
	    }

	    public function ORDER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ORDER_, 0);
	    }

	    public function OUTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OUTER_, 0);
	    }

	    public function PLAN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PLAN_, 0);
	    }

	    public function PRAGMA_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRAGMA_, 0);
	    }

	    public function PRIMARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRIMARY_, 0);
	    }

	    public function QUERY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::QUERY_, 0);
	    }

	    public function RAISE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RAISE_, 0);
	    }

	    public function RECURSIVE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RECURSIVE_, 0);
	    }

	    public function REFERENCES_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REFERENCES_, 0);
	    }

	    public function REGEXP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REGEXP_, 0);
	    }

	    public function REINDEX_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REINDEX_, 0);
	    }

	    public function RELEASE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RELEASE_, 0);
	    }

	    public function RENAME_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RENAME_, 0);
	    }

	    public function REPLACE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::REPLACE_, 0);
	    }

	    public function RESTRICT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RESTRICT_, 0);
	    }

	    public function RIGHT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RIGHT_, 0);
	    }

	    public function ROLLBACK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROLLBACK_, 0);
	    }

	    public function ROW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_, 0);
	    }

	    public function ROWS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROWS_, 0);
	    }

	    public function SAVEPOINT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SAVEPOINT_, 0);
	    }

	    public function SELECT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SELECT_, 0);
	    }

	    public function SET_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::SET_, 0);
	    }

	    public function TABLE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TABLE_, 0);
	    }

	    public function TEMP_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMP_, 0);
	    }

	    public function TEMPORARY_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TEMPORARY_, 0);
	    }

	    public function THEN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::THEN_, 0);
	    }

	    public function TO_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TO_, 0);
	    }

	    public function TRANSACTION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRANSACTION_, 0);
	    }

	    public function TRIGGER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRIGGER_, 0);
	    }

	    public function UNION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNION_, 0);
	    }

	    public function UNIQUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNIQUE_, 0);
	    }

	    public function UPDATE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UPDATE_, 0);
	    }

	    public function USING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::USING_, 0);
	    }

	    public function VACUUM_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VACUUM_, 0);
	    }

	    public function VALUES_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VALUES_, 0);
	    }

	    public function VIEW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VIEW_, 0);
	    }

	    public function VIRTUAL_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::VIRTUAL_, 0);
	    }

	    public function WHEN_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHEN_, 0);
	    }

	    public function WHERE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WHERE_, 0);
	    }

	    public function WITH_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WITH_, 0);
	    }

	    public function WITHOUT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WITHOUT_, 0);
	    }

	    public function FIRST_VALUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FIRST_VALUE_, 0);
	    }

	    public function OVER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OVER_, 0);
	    }

	    public function PARTITION_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PARTITION_, 0);
	    }

	    public function RANGE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RANGE_, 0);
	    }

	    public function PRECEDING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PRECEDING_, 0);
	    }

	    public function UNBOUNDED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::UNBOUNDED_, 0);
	    }

	    public function CURRENT_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CURRENT_, 0);
	    }

	    public function FOLLOWING_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FOLLOWING_, 0);
	    }

	    public function CUME_DIST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CUME_DIST_, 0);
	    }

	    public function DENSE_RANK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::DENSE_RANK_, 0);
	    }

	    public function LAG_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LAG_, 0);
	    }

	    public function LAST_VALUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LAST_VALUE_, 0);
	    }

	    public function LEAD_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LEAD_, 0);
	    }

	    public function NTH_VALUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NTH_VALUE_, 0);
	    }

	    public function NTILE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NTILE_, 0);
	    }

	    public function PERCENT_RANK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::PERCENT_RANK_, 0);
	    }

	    public function RANK_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::RANK_, 0);
	    }

	    public function ROW_NUMBER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ROW_NUMBER_, 0);
	    }

	    public function GENERATED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GENERATED_, 0);
	    }

	    public function ALWAYS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::ALWAYS_, 0);
	    }

	    public function STORED_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STORED_, 0);
	    }

	    public function TRUE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::TRUE_, 0);
	    }

	    public function FALSE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FALSE_, 0);
	    }

	    public function WINDOW_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::WINDOW_, 0);
	    }

	    public function NULLS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::NULLS_, 0);
	    }

	    public function FIRST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FIRST_, 0);
	    }

	    public function LAST_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::LAST_, 0);
	    }

	    public function FILTER_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::FILTER_, 0);
	    }

	    public function GROUPS_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::GROUPS_, 0);
	    }

	    public function EXCLUDE_(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::EXCLUDE_, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterKeyword($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitKeyword($this);
		    }
		}
	} 

	class NameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterName($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitName($this);
		    }
		}
	} 

	class Function_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_function_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFunction_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFunction_name($this);
		    }
		}
	} 

	class Schema_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_schema_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSchema_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSchema_name($this);
		    }
		}
	} 

	class Table_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_table_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTable_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTable_name($this);
		    }
		}
	} 

	class Table_or_index_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_table_or_index_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTable_or_index_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTable_or_index_name($this);
		    }
		}
	} 

	class Column_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_column_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterColumn_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitColumn_name($this);
		    }
		}
	} 

	class Collation_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_collation_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterCollation_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitCollation_name($this);
		    }
		}
	} 

	class Foreign_tableContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_foreign_table;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterForeign_table($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitForeign_table($this);
		    }
		}
	} 

	class Index_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_index_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterIndex_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitIndex_name($this);
		    }
		}
	} 

	class Trigger_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_trigger_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTrigger_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTrigger_name($this);
		    }
		}
	} 

	class View_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_view_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterView_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitView_name($this);
		    }
		}
	} 

	class Module_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_module_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterModule_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitModule_name($this);
		    }
		}
	} 

	class Pragma_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_pragma_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterPragma_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitPragma_name($this);
		    }
		}
	} 

	class Savepoint_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_savepoint_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSavepoint_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSavepoint_name($this);
		    }
		}
	} 

	class Table_aliasContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_table_alias;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTable_alias($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTable_alias($this);
		    }
		}
	} 

	class Transaction_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_transaction_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTransaction_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTransaction_name($this);
		    }
		}
	} 

	class Window_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_window_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterWindow_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitWindow_name($this);
		    }
		}
	} 

	class AliasContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_alias;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAlias($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAlias($this);
		    }
		}
	} 

	class FilenameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_filename;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterFilename($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitFilename($this);
		    }
		}
	} 

	class Base_window_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_base_window_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterBase_window_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitBase_window_name($this);
		    }
		}
	} 

	class Simple_funcContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_simple_func;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterSimple_func($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitSimple_func($this);
		    }
		}
	} 

	class Aggregate_funcContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_aggregate_func;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAggregate_func($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAggregate_func($this);
		    }
		}
	} 

	class Table_function_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_table_function_name;
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterTable_function_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitTable_function_name($this);
		    }
		}
	} 

	class Any_nameContext extends ParserRuleContext
	{
		public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
		{
			parent::__construct($parent, $invokingState);
		}

		public function getRuleIndex(): int
		{
		    return SQLiteParser::RULE_any_name;
	    }

	    public function IDENTIFIER(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::IDENTIFIER, 0);
	    }

	    public function keyword(): ?KeywordContext
	    {
	    	return $this->getTypedRuleContext(KeywordContext::class, 0);
	    }

	    public function STRING_LITERAL(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::STRING_LITERAL, 0);
	    }

	    public function OPEN_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::OPEN_PAR, 0);
	    }

	    public function any_name(): ?Any_nameContext
	    {
	    	return $this->getTypedRuleContext(Any_nameContext::class, 0);
	    }

	    public function CLOSE_PAR(): ?TerminalNode
	    {
	        return $this->getToken(SQLiteParser::CLOSE_PAR, 0);
	    }

		public function enterRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->enterAny_name($this);
		    }
		}

		public function exitRule(ParseTreeListener $listener): void
		{
			if ($listener instanceof SQLiteParserListener) {
			    $listener->exitAny_name($this);
		    }
		}
	} 
}
